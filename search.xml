<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>my-first-blog</title>
    <url>/2022/08/26/my-first-blog/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="我的第一篇博客"><a href="#我的第一篇博客" class="headerlink" title="我的第一篇博客"></a>我的第一篇博客</h3>]]></content>
      <categories>
        <category>旅行</category>
        <category>国内</category>
      </categories>
      <tags>
        <tag>旅行</tag>
        <tag>国内</tag>
      </tags>
  </entry>
  <entry>
    <title>C++输入输出-文件IO</title>
    <url>/2022/08/31/C-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-%E6%96%87%E4%BB%B6IO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-输入输出–文件IO"><a href="#C-输入输出–文件IO" class="headerlink" title="C++输入输出–文件IO"></a>C++输入输出–文件IO</h1><h2 id="1、文件流类和文件流对象"><a href="#1、文件流类和文件流对象" class="headerlink" title="1、文件流类和文件流对象"></a>1、文件流类和文件流对象</h2><p>输入输出是以系统指定的标准设备（输入设备为键盘，输出设备为显示器）为对象的。在实际应用中，常以磁盘文件作为对象。即从磁盘文件读取数据，将数据输出到磁盘文件。<span id="more"></span></p>
<p>和文件有关系的输入输出类主要在fstream.h这个头文件中被定义，在这个头文件中主要被定义了三个类，由这三个类控制对文件的各种输入输出操 作，他们分别是ifstream、ofstream、fstream，其中fstream类是由iostream类派生而来，他们之间的继承关系见下图所示：</p>
<p><img src="https://pic.imgdb.cn/item/630f16a616f2c2beb1a3d351.jpg"></p>
<p>由于文件设备并不像显示器屏幕与键盘那样是标准默认设备，所以它在fstream.h头文件中是没有像cout那样预先定义的全局对象，所以我们必须自己定义一个该类的对象。</p>
<ul>
<li><p>ifstream类，它是从istream类派生的，用来支持从磁盘文件的输入。</p>
</li>
<li><p>ofstream类，它是从ostream类派生的，用来支持向磁盘文件的输出。</p>
</li>
<li><p>fstream类，它是从iostream类派生的，用来支持对磁盘文件的输入输出。</p>
</li>
</ul>
<h2 id="2、文件打开和关闭"><a href="#2、文件打开和关闭" class="headerlink" title="2、文件打开和关闭"></a>2、文件打开和关闭</h2><p>C++根据文件（file）内容的数据格式，可分为两类：</p>
<ul>
<li><p>文本文件：由字符序列组成，在文本文件中存取的最小信息单位为字符（character），也称ASCII码文件。</p>
</li>
<li><p>二进制文件：存取的最小信息单位为字节（Byte）。</p>
</li>
</ul>
<p>C++把每个文件都看成一个有序的字节流，每一个文件或者以文件结束符（end of file marker）结束，或者在特定的字节号处结束，如下图所示。</p>
<p><img src="https://pic.imgdb.cn/item/630f16c216f2c2beb1a3e3ba.jpg"></p>
<p>当打开一个文件时，该文件就和某个流关联起来了。对文件进行读写实际上受到一个文件定位指针（file position pointer）的控制。输入流的指针也称为读指针，每一次提取操作将从读指针当前所指位置开始，每次提取操作自动将读指针向文件尾移动。输出流指针也称写指针，每一次插入操作将从写指针当前位置开始，每次插入操作自动将写指针向文件尾移动。 </p>
<h3 id="2-1、文件打开"><a href="#2-1、文件打开" class="headerlink" title="2.1、文件打开"></a>2.1、文件打开</h3><p>打开文件是指在文件读写之前做必要的准备工作，包括：</p>
<ul>
<li><p>为文件流对象和指定的磁盘文件建立关联，以便使文件流流向指定的磁盘文件。</p>
</li>
<li><p>指定文件的工作方式，如，该文件是作为输入文件还是输出文件，是ASCII文件还是二进制文件等。</p>
</li>
</ul>
<p>以上工作可以通过两种不同的方法实现。</p>
<ol>
<li>调用文件流的成员函数open。如</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ofstream outfile;  <span class="comment">//定义ofstream类(输出文件流类)对象outfile</span></span><br><span class="line"></span><br><span class="line">outfile.<span class="built_in">open</span>(<span class="string">&quot;f1.dat&quot;</span>,ios::out);  <span class="comment">//使文件流与f1.dat文件建立关联</span></span><br></pre></td></tr></table></figure>

<p>第2行是调用输出文件流的成员函数open打开磁盘文件f1.dat，并指定它为输出文件， 文件流对象outfile将向磁盘文件f1.dat输出数据。ios::out是I&#x2F;O模式的一种，表示以输出方式打开一个文件。或者简单地说，此时f1.dat是一个输出文件，接收从内存输出的数据。</p>
<p>调用成员函数open的一般形式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">文件流对象.<span class="built_in">open</span>(磁盘文件名, 输入输出方式);</span><br></pre></td></tr></table></figure>

<p>磁盘文件名可以包括路径，如”c:\new\f1.dat”，如缺省路径，则默认为当前目录下的文件。</p>
<ol start="2">
<li>在定义文件流对象时指定参数</li>
</ol>
<p>在声明文件流类时定义了带参数的构造函数，其中包含了打开磁盘文件的功能。因此，可以在定义文件流对象时指定参数，调用文件流类的构造函数来实现打开文件的功能。如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream <span class="title">outfile</span><span class="params">(<span class="string">&quot;f1.dat&quot;</span>,ios::out)</span></span>; 一般多用此形式，比较方便。作用与open函数相同。</span><br></pre></td></tr></table></figure>

<p>输入输出方式是在ios类中定义的，它们是枚举常量，有多种选择。</p>
<p>需要注意的是：</p>
<ol>
<li><p>每一个打开的文件都有一个文件指针，该指针的初始位置由I&#x2F;O方式指定，每次读写都从文件指针的当前位置开始。每读入一个字节，指针就后移一个字节。当文 件指针移到最后，就会遇到文件结束EOF（文件结束符也占一个字节，其值为-1)，此时流对象的成员函数eof的值为非0值(一般设为1)，表示文件结束 了。</p>
</li>
<li><p>可以用“位或”运算符“|”对输入输出方式进行组合，如表13.6中最后3行所示那样。还可以举出下面一些例子：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ios::in | ios:: noreplace  <span class="comment">//打开一个输入文件，若文件不存在则返回打开失败的信息</span></span><br><span class="line">ios::app | ios::nocreate  <span class="comment">//打开一个输出文件，在文件尾接着写数据，若文件不存在，则返回打开失败的信息</span></span><br><span class="line">ios::out l ios::noreplace  <span class="comment">//打开一个新文件作为输出文件，如果文件已存在则返回打开失败的信息</span></span><br><span class="line">ios::in l ios::out I ios::binary  <span class="comment">//打开一个二进制文件，可读可写</span></span><br></pre></td></tr></table></figure>

<p>但不能组合互相排斥的方式，如 ios::nocreate l ios::noreplace。</p>
<ol start="3">
<li>如果打开操作失败，open函数的返回值为0(假)，如果是用调用构造函数的方式打开文件的，则流对象的值为0。可以据此测试打开是否成功。如</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span>(outfile.<span class="built_in">open</span>(<span class="string">&quot;f1.bat&quot;</span>, ios::app) ==<span class="number">0</span>)</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;open error&quot;</span>;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">  <span class="keyword">if</span>( !outfile.<span class="built_in">open</span>(<span class="string">&quot;f1.bat&quot;</span>, ios::app) )</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;open error&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-2、文件关闭"><a href="#2-2、文件关闭" class="headerlink" title="2.2、文件关闭"></a>2.2、文件关闭</h3><p>在对已打开的磁盘文件的读写操作完成后，应关闭该文件。关闭文件用成员函数close。如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">outfile.<span class="built_in">close</span>( );  <span class="comment">//将输出文件流所关联的磁盘文件关闭</span></span><br></pre></td></tr></table></figure>

<p>关闭文件，实际上是解除该磁盘文件与文件流的关联，原来设置的工作方式也失效，这样，就不能再通过文件流对该文件进行输入或输出。此时可以将文件流与其他磁盘文件建立关联，通过文件流对新的文件进行输入或输出。如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">outfile.<span class="built_in">open</span>(<span class="string">&quot;f2.dat&quot;</span>,ios::app|ios::nocreate);</span><br></pre></td></tr></table></figure>

<p>此时文件流outfile与f2.dat建立关联，并指定了f2.dat的工作方式。</p>
<p>关闭文件并没有取消文件流对象，该文件流对象又可与其他磁盘文件建立联系。文件流对象在程序结束时，或它的生命期结束时，由析构函数撤消。它同时释放内部分配的预留缓冲区。 </p>
<h3 id="2-3、文件操作的5个步骤"><a href="#2-3、文件操作的5个步骤" class="headerlink" title="2.3、文件操作的5个步骤"></a>2.3、文件操作的5个步骤</h3><p>可以总结出文件使用的5步骤：</p>
<p>①说明一个文件流对象，这又被称为内部文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ifstream ifile；<span class="comment">//只输入用</span></span><br><span class="line">ofstream ofile；<span class="comment">//只输出用</span></span><br><span class="line">fstream iofile；<span class="comment">//既输入又输出用</span></span><br></pre></td></tr></table></figure>

<p>②使用文件流对象的成员函数打开一个磁盘文件。这样在文件流对象和磁盘文件名之间建立联系。文件流中说明了三个打开文件的成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ifstream::open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*,<span class="type">int</span>=ios::in,<span class="type">int</span>=filebuf::openprot)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ofstream::open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*,<span class="type">int</span>=ios::out,<span class="type">int</span>=filebuf::openprot)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fstream::open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*,<span class="type">int</span>,<span class="type">int</span>=filebuf::openprot)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一个参数为要打开的磁盘文件名。第二个参数为打开方式，有输入（in），输出（out）等，打开方式在ios基类中定义为枚举类型。第三个参数为指定打开文件的保护方式，一般取默认。所以第二步可如下进行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">iofile.<span class="built_in">open</span>(“myfile.txt”,ios::in|ios::out);</span><br></pre></td></tr></table></figure>

<p>上面三个文件流类都重载了一个带默认参数的构造函数，功能与open函数一样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ifstream::ifstream(<span class="type">const</span> <span class="type">char</span>*,<span class="type">int</span>=ios::in,<span class="type">int</span>=filebuf::openprot);</span><br><span class="line">ofstream::<span class="built_in">ofstream</span>(<span class="type">const</span> <span class="type">char</span>*,<span class="type">int</span>=ios::out,<span class="type">int</span>=filebuf::openprot);</span><br><span class="line">fstream::<span class="built_in">fstream</span>(<span class="type">const</span> <span class="type">char</span>*,<span class="type">int</span>,<span class="type">int</span>=filebuf::operprot);</span><br></pre></td></tr></table></figure>

<p>所以①和②两步可合成： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">iofile</span><span class="params">(”myfile.txt”,ios::in|ios::out)</span></span>;</span><br></pre></td></tr></table></figure>

<p>③打开文件也应该判断是否成功，若成功，文件流对象值为非零值，不成功为0（NULL），文件流对象值物理上就是指它的地址。因此打开一个文件完整的程序为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fstream iofile（”myfile.txt”,ios::in|ios::out）;</span><br><span class="line"><span class="keyword">if</span>(!iofile)</span><br><span class="line">&#123; <span class="comment">//“！”为重载的运算符</span></span><br><span class="line">    cout&lt;&lt;”不能打开文件:”&lt;&lt;”myfile,txt”&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="comment">//失败退回操作系统</span></span><br></pre></td></tr></table></figure>

<p>④使用提取和插入运算符对文件进行读写操作，或使用成员函数进行读写</p>
<p>⑤关闭文件。三个文件流类各有一个关闭文件的成员函数 :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ifstream::close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ofstream::close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fstream::close</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用很方便，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">iofile.<span class="built_in">close</span>(); </span><br></pre></td></tr></table></figure>

<h2 id="3、C-对ASCII文件的读写操作"><a href="#3、C-对ASCII文件的读写操作" class="headerlink" title="3、C++对ASCII文件的读写操作"></a>3、C++对ASCII文件的读写操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fstream&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> fileName[<span class="number">80</span>];</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">255</span>];</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入一个文件名: &quot;</span>;</span><br><span class="line">	cin &gt;&gt; fileName;</span><br><span class="line"></span><br><span class="line">	<span class="function">ofstream <span class="title">fout</span><span class="params">(fileName, ios::app)</span></span>;</span><br><span class="line">	fout &lt;&lt; <span class="string">&quot;1111111111111111111\n&quot;</span>;</span><br><span class="line">	fout &lt;&lt; <span class="string">&quot;22222222222222222\n&quot;</span>;</span><br><span class="line">	<span class="comment">//cin.ignore(1,&#x27;\n&#x27;);</span></span><br><span class="line">	cin.<span class="built_in">getline</span>(buffer,<span class="number">255</span>); <span class="comment">//从键盘输入</span></span><br><span class="line">	fout &lt;&lt; buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	fout.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function">ifstream <span class="title">fin</span><span class="params">(fileName)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Here&#x27;s the the content of the file: \n&quot;</span>;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="keyword">while</span>(fin.<span class="built_in">get</span>(ch))</span><br><span class="line">		cout &lt;&lt; ch;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n***End of file contents.***\n&quot;</span>;</span><br><span class="line">	fin.<span class="built_in">close</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line">usingnamespace std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        ifstream myfile; </span><br><span class="line">        myfile.<span class="built_in">open</span>(<span class="string">&quot;c:\\test.txt&quot;</span>,ios::in,<span class="number">0</span>); </span><br><span class="line">        <span class="keyword">if</span>(!myfile) </span><br><span class="line">        &#123; </span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;文件读错误&quot;</span>; </span><br><span class="line">                <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); </span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">char</span> ch; </span><br><span class="line">        string content; </span><br><span class="line">        <span class="keyword">while</span>(myfile.<span class="built_in">get</span>(ch)) </span><br><span class="line">        &#123; </span><br><span class="line">                content+=ch; </span><br><span class="line">                cout.<span class="built_in">put</span>(ch);<span class="comment">//cout&lt;&lt;ch;这么写也是可以的 </span></span><br><span class="line">        &#125; </span><br><span class="line">        myfile.<span class="built_in">close</span>(); </span><br><span class="line">        cout&lt;&lt;content; </span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、C-对二进制文件的读写操作"><a href="#4、C-对二进制文件的读写操作" class="headerlink" title="4、C++对二进制文件的读写操作"></a>4、C++对二进制文件的读写操作</h2><p>用成员函数read和write读写二进制文件，对二进制文件的读写主要用istream类的成员函数read和write来实现。这两个成员函数的原型为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">(<span class="type">char</span> *buffer,<span class="type">int</span> len)</span></span>;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * buffer,<span class="type">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure>

<p>字符指针buffer指向内存中一段存储空间。len是读写的字节数。调用的方式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a. <span class="built_in">write</span>(p1,<span class="number">50</span>);</span><br><span class="line">b. <span class="built_in">read</span>(p2,<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>上面第一行中的a是输出文件流对象，write函数将字符指针p1所给出的地址开始的50个字节的内容不加转换地写到磁盘文件中。在第二行中，b是输入文 件流对象，read 函数从b所关联的磁盘文件中，读入30个字节(或遇EOF结束），存放在字符指针p2所指的一段空间内。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建二进制数据文件，以及数据文件的读取。这两项操作设计为成员函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">inventory</span>&#123;</span><br><span class="line">	string Description;</span><br><span class="line">	string No;</span><br><span class="line">	<span class="type">int</span> Quantity;</span><br><span class="line">	<span class="type">double</span> Cost;</span><br><span class="line">	<span class="type">double</span> Retail;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">inventory</span>(string=<span class="string">&quot;#&quot;</span>,string=<span class="string">&quot;0&quot;</span>,<span class="type">int</span> =<span class="number">0</span>,<span class="type">double</span> =<span class="number">0</span>,<span class="type">double</span> =<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream&amp;,inventory&amp;);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bdatatofile</span><span class="params">(ofstream&amp;dist)</span></span>;     <span class="comment">//文件流类作为形式参数必须是引用</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bdatafromfile</span><span class="params">(ifstream&amp;sour)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">inventory::<span class="built_in">inventory</span>(string des,string no,<span class="type">int</span> quan,<span class="type">double</span> cost,<span class="type">double</span> ret)&#123;</span><br><span class="line">	Description=des;</span><br><span class="line">	No=no;</span><br><span class="line">	Quantity=quan;</span><br><span class="line">	Cost=cost;</span><br><span class="line">	Retail=ret;</span><br><span class="line">&#125;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream&amp;dist,inventory&amp;iv)&#123;</span><br><span class="line">	dist&lt;&lt;left&lt;&lt;<span class="built_in">setw</span>(<span class="number">20</span>)&lt;&lt;iv.Description&lt;&lt;<span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;iv.No;</span><br><span class="line">	dist&lt;&lt;right&lt;&lt;<span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;iv.Quantity&lt;&lt;<span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;iv.Cost&lt;&lt;<span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;iv.Retail&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inventory::Bdatatofile</span><span class="params">(ofstream&amp;dist)</span></span>&#123;</span><br><span class="line">	dist.<span class="built_in">write</span>(Description.<span class="built_in">c_str</span>(),<span class="number">20</span>); <span class="comment">//由string类的c_str()函数转为char*</span></span><br><span class="line">	dist.<span class="built_in">write</span>(No.<span class="built_in">c_str</span>(),<span class="number">10</span>);</span><br><span class="line">	dist.<span class="built_in">write</span>((<span class="type">char</span>*)&amp;Quantity,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	dist.<span class="built_in">write</span>((<span class="type">char</span>*)&amp;Cost,<span class="built_in">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">	dist.<span class="built_in">write</span>((<span class="type">char</span>*)&amp;Retail,<span class="built_in">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inventory::Bdatafromfile</span><span class="params">(ifstream&amp;sour)</span></span>&#123;</span><br><span class="line">	<span class="type">char</span> k[<span class="number">20</span>];</span><br><span class="line">	sour.<span class="built_in">read</span>(k,<span class="number">20</span>);</span><br><span class="line">	Description=k;</span><br><span class="line">	sour.<span class="built_in">read</span>(k,<span class="number">10</span>);</span><br><span class="line">	No=k;</span><br><span class="line">	sour.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;Quantity,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	sour.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;Cost,<span class="built_in">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">	sour.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;Retail,<span class="built_in">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">&#125;<span class="comment">//由此可见读和写是完全对称的过程,次序决不能错</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">inventory <span class="title">car1</span><span class="params">(<span class="string">&quot;夏利2000&quot;</span>,<span class="string">&quot;805637928&quot;</span>,<span class="number">156</span>,<span class="number">80000</span>,<span class="number">105000</span>)</span>,car2</span>;</span><br><span class="line">	<span class="function">inventory <span class="title">motor1</span><span class="params">(<span class="string">&quot;金城125&quot;</span>,<span class="string">&quot;93612575&quot;</span>,<span class="number">302</span>,<span class="number">10000</span>,<span class="number">13000</span>)</span>,motor2</span>;</span><br><span class="line">	<span class="function">ofstream <span class="title">ddatafile</span><span class="params">(<span class="string">&quot;d:\\Ex9_10.data&quot;</span>,ios::out|ios::binary)</span></span>;</span><br><span class="line">	car1.<span class="built_in">Bdatatofile</span>(ddatafile);</span><br><span class="line">	motor1.<span class="built_in">Bdatatofile</span>(ddatafile);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;对象car1:&quot;</span>&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;car1;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;对象motor1:&quot;</span>&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;motor1;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;对象car2:&quot;</span>&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;car2;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;对象motor2:&quot;</span>&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;motor2;</span><br><span class="line">	ddatafile.<span class="built_in">close</span>();</span><br><span class="line">	<span class="function">ifstream <span class="title">sdatafile</span><span class="params">(<span class="string">&quot;d:\\Ex9_10.data&quot;</span>,ios::in|ios::binary)</span></span>;<span class="comment">//重新打开文件,从头读取数据</span></span><br><span class="line">	car2.<span class="built_in">Bdatafromfile</span>(sdatafile);                         <span class="comment">//从文件读取数据拷贝到对象car2</span></span><br><span class="line">	<span class="keyword">if</span>(sdatafile.<span class="built_in">eof</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;读文件成功&quot;</span>&lt;&lt;endl; </span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;对象car2:&quot;</span>&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;car2;</span><br><span class="line">	motor2.<span class="built_in">Bdatafromfile</span>(sdatafile);                 <span class="comment">//继续从文件读取数据拷贝到对象motor2</span></span><br><span class="line">	<span class="keyword">if</span>(sdatafile.<span class="built_in">eof</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;读文件成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;对象motor2:&quot;</span>&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;motor2;</span><br><span class="line">	sdatafile.<span class="built_in">close</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 文件结束判断：读函数并不能知道文件是否结束，可用状态函数int ios::eof()来判断文件是否结束。必须指出系统是根据当前操作的实际情况设置状态位，如需根据状态位来判断下一步的操作，必须在一次操作后立即去调取状态位，以判断本次操作是否有效。 </p>
<p> 二进制文件优点：可以控制字节长度，读写数据时不会出现二义性，可靠性高。同时不知格式是无法读取的，保密性好。文件结束后，系统不会再读，但程序不会自动停下来，所以要判断文件中是否已没有数据。如写完数据后没有关闭文件，直接开始读，则必须把文件定位指针移到文件头。如关闭文件后重新打开，文件定位指针就在文件头。 </p>
]]></content>
      <categories>
        <category>技术</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++输入输出-标准IO流</title>
    <url>/2022/08/31/C-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-%E6%A0%87%E5%87%86IO%E6%B5%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-输入输出–标准IO流"><a href="#C-输入输出–标准IO流" class="headerlink" title="C++输入输出–标准IO流"></a>C++输入输出–标准IO流</h1><h2 id="1、I-x2F-O流的概念和流类库的结构"><a href="#1、I-x2F-O流的概念和流类库的结构" class="headerlink" title="1、I&#x2F;O流的概念和流类库的结构"></a>1、I&#x2F;O流的概念和流类库的结构</h2><p>输入输出：程序的输入指的是从输入文件将数据传送给程序，程序的输出指的是从程序将数据传送给输出文件。<span id="more"></span></p>
<p>C++输入输出包含以下三个方面的内容：</p>
<ul>
<li><p>对系统指定的标准设备的输入和输出。即从键盘输入数据，输出到显示器屏幕。这种输入输出称为标准的输入输出，简称标准I&#x2F;O。</p>
</li>
<li><p>以外存磁盘文件为对象进行输入和输出，即从磁盘文件输入数据，数据输出到磁盘文件。以外存文件为对象的输入输出称为文件的输入输出，简称文件I&#x2F;O。</p>
</li>
<li><p>对内存中指定的空间进行输入和输出。通常指定一个字符数组作为存储空间(实际上可以利用该空间存储任何信息)。这种输入和输出称为字符串输入输出，简称串I&#x2F;O。</p>
</li>
</ul>
<p>C++的I&#x2F;O对C的发展–类型安全和可扩展性</p>
<ul>
<li><p>在C语言中，用printf和scanf进行输入输出，往往不能保证所输入输出的数据是可靠的安全的。在C++的输入输出中，编译系统对数据类型进行严格的检查，凡是类型不正确的数据都不可能通过编译。因此C++的I&#x2F;O操作是类型安全(type safe)的。C++的I&#x2F;O操作是可扩展的，不仅可以用来输入输出标准类型的数据，也可以用于用户自定义类型的数据。</p>
</li>
<li><p>C++通过I&#x2F;O类库来实现丰富的I&#x2F;O功能。这样使C++的输人输出明显地优于C 语言中的printf和scanf，但是也为之付出了代价，C++的I&#x2F;O系统变得比较复杂，要掌握许多细节。</p>
</li>
<li><p>C++编译系统提供了用于输入输出的iostream类库。iostream这个单词是由3个部 分组成的，即i-o-stream，意为输入输出流。在iostream类库中包含许多用于输入输出的 类。</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/630f157b16f2c2beb1a30c98.jpg"></p>
<h3 id="1-1、I-x2F-O-库文件"><a href="#1-1、I-x2F-O-库文件" class="headerlink" title="1.1、I&#x2F;O 库文件"></a>1.1、I&#x2F;O 库文件</h3><p>ios是抽象基类，由它派生出istream类和ostream类，两个类名中第1个字母i和o分别代表输入(input)和输出(output)。 istream类支持输入操作，ostream类支持输出操作， iostream类支持输入输出操作。iostream类是从istream类和ostream类通过多重继承而派生的类。其继承层次见上图表示。</p>
<p>C++对文件的输入输出需要用ifstrcam和ofstream类，两个类名中第1个字母i和o分别代表输入和输出，第2个字母f代表文件 (file)。ifstream支持对文件的输入操作， ofstream支持对文件的输出操作。类ifstream继承了类istream，类ofstream继承了类ostream，类fstream继承了 类iostream。</p>
<p>下列的头文件在 C++ 编程中很重要。</p>
<table>
<thead>
<tr>
<th align="left">头文件</th>
<th align="left">函数和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><iostream></td>
<td align="left">该文件定义了 <strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td>
</tr>
<tr>
<td align="left"><iomanip></td>
<td align="left">该文件通过所谓的参数化的流操纵器（比如 <strong>setw</strong> 和 <strong>setprecision</strong>），来声明对执行标准化 I&#x2F;O 有用的服务。</td>
</tr>
<tr>
<td align="left"><fstream></td>
<td align="left">该文件为用户控制的文件处理声明服务。</td>
</tr>
</tbody></table>
<p><img src="https://pic.imgdb.cn/item/630f15a116f2c2beb1a32617.jpg"></p>
<p>在iostream头文件中重载运算符</p>
<p>“&lt;&lt;”和“&gt;&gt;”本来在C++中是被定义为左位移运算符和右位移运算符的，由于在iostream头文件中对它们进行了重载， 使它们能用作标准类型数据的输入和输出运算符。所以，在用它们的程序中必须用#include命令把iostream包含到程序中。</p>
<p>  #include <iostream></p>
<ol>
<li><blockquote>
<blockquote>
<p>a 表示将数据放入a对象中。</p>
</blockquote>
</blockquote>
</li>
<li><p>&lt;&lt;a 表示将a对象中存储的数据拿出。</p>
</li>
</ol>
<h2 id="2、标准I-x2F-O流"><a href="#2、标准I-x2F-O流" class="headerlink" title="2、标准I&#x2F;O流"></a>2、标准I&#x2F;O流</h2><p>标准I&#x2F;O对象：cin，cout，cerr，clog</p>
<ul>
<li><p>cout流对象</p>
<p>cont是console output的缩写，意为在控制台（终端显示器）的输出。强调几点。</p>
<ol>
<li>cout不是C++预定义的关键字，它是ostream流类的对象，在iostream中定义。 顾名思义，流是流动的数据，cout流是流向显示器的数据。cout流中的数据是用流插入运算符“&lt;&lt;”顺序加入的。如果有<br>  cout&lt;&lt;”I “&lt;&lt;”study C++ “&lt;&lt;”very hard. &lt;&lt; “wang bao ming “;</li>
</ol>
<p>按顺序将字符串”I “, “study C++ “, “very hard.”插人到cout流中，cout就将它们送到显示器，在显示器上输出字符串”I study C++ very hard.”。cout流是容纳数据的载体，它并不是一个运算符。人们关心的是cout流中的内容，也就是向显示器输出什么。<br>2)用“ccmt&lt;&lt;”输出基本类型的数据时，可以不必考虑数据是什么类型，系统会判断数据的类型，并根据其类型选择调用与之匹配的运算符重 载函数。这个过程都是自动的，用户不必干预。如果在C语言中用prinf函数输出不同类型的数据，必须分别指定相应的输出格式符，十分麻烦，而且容易出 错。C++的I&#x2F;O机制对用户来说，显然是方便而安全的。</p>
<ol start="3">
<li>cout流在内存中对应开辟了一个缓冲区，用来存放流中的数据，当向cout流插 人一个endl时，不论缓冲区是否已满，都立即输出流中所有数据，然后插入一个换行符， 并刷新流（清空缓冲区）。注意如果插人一个换行符”\n“（如cout&lt;&lt;a&lt;&lt;”\n”），则只输出和换行，而不刷新cout 流(但并不是所有编译系统都体现出这一区别）。</li>
<li>在iostream中只对”&lt;&lt;”和”&gt;&gt;”运算符用于标准类型数据的输入输出进行了重载，但未对用户声明的类型数据的输入输出 进行重载。如果用户声明了新的类型，并希望用”&lt;&lt;”和”&gt;&gt;”运算符对其进行输入输出，按照重运算符重载来做。</li>
</ol>
</li>
<li><p>cerr流对象</p>
<p>cerr流对象是标准错误流，cerr流已被指定为与显示器关联。cerr的 作用是向标准错误设备(standard error device)输出有关出错信息。cerr与标准输出流cout的作用和用法差不多。但有一点不同：cout流通常是传送到显示器输出，但也可以被重定向 输出到磁盘文件，而cerr流中的信息只能在显示器输出。当调试程序时，往往不希望程序运行时的出错信息被送到其他文件，而要求在显示器上及时输出，这时 应该用cerr。cerr流中的信息是用户根据需要指定的。</p>
</li>
<li><p>clog流对象</p>
<p>clog流对象也是标准错误流，它是console log的缩写。它的作用和cerr相同，都是在终端显示器上显示出错信息。区别：cerr是不经过缓冲区，直接向显示器上输出有关信息，而clog中的信息存放在缓冲区中，缓冲区满后或遇endl时向显示器输出。</p>
</li>
</ul>
<h3 id="2-1、标准输入流"><a href="#2-1、标准输入流" class="headerlink" title="2.1、标准输入流"></a>2.1、标准输入流</h3><p>标准输入流对象cin，重点掌握的函数</p>
<ul>
<li>cin.get() &#x2F;&#x2F;一次只能读取一个字符</li>
<li>cin.get(一个参数) &#x2F;&#x2F;读一个字符</li>
<li>cin.get(三个参数) &#x2F;&#x2F;可以读字符串</li>
<li>cin.getline()</li>
<li>cin.ignore()</li>
<li>cin.peek()</li>
<li>cin.putback()</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 cin cout能根据类型 获取数据 / 输出数据</span></span><br><span class="line"><span class="comment">//2 输入字符串 你 好  遇见空格,停止接受输入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> YourName[<span class="number">50</span>];</span><br><span class="line">	<span class="type">int</span> myInt;</span><br><span class="line">	<span class="type">long</span> myLong;</span><br><span class="line">	<span class="type">double</span> myDouble;</span><br><span class="line">	<span class="type">float</span> myFloat;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> myUnsigned;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入一个Int: &quot;</span>;</span><br><span class="line">	cin &gt;&gt; myInt;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入一个Long: &quot;</span>;</span><br><span class="line">	cin &gt;&gt; myLong;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入一个Double: &quot;</span>;</span><br><span class="line">	cin &gt;&gt; myDouble;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入你的姓名: &quot;</span>;</span><br><span class="line">	cin &gt;&gt; YourName;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n\n你输入的数是：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Int: \t&quot;</span> &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Long: \t&quot;</span> &lt;&lt; myLong &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Double: \t&quot;</span> &lt;&lt; myDouble &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名: \t&quot;</span> &lt;&lt; YourName &lt;&lt; endl;</span><br><span class="line">	cout&lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1 输入英文 ok </span></span><br><span class="line"><span class="comment">//2 ctr+z  会产生一个 EOF(-1)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="keyword">while</span>( (ch= cin.<span class="built_in">get</span>())!= EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;字符: &quot;</span> &lt;&lt; ch &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;\n结束.\n&quot;</span>;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演示:读一个字符 链式编程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> a, b, c;</span><br><span class="line">	cin.<span class="built_in">get</span>(a);</span><br><span class="line">	cin.<span class="built_in">get</span>(b);</span><br><span class="line">	cin.<span class="built_in">get</span>(c);</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; b &lt;&lt; c&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;开始链式编程&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout.<span class="built_in">flush</span>();</span><br><span class="line"></span><br><span class="line">	cin.<span class="built_in">get</span>(a).<span class="built_in">get</span>(b).<span class="built_in">get</span>(c);</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; b &lt;&lt; c&lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//演示cin.getline() 可以接受空格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> buf1[<span class="number">256</span>];</span><br><span class="line">	<span class="type">char</span> buf2[<span class="number">256</span>]; </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n请输入你的字符串 不超过256&quot;</span> ;</span><br><span class="line">	cin.<span class="built_in">getline</span>(buf1, <span class="number">256</span>, <span class="string">&#x27;\n&#x27;</span>); </span><br><span class="line">	cout &lt;&lt; buf1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;注意: cin.getline() 和 cin &gt;&gt; buf2 的区别, 能不能带空格 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin &gt;&gt; buf2 ; <span class="comment">//流提取操作符 遇见空格 停止提取输入流</span></span><br><span class="line">	cout &lt;&lt; buf2 &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲区实验 </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1 输入 &quot;aa bb cc dd&quot; 字符串入缓冲区 </span></span><br><span class="line"><span class="comment">2 通过 cin &gt;&gt; buf1; 提走了 aa </span></span><br><span class="line"><span class="comment">3 不需要输入 可以再通过cin.getline() 把剩余的缓冲区数据提走</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> buf1[<span class="number">256</span>];</span><br><span class="line">	<span class="type">char</span> buf2[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入带有空格的字符串,测试缓冲区&quot;</span> &lt;&lt; endl; </span><br><span class="line">	cin &gt;&gt; buf1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;buf1:&quot;</span> &lt;&lt; buf1 &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入数据...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//缓冲区没有数据,就等待; 缓冲区如果有数据直接从缓冲区中拿走数据</span></span><br><span class="line">	cin.<span class="built_in">getline</span>(buf2, <span class="number">256</span>); </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;buf2:&quot;</span> &lt;&lt; buf2 &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ignore 和 peek</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>  intchar;</span><br><span class="line">	<span class="type">char</span> buf1[<span class="number">256</span>];</span><br><span class="line">	<span class="type">char</span> buf2[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入带有空格的字符串,测试缓冲区 aa bb cc dd ee &quot;</span> &lt;&lt; endl; </span><br><span class="line">	cin &gt;&gt; buf1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;buf1:&quot;</span> &lt;&lt; buf1 &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;请输入数据...&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cin.<span class="built_in">ignore</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="comment">//intchar = cin.peek();</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;缓冲区若有数据,返回第一个数据的asc码:&quot; &lt;&lt; intchar &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//缓冲区没有数据,就等待; 缓冲区如果有数据直接从缓冲区中拿走数据</span></span><br><span class="line">	cin.<span class="built_in">getline</span>(buf2, <span class="number">256</span>); </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;buf2:&quot;</span> &lt;&lt; buf2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	intchar = cin.<span class="built_in">peek</span>(); <span class="comment">//没有缓冲区 默认是阻塞模式 </span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;缓冲区若有数据,返回第一个数据的asc码:&quot;</span> &lt;&lt; intchar &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//案例:输入的整数和字符串分开处理</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Please, enter a number or a word: &quot;</span>;</span><br><span class="line">	<span class="type">char</span> c = std::cin.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( (c &gt;= <span class="string">&#x27;0&#x27;</span>) &amp;&amp; (c &lt;= <span class="string">&#x27;9&#x27;</span>) ) <span class="comment">//输入的整数和字符串 分开处理</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n; <span class="comment">//整数不可能 中间有空格 使用cin &gt;&gt;n</span></span><br><span class="line">		cin.<span class="built_in">putback</span> (c);</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;You entered a number: &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		string str;</span><br><span class="line">		cin.<span class="built_in">putback</span> (c);</span><br><span class="line">		<span class="built_in">getline</span> (cin,str); <span class="comment">// //字符串 中间可能有空格 使用 cin.getline();</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;You entered a word: &quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2、标准输出流"><a href="#2-2、标准输出流" class="headerlink" title="2.2、标准输出流"></a>2.2、标准输出流</h3><p>标准输出流对象cout</p>
<ul>
<li>cout.flush()</li>
<li>cout.put()</li>
<li>cout.write()</li>
<li>cout.width()</li>
<li>cout.fill()</li>
<li>cout.setf(标记)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout.<span class="built_in">put</span>(<span class="string">&#x27;h&#x27;</span>).<span class="built_in">put</span>(<span class="string">&#x27;e&#x27;</span>).<span class="built_in">put</span>(<span class="string">&#x27;l&#x27;</span>).<span class="built_in">put</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	cout.<span class="built_in">write</span>(<span class="string">&quot;hello world&quot;</span>, <span class="number">4</span>); <span class="comment">//输出的长度</span></span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> buf[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	cout.<span class="built_in">write</span>(buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	cout.<span class="built_in">write</span>(buf, <span class="built_in">strlen</span>(buf) - <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	cout.<span class="built_in">write</span>(buf, <span class="built_in">strlen</span>(buf) + <span class="number">6</span>); <span class="comment">//给的大于buf长度 不会帮我们检查 提高速度</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用cout.setf()控制符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//使用类成员函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&lt;start&gt;&quot;</span>;</span><br><span class="line">	cout.<span class="built_in">width</span>(<span class="number">30</span>);</span><br><span class="line">	cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::showbase); <span class="comment">//#include &lt;iomanip&gt;</span></span><br><span class="line">	cout.<span class="built_in">setf</span>(ios::internal); <span class="comment">//设置</span></span><br><span class="line">	cout &lt;&lt; hex &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="string">&quot;&lt;End&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//manipulator(操作符、控制符)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用控制阀</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&lt;Start&gt;&quot;</span> </span><br><span class="line">		&lt;&lt; <span class="built_in">setw</span>(<span class="number">30</span>) </span><br><span class="line">		&lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) </span><br><span class="line">		&lt;&lt; <span class="built_in">setiosflags</span>(ios::showbase) <span class="comment">//基数</span></span><br><span class="line">		&lt;&lt; <span class="built_in">setiosflags</span>(ios::internal)</span><br><span class="line">		&lt;&lt; hex</span><br><span class="line">		&lt;&lt; <span class="number">123</span></span><br><span class="line">		&lt;&lt; <span class="string">&quot;&lt;End&gt;\n&quot;</span></span><br><span class="line">		&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3、C-格式化输出控制"><a href="#2-3、C-格式化输出控制" class="headerlink" title="2.3、C++格式化输出控制"></a>2.3、C++格式化输出控制</h3><p>在输出数据时，为简便起见，往往不指定输出的格式，由系统根据数据的类型采取默认的格式，但有时希望数据按指定的格式输出，如要求以十六进制或八进制形式 输出一个 整数，对输出的小数只保留两位小数等。有两种方法可以达到此目的。</p>
<p>1）使用控制符的方法；</p>
<p>2）使用流对象的有关成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;input a:&quot;</span>;</span><br><span class="line">	cin&gt;&gt;a;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;dec:&quot;</span>&lt;&lt;dec&lt;&lt;a&lt;&lt;endl; <span class="comment">//以十进制形式输出整数</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;hex:&quot;</span>&lt;&lt;hex&lt;&lt;a&lt;&lt;endl; <span class="comment">//以十六进制形式输出整数a</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;oct:&quot;</span>&lt;&lt;<span class="built_in">setbase</span>(<span class="number">8</span>)&lt;&lt;a&lt;&lt;endl; <span class="comment">//以八进制形式输出整数a</span></span><br><span class="line">	<span class="type">char</span> *pt=<span class="string">&quot;China&quot;</span>; <span class="comment">//pt指向字符串&quot;China&quot;</span></span><br><span class="line">	cout&lt;&lt;<span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;pt&lt;&lt;endl; <span class="comment">//指定域宽为,输出字符串</span></span><br><span class="line">	cout&lt;&lt;<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>)&lt;&lt;<span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;pt&lt;&lt;endl; <span class="comment">//指定域宽,输出字符串,空白处以&#x27;*&#x27;填充</span></span><br><span class="line">	<span class="type">double</span> pi=<span class="number">22.0</span>/<span class="number">7.0</span>; <span class="comment">//计算pi值</span></span><br><span class="line">	<span class="comment">//按指数形式输出,8位小数</span></span><br><span class="line">	cout&lt;&lt;<span class="built_in">setiosflags</span>(ios::scientific)&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">8</span>);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;pi=&quot;</span>&lt;&lt;pi&lt;&lt;endl; <span class="comment">//输出pi值</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;pi=&quot;</span>&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">4</span>)&lt;&lt;pi&lt;&lt;endl; <span class="comment">//改为位小数</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;pi=&quot;</span>&lt;&lt;<span class="built_in">setiosflags</span>(ios::fixed)&lt;&lt;pi&lt;&lt;endl; <span class="comment">//改为小数形式输出</span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行结果如下：</span><br><span class="line">input a:34↙(输入a的值)</span><br><span class="line">dec:34                   (十进制形式)</span><br><span class="line">hex:22                   (十六进制形式)</span><br><span class="line">oct:42                   (八进制形式)</span><br><span class="line">         China               (域宽为)</span><br><span class="line">*****China               (域宽为,空白处以&#x27;*&#x27;填充)</span><br><span class="line">pi=3.14285714e+00        (指数形式输出,8位小数)</span><br><span class="line">pi=3.1429e+00            (指数形式输出,4位小数)</span><br><span class="line">pi=3.143                 (小数形式输出,精度仍为)</span><br></pre></td></tr></table></figure>

<p>在输入输出时有一些特殊的要求，如在输出实数时规定字段宽度，只保留两位小数，数据向左或向右对齐等。C++提供了在输入输出流中使用的控制符(有的书中称为操纵符)</p>
<p>1）标准输入输出控制符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dec  设置整数的基数为10 </span><br><span class="line">hex  设置整数的基数为16 </span><br><span class="line">oct  设置整数的基数为8 </span><br><span class="line">setbase(n)  设置整数的基数为n(n只能是16，10，8之一) </span><br><span class="line">setfill(c)  设置填充字符c，c可以是字符常量或字符变量 </span><br><span class="line">setprecision(n)  设置实数的精度为n位。在以一般十进制小数形式输出时，n代表有效数字。在以fixed(固定小数位数)形式和scientific(指数)形式输出时，n为小数位数。 </span><br><span class="line">setw(n)  设置字段宽度为n位。 </span><br><span class="line">setiosflags(ios::fixed)  设置浮点数以固定的小数位数显示。 </span><br><span class="line">setiosflags(ios::scientific)  设置浮点数以科学计数法(即指数形式)显示。 </span><br><span class="line">setiosflags(ios::left)  输出数据左对齐。 </span><br><span class="line">setiosflags(ios::right)  输出数据右对齐。 </span><br><span class="line">setiosflags(ios::shipws)  忽略前导的空格。 </span><br><span class="line">setiosflags(ios::uppercase)  在以科学计数法输出E和十六进制输出字母X时，以大写表示。 </span><br><span class="line">setiosflags(ios::showpos)  输出正数时，给出“+”号。 </span><br><span class="line">resetiosflags  终止已设置的输出格式状态，在括号中应指定内容。 </span><br></pre></td></tr></table></figure>

<p>2）用流对象的成员控制输出格式 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">流成员函数      与之作用相同的控制符    作用 </span><br><span class="line">precision(n)  setprecision(n)     设置实数的精度为n位。 </span><br><span class="line">width(n)      setw(n)             设置字段宽度为n位。 </span><br><span class="line">fill(c)       setfill(c)          设置填充字符c。 </span><br><span class="line">setf( )       setiosflags( )      设置输出格式状态，括号中应给出格式状态，内容与控制符setiosflags括                                   号中内容相同。 </span><br><span class="line">ubsetf( )     resetiosflags( )    终止已设置的输出格式状态。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3）设置格式状态的格式标志 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式标志         作用 </span><br><span class="line">ios::left       输出数据在本域宽范围内左对齐 </span><br><span class="line">ios::right      输出数据在本域宽范围内右对齐 </span><br><span class="line">ios::internal   数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充 </span><br><span class="line">ios::dec        设置整数的基数为10 </span><br><span class="line">ios::oct        设置整数的基数为8 </span><br><span class="line">ios::hex        设置整数的基数为16 </span><br><span class="line">ios::showbase   强制输出整数的基数(八进制以0打头，十六进制以0x打头) </span><br><span class="line">ios::showpoint  强制输出浮点数的小点和尾数0 </span><br><span class="line">ios::uppercase  在以科学计数法输出E和十六进制输出字母X时，以大写表示 </span><br><span class="line">ios::showpos    输出正数时，给出“+”号。 </span><br><span class="line">ios::scientific  设置浮点数以科学计数法(即指数形式)显示 </span><br><span class="line">ios::fixed      设置浮点数以固定的小数位数显示 </span><br><span class="line">ios::unitbuf    每次输出后刷新所有流 </span><br><span class="line">ios::stdio      每次输出后清除 stdout，stderr </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="type">int</span> a=<span class="number">21</span>;</span><br><span class="line">   cout.<span class="built_in">setf</span>(ios::showbase); <span class="comment">//设置输出时的基数符号</span></span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;dec:&quot;</span>&lt;&lt;a&lt;&lt;endl; <span class="comment">//默认以十进制形式输出a</span></span><br><span class="line">   cout.<span class="built_in">unsetf</span>(ios::dec); <span class="comment">//终止十进制的格式设置</span></span><br><span class="line">   cout.<span class="built_in">setf</span>(ios::hex); <span class="comment">//设置以十六进制输出的状态</span></span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;hex:&quot;</span>&lt;&lt;a&lt;&lt;endl; <span class="comment">//以十六进制形式输出a</span></span><br><span class="line">   cout.<span class="built_in">unsetf</span>(ios::hex); <span class="comment">//终止十六进制的格式设置</span></span><br><span class="line">   cout.<span class="built_in">setf</span>(ios::oct); <span class="comment">//设置以八进制输出的状态</span></span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;oct:&quot;</span>&lt;&lt;a&lt;&lt;endl; <span class="comment">//以八进制形式输出a</span></span><br><span class="line">   cout.<span class="built_in">unsetf</span>(ios::oct); <span class="comment">//终止以八进制的输出格式设置</span></span><br><span class="line">   <span class="type">char</span> *pt=<span class="string">&quot;China&quot;</span>; <span class="comment">//pt指向字符串”china”</span></span><br><span class="line">   cout.<span class="built_in">width</span>(<span class="number">10</span>); <span class="comment">//指定域宽为10</span></span><br><span class="line">   cout&lt;&lt;pt&lt;&lt;endl; <span class="comment">//输出字符串</span></span><br><span class="line">   cout.<span class="built_in">width</span>(<span class="number">10</span>); <span class="comment">//指定域宽为10</span></span><br><span class="line">   cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>); <span class="comment">//指定空白处以&#x27;*&#x27;填充</span></span><br><span class="line">   cout&lt;&lt;pt&lt;&lt;endl; <span class="comment">//输出字符串</span></span><br><span class="line">   <span class="type">double</span> pi=<span class="number">22.0</span>/<span class="number">7.0</span>; <span class="comment">//计算pi值</span></span><br><span class="line">   cout.<span class="built_in">setf</span>(ios::scientific);<span class="comment">//指定用科学记数法输出</span></span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;pi=&quot;</span>; <span class="comment">//输出&quot;pi=&quot;</span></span><br><span class="line">   cout.<span class="built_in">width</span>(<span class="number">14</span>); <span class="comment">//指定域宽为14</span></span><br><span class="line">   cout&lt;&lt;pi&lt;&lt;endl; <span class="comment">//输出&quot;pi值</span></span><br><span class="line">   cout.<span class="built_in">unsetf</span>(ios::scientific); <span class="comment">//终止科学记数法状态</span></span><br><span class="line">   cout.<span class="built_in">setf</span>(ios::fixed); <span class="comment">//指定用定点形式输出</span></span><br><span class="line">   cout.<span class="built_in">width</span>(<span class="number">12</span>); <span class="comment">//指定域宽为12</span></span><br><span class="line">   cout.<span class="built_in">setf</span>(ios::showpos); <span class="comment">//在输出正数时显示“+”号</span></span><br><span class="line">   cout.<span class="built_in">setf</span>(ios::internal); <span class="comment">//数符出现在左侧</span></span><br><span class="line">   cout.<span class="built_in">precision</span>(<span class="number">6</span>); <span class="comment">//保留6位小数</span></span><br><span class="line">   cout&lt;&lt;pi&lt;&lt;endl; <span class="comment">//输出pi，注意数符“+”的位置</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">dec：<span class="number">21</span> (十进制形式)</span><br><span class="line">    hex：<span class="built_in">Oxl5</span> (十六进制形式，以<span class="number">0</span>x开头)</span><br><span class="line">    oct：<span class="number">025</span> (八进制形式，以O开头)</span><br><span class="line">    <span class="built_in">China</span> (域宽为<span class="number">10</span>)</span><br><span class="line">    *****<span class="built_in">china</span> (域宽为<span class="number">10</span>，空白处以<span class="string">&#x27;*&#x27;</span>填充)</span><br><span class="line">    pi=**<span class="number">3.142857e+00</span> (指数形式输出，域宽<span class="number">14</span>，默认<span class="number">6</span>位小数)</span><br><span class="line">    ****<span class="number">3.142857</span> (小数形式输㈩，精度为<span class="number">6</span>，最左侧输出数符“+”)</span><br></pre></td></tr></table></figure>

<p>对程序的几点说明：</p>
<ol>
<li>成员函数width(n)和控制符setw(n)只对其后的第一个输出项有效。如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout.<span class="built_in">width</span>(<span class="number">6</span>);</span><br><span class="line">cout &lt;&lt;<span class="number">20</span> &lt;&lt;<span class="number">3.14</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">输出结果为 <span class="number">203.14</span></span><br></pre></td></tr></table></figure>

<p>在输出第一个输出项20时，域宽为6，因此在20前面有4个空格，在输出3.14时，width (6)已不起作用，此时按系统默认的域宽输出（按数据实际长度输出）。如果要求在输出数据时都按指定的同一域宽n输出，不能只调用一次width(n)， 而必须在输出每一项前都调用一次width(n&gt;），上面的程序中就是这样做的。</p>
<ol start="2">
<li><p>在输出格式状态分为5组，每一组中同时只能选用一种（例如dec、hex和oct中只能选一，它们是互相排斥的）。在用成员函数setf和 控制符setiosflags设置输出格式状态后，如果想改设置为同组的另一状态，应当调用成员函数unsetf（对应于成员函数self）或 resetiosflags（对应于控制符setiosflags），先终止原来设置的状态。然后再设置其他状态，可以从本程序中看到这点。程序在开始虽然没有用成员函数self和控制符setiosflags设置用dec输出格式状态，但系统默认指定为dec，因此要改变为hex或oct，也应当先 用unsetf 函数终止原来设置。如果删去程序中的第7行和第10行，虽然在第8行和第11行中用成员函数setf设置了hex和oct格式，由于未终止dec格式，因 此hex和oct的设置均不起作用，系统依然以十进制形式输出。同理，程序倒数第8行的unsetf 函数的调用也是不可缺少的。</p>
</li>
<li><p>用setf 函数设置格式状态时，可以包含两个或多个格式标志，由于这些格式标志在ios类中被定义为枚举值，每一个格式标志以一个二进位代表，因此可以用位或运算符“|”组合多个格式标志。如倒数第5、第6行可以用下面一行代替：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout.<span class="built_in">setf</span>(ios::internal I ios::showpos);  <span class="comment">//包含两个状态标志，用&quot;|&quot;组合</span></span><br></pre></td></tr></table></figure>

<p>可以看到：对输出格式的控制，既可以用控制符，也可以用cout流的有关成员函数，二者的作用是相同的。控制符是在头文件iomanip中定义的，因此用控制符时，必须包含iomanip头文件。cout流的成员函数是在头文件iostream 中定义的，因此只需包含头文件iostream，不必包含iomanip。许多程序人员感到使用控制符方便简单，可以在一个cout输出语句中连续使用多种控制符。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++异常处理</title>
    <url>/2022/08/31/C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-异常处理"><a href="#C-异常处理" class="headerlink" title="C++异常处理"></a>C++异常处理</h1><p>异常是一种程序控制机制，与函数机制独立和互补。<span id="more"></span></p>
<p>函数是一种以栈结构展开的上下函数衔接的程序控制系统，异常是另一种控制结构，它依附于栈结构，却可以同时设置多个异常类型作为网捕条件，从而以类型匹配在栈机制中跳跃回馈。</p>
<p>异常设计目的：栈机制是一种高度节律性控制机制，面向对象编程却要求对象之间有方向、有目的的控制传动,从一开始，异常就是冲着改变程序控制结构，以适应面向对象程序更有效地工作这个主题，而不是仅为了进行错误处理。异常设计出来之后，却发现在错误处理方面获得了最大的好处。</p>
<h2 id="1、c-异常处理机制"><a href="#1、c-异常处理机制" class="headerlink" title="1、c++异常处理机制"></a>1、c++异常处理机制</h2><p>对异常的处理有3个组成部 分： </p>
<ul>
<li><p>引发异常</p>
</li>
<li><p>使用处理程序捕获异常 </p>
</li>
<li><p>使用try块</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/630f14a316f2c2beb1a1f0b7.jpg"></p>
<ul>
<li><p>C++的异常处理机制使得异常的引发和异常的处理不必在同一个函数中，这样底层的函数可以着重解决具体问题，而不必过多的考虑异常的处理。上层调用者可以再适当的位置设计对不同类型异常的处理。</p>
</li>
<li><p>异常是专门针对抽象编程中的一系列错误处理的，C++中不能借助函数机制，因为栈结构的本质是先进后出，依次访问，无法进行跳跃，但错误处理的特征却是遇到错误信息就想要转到若干级之上进行重新尝试。</p>
</li>
<li><p>异常超脱于函数机制，决定了其对函数的跨越式回跳。异常跨越函数</p>
</li>
</ul>
<h2 id="2、c-异常处理的实现"><a href="#2、c-异常处理的实现" class="headerlink" title="2、c++异常处理的实现"></a>2、c++异常处理的实现</h2><h3 id="2-1、c-异常处理语法"><a href="#2-1、c-异常处理语法" class="headerlink" title="2.1、c++异常处理语法"></a>2.1、c++异常处理语法</h3><p><img src="https://pic.imgdb.cn/item/630f14b616f2c2beb1a1fd13.jpg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(...) <span class="keyword">throw</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">  &#125;<span class="built_in">catch</span>(B)&#123;</span><br><span class="line">    cout&lt;&lt;“exception B\n”;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">g</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1） 若有异常则通过throw操作创建一个异常对象并抛掷。</p>
<p>2） 将可能抛出异常的程序段嵌在try块之中。控制通过正常的顺序执行到达try语句，然后执行try块内的保护段。</p>
<p>3） 如果在保护段执行期间没有引起异常，那么跟在try块后的catch子句就不执行。程序从try块后跟随的最后一个catch子句后面的语句继续执行下去。</p>
<p>4） catch子句按其在try块后出现的顺序被检查。匹配的catch子句将捕获并处理异常（或继续抛掷异常）。</p>
<p>5） 如果匹配的处理器未找到，则运行函数terminate将被自动调用，其缺省功能是调用abort终止程序。</p>
<p>6）处理不了的异常，可以在catch的最后一个分支，使用throw语法，向上扔。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//被零整除</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (y ==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x/y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;8/2 = &quot;</span> &lt;&lt; <span class="built_in">divide</span>(<span class="number">8</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;10/0 =&quot;</span> &lt;&lt; <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (<span class="type">int</span> e)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;e&quot;</span> &lt;&lt; <span class="string">&quot; is divided by zero!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span>(...)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未知异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span><br><span class="line"> 	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7）异常机制与函数机制互不干涉，但捕捉的方式是基于类型匹配。捕捉相当于函数返回类型的匹配，而不是函数参数的匹配，所以捕捉不用考虑一个抛掷中的多种数据类型匹配问题</p>
<p>比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> 	j = <span class="number">0</span>;    </span><br><span class="line">		<span class="type">double</span> 	d = <span class="number">2.3</span>;    </span><br><span class="line">		<span class="type">char</span> 	str[<span class="number">20</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Please input a exception number: &quot;</span>;</span><br><span class="line">		<span class="type">int</span> a; </span><br><span class="line">		cin&gt;&gt;a;</span><br><span class="line">		<span class="keyword">switch</span>(a)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">1</span>: </span><br><span class="line">			<span class="keyword">throw</span> d;      </span><br><span class="line">		<span class="keyword">case</span>  <span class="number">2</span>: </span><br><span class="line">			<span class="keyword">throw</span> j;      </span><br><span class="line">		<span class="keyword">case</span>  <span class="number">3</span>: </span><br><span class="line">			<span class="keyword">throw</span> str;</span><br><span class="line">		<span class="keyword">case</span>  <span class="number">4</span>: </span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">A</span>();      </span><br><span class="line">		<span class="keyword">case</span>  <span class="number">5</span>: </span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">B</span>();</span><br><span class="line">		<span class="keyword">default</span>: </span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;No throws here.\n&quot;</span>;    </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span>(<span class="type">int</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;int exception.\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span>(<span class="type">double</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;double exception.\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span>(<span class="type">char</span>*)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;char* exception.\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span>(A)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;class A exception.\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span>(B)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;class B exception.\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;That&#x27;s ok.\n&quot;</span>;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>catch代码块必须出现在try后，并且在try块后可以出现多个catch代码块，以捕捉各种不同类型的抛掷。</p>
<p>异常机制是基于这样的原理：程序运行实质上是数据实体在做一些操作，因此发生异常现象的地方，一定是某个实体出了差错，该实体所对应的数据类型便作为抛掷和捕捉的依据。</p>
<p>8）异常捕捉严格按照类型匹配</p>
<p>异常捕捉的类型匹配之苛刻程度可以和模板的类型匹配媲美，它不允许相容类型的隐式转换，比如，抛掷char类型用int型就捕捉不到。例如下列代码不会输出“int exception”，从而也不会输出“That’s ok”  因为出现异常后提示退出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> ‘H’;</span><br><span class="line">  &#125;<span class="built_in">catch</span>(<span class="type">int</span>)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;int exception.\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;That&#x27;s ok.\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2、栈解旋-unwinding"><a href="#2-2、栈解旋-unwinding" class="headerlink" title="2.2、栈解旋(unwinding)"></a>2.2、栈解旋(unwinding)</h3><p>异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上的构造的所有对象，都会被自动析构。析构的顺序与构造的顺序相反。这一过程称为栈的解旋(unwinding)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Test</span>(<span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Test 构造函数执行&quot;</span> &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printT</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Test</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Test 析构函数执行&quot;</span> &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunc</span><span class="params">()</span> <span class="title">throw</span> <span class="params">(MyException)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test t1;</span><br><span class="line">	Test t2;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;定义了两个栈变量,异常抛出后测试栈变量的如何被析构&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上的构造的所有对象，</span></span><br><span class="line">	<span class="comment">//都会被自动析构。析构的顺序与构造的顺序相反。</span></span><br><span class="line">	<span class="comment">//这一过程称为栈的解旋(unwinding)</span></span><br><span class="line">	<span class="keyword">try</span>  </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">myFunc</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//catch(MyException &amp;e) //这里不能访问异常对象</span></span><br><span class="line">	<span class="built_in">catch</span>(MyException ) <span class="comment">//这里不能访问异常对象</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;接收到MyException类型异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span>(...)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未知类型异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3、异常接口声明"><a href="#3、异常接口声明" class="headerlink" title="3、异常接口声明"></a>3、异常接口声明</h2><p>1）为了加强程序的可读性，可以在函数声明中列出可能抛出的所有异常类型，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span> <span class="params">(A, B, C , D)</span></span>; <span class="comment">//这个函数func（）能够且只能抛出类型A B C D及其子类型的异常。</span></span><br></pre></td></tr></table></figure>

<p>2）如果在函数声明中没有包含异常接口声明，则次函数可以抛掷任何类型的异常，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>3）一个不抛掷任何类型异常的函数可以声明为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span>  <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>4） 如果一个函数抛出了它的异常接口声明所不允许抛出的异常，unexpected函数会被调用，该函数默认行为调用terminate函数中止程序。</p>
<h2 id="4、异常类型和异常变量的生命周期"><a href="#4、异常类型和异常变量的生命周期" class="headerlink" title="4、异常类型和异常变量的生命周期"></a>4、异常类型和异常变量的生命周期</h2><ul>
<li><p>throw的异常是有类型的，可以是数字、字符串、类对象。</p>
</li>
<li><p>throw的异常是有类型的，catch严格按照类型进行匹配。</p>
</li>
<li><p>异常对象的内存模型。</p>
</li>
</ul>
<h3 id="4-1、throw-int类型异常"><a href="#4-1、throw-int类型异常" class="headerlink" title="4.1、throw int类型异常"></a>4.1、throw int类型异常</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件的二进制copy</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">filecopy</span><span class="params">(<span class="type">char</span> *filename2, <span class="type">char</span> *filename1 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE *fp1= <span class="literal">NULL</span>,  *fp2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	fp1 = <span class="built_in">fopen</span>(filename1, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp1 == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//return 1;</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fp2 = <span class="built_in">fopen</span>(filename2, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp1 == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//return 2;</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">	<span class="type">int</span>  readlen, writelen;</span><br><span class="line">	<span class="keyword">while</span> ( (readlen = <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="number">256</span>, fp1)) &gt; <span class="number">0</span> ) <span class="comment">//如果读到数据，则大于0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		writelen = <span class="built_in">fwrite</span>(buf, <span class="number">1</span>, readlen, fp2);</span><br><span class="line">		<span class="keyword">if</span> (readlen != readlen)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//return 3;</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fclose</span>(fp1);</span><br><span class="line">	<span class="built_in">fclose</span>(fp2);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2、throw字符类型异常"><a href="#4-2、throw字符类型异常" class="headerlink" title="4.2、throw字符类型异常"></a>4.2、throw字符类型异常</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件的二进制copy</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">filecopy</span><span class="params">(<span class="type">char</span> *filename2, <span class="type">char</span> *filename1 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE *fp1= <span class="literal">NULL</span>,  *fp2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	fp1 = <span class="built_in">fopen</span>(filename1, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp1 == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="string">&quot;打开源文件时出错&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fp2 = <span class="built_in">fopen</span>(filename2, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp1 == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="string">&quot;打开目标文件时出错&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">	<span class="type">int</span>  readlen, writelen;</span><br><span class="line">	<span class="keyword">while</span> ( (readlen = <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="number">256</span>, fp1)) &gt; <span class="number">0</span> ) <span class="comment">//如果读到数据，则大于0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		writelen = <span class="built_in">fwrite</span>(buf, <span class="number">1</span>, readlen, fp2);</span><br><span class="line">		<span class="keyword">if</span> (readlen != readlen)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">&quot;拷贝文件过程中失败&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fclose</span>(fp1);</span><br><span class="line">	<span class="built_in">fclose</span>(fp2);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3、throw类对象类型异常"><a href="#4-3、throw类对象类型异常" class="headerlink" title="4.3、throw类对象类型异常"></a>4.3、throw类对象类型异常</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//throw int类型变量</span></span><br><span class="line"><span class="comment">//throw 字符串类型</span></span><br><span class="line"><span class="comment">//throw 类类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BadSrcFile</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BadSrcFile</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;BadSrcFile 构造 do &quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">BadSrcFile</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;BadSrcFile 析构 do &quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">BadSrcFile</span>(BadSrcFile &amp; obj)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造  do &quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;aaaa&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BadDestFile</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BadCpyFile</span> &#123;&#125;;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">filecopy</span><span class="params">(<span class="type">char</span> *filename2, <span class="type">char</span> *filename1 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE *fp1= <span class="literal">NULL</span>,  *fp2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	fp1 = <span class="built_in">fopen</span>(filename1, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp1 == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//throw new BadSrcFile();</span></span><br><span class="line">		<span class="keyword">throw</span>  <span class="built_in">BadSrcFile</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fp2 = <span class="built_in">fopen</span>(filename2, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp1 == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">BadDestFile</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">	<span class="type">int</span>  readlen, writelen;</span><br><span class="line">	<span class="keyword">while</span> ( (readlen = <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="number">256</span>, fp1)) &gt; <span class="number">0</span> ) <span class="comment">//如果读到数据，则大于0 </span></span><br><span class="line">	&#123;</span><br><span class="line">		writelen = <span class="built_in">fwrite</span>(buf, <span class="number">1</span>, readlen, fp2);</span><br><span class="line">		<span class="keyword">if</span> (readlen != readlen)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">BadCpyFile</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fclose</span>(fp1);</span><br><span class="line">	<span class="built_in">fclose</span>(fp2);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		 <span class="comment">//filecopy(&quot;c:/1.txt&quot;,&quot;c:/2.txt&quot;);</span></span><br><span class="line">		<span class="comment">// filecopy(&quot;c:/1.txt&quot;,&quot;c:/2.txt&quot;);</span></span><br><span class="line">		 <span class="built_in">filecopy</span>(<span class="string">&quot;c:/1.txt&quot;</span>,<span class="string">&quot;c:/2.txt&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (<span class="type">int</span> e)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;发生异常：%d \n&quot;</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span> * e)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;发生异常：%s \n&quot;</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> ( BadSrcFile *e)</span><br><span class="line">	&#123;</span><br><span class="line">		 e-&gt;<span class="built_in">toString</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;发生异常：打开源文件时出错!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> ( BadSrcFile &amp;e)</span><br><span class="line">	&#123;</span><br><span class="line">		e.<span class="built_in">toString</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;发生异常：打开源文件时出错!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> ( BadDestFile e)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;发生异常：打开目标文件时出错!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> ( BadCpyFile e)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;发生异常：copy时出错!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span>(...) <span class="comment">//抓漏网之鱼</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;发生了未知异常! 抓漏网之鱼\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//class BadSrcFile &#123;&#125;;</span></span><br><span class="line">	<span class="comment">//class BadDestFile &#123;&#125;;</span></span><br><span class="line">	<span class="comment">//class BadCpyFile &#123;&#125;;;	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、异常的层次结构-继承在异常中的应用-–-创建自己的异常类"><a href="#5、异常的层次结构-继承在异常中的应用-–-创建自己的异常类" class="headerlink" title="5、异常的层次结构(继承在异常中的应用) – 创建自己的异常类"></a>5、异常的层次结构(继承在异常中的应用) – 创建自己的异常类</h2><h3 id="5-1、exception类"><a href="#5-1、exception类" class="headerlink" title="5.1、exception类"></a>5.1、exception类</h3><p>C++异常的主要目的是为设计容错程序提供语言级支持，即异常使得在程序设计中包含错误处理功能更容易，以免事后采取一些严格的错误处理方式。异常的灵活性和相对方便性激励着程序员在条件允许的情况下在程序设计中加入错误处理功能。总之，异常是这样一种特性：类似于类，可以改变您的编程方式。 </p>
<p>较新的C++编译器将异常合并到语言中。例如，为支持该语言，exception头文件（以前为exception.h或except.h）定义了exception类， C++可以把它用作其他异常类的基类。代码可以引发exception异常，也可以将exception类用作基类。</p>
<ul>
<li><p>异常派生</p>
</li>
<li><p>异常中的数据：数据成员</p>
</li>
<li><p>按引用传递异常，在异常中使用虚函数</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// out_of_range</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span>  </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Teacher</span>(<span class="type">int</span> age)  <span class="comment">//构造函数, 通过异常机制 处理错误</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (age &gt; <span class="number">100</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;年龄太大&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Teacher <span class="title">t1</span><span class="params">(<span class="number">102</span>)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (out_of_range e)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	exception e;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义异常类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyException</span>(<span class="type">const</span> <span class="type">char</span> *p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_p = p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span> *  <span class="title">what</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;MyException: 类型&quot;</span> &lt;&lt; m_p &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> m_p;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *m_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testMyExcept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="built_in">MyException</span>(<span class="string">&quot;函数异常&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">testMyExcept</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (MyException &amp; e)</span><br><span class="line">	&#123;</span><br><span class="line">		e.<span class="built_in">what</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (...)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;未知 类型 &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2、标准程序库异常"><a href="#5-2、标准程序库异常" class="headerlink" title="5.2、标准程序库异常"></a>5.2、标准程序库异常</h3><p>C++标准提供了一组标准异常类，这些类以基类Exception开始，标准程序库抛出的所有异常，都派生与该基类，这些类构成如图所示的异常类的派生继承关系。该继承类提供一个成员函数what()，用于返回错误信息（返回类型为const char）。在Exception类中，what()函数的声明如下：<br>virtual const char* what() const throw();<br>该函数可以在派生类中重新定义 </p>
<p> 标准异常类的继承关系如下：</p>
<p><img src="https://pic.imgdb.cn/item/630f14f416f2c2beb1a2343f.png"></p>
<p>下表中列出了各个具体异常类的含义及定义它们的头文件。runtime_error和logic_error是一些具体的异常类的基类，它们分别表示两大异常类。logic_error表示那些可以在程序中被预先检测到的异常，也就是说如果小心地编写程序，这类异常能够避免；而runtime_error则表示那些难以被预先检测的异常。 </p>
<pre><code>                                                C++标准库各种异常类所代表的的异常
</code></pre>
<table>
<thead>
<tr>
<th>异常类</th>
<th>头文件</th>
<th>异常的含义</th>
</tr>
</thead>
<tbody><tr>
<td>bad_alloc</td>
<td>exception</td>
<td>用 new 动态分配空间失败</td>
</tr>
<tr>
<td>bad_cast</td>
<td>new</td>
<td>执行dynamic_cast失败</td>
</tr>
<tr>
<td>bad_typeid</td>
<td>typeinfo</td>
<td>对某个空指针p执行 typeid(*p)</td>
</tr>
<tr>
<td>bad_exception</td>
<td>typeinfo</td>
<td>当某个函数fun()因在执行过程中抛出了异常声明所不允许的异常而调用unexpected()函数时，若unexpected()函数又一次抛出了fun()的异常声明所不允许的异常，且fun()的异常声明列表中有bad_exception，则会有一个bad_exception异常在fun()的调用点被抛出</td>
</tr>
<tr>
<td>ios_base::failure</td>
<td>ios</td>
<td>用来表示 C++ 的输入输出流执行过程中发生的错误</td>
</tr>
<tr>
<td>underflow_error</td>
<td>stdexcept</td>
<td>算术运算时向下溢出</td>
</tr>
<tr>
<td>overflow_error</td>
<td>stdexcept</td>
<td>算术运算时向上溢出</td>
</tr>
<tr>
<td>range_error</td>
<td>stdexcept</td>
<td>内部计算时发生作用域的错误</td>
</tr>
<tr>
<td>out_of_range</td>
<td>stdexcept</td>
<td>表示一个参数值不在允许的范围之内</td>
</tr>
<tr>
<td>length_error</td>
<td>stdexcept</td>
<td>尝试创建一个长度超过最大允许值的对象</td>
</tr>
<tr>
<td>invalid_argument</td>
<td>stdexcept</td>
<td>表示向函数传入无效参数</td>
</tr>
<tr>
<td>domain_error</td>
<td>stdexcept</td>
<td>执行一段程序所需要的先决条件不满足</td>
</tr>
</tbody></table>
<p> 下面的例子使用了标准程序库提供的异常类。<br>三角形面积计算<br>        编写一个计算三角形面积的函数，函数的参数为三角形三边长 a，b，c，可以用 Heron 公式计算：</p>
<p><img src="https://pic.imgdb.cn/item/630f186416f2c2beb1a4e376.jpg"></p>
<p>  在计算三角形面积的函数中需要判断输入的参数 a，b，c 是否构成一个三角形，若三角形三个边长不能构成三角形，则需要抛出异常。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//==========================================										   	</span></span><br><span class="line"><span class="comment">//	Filename : 三角形面积计算						   	</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给出三角形三边长，计算三角形面积</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Area</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c)</span> <span class="title">throw</span> <span class="params">(invalid_argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//判断三角形三边长是否为正</span></span><br><span class="line">	<span class="keyword">if</span> (a &lt;= <span class="number">0</span> || b &lt;= <span class="number">0</span> || c &lt;= <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;the side length should be positive&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断三边长是否满足三角不等式</span></span><br><span class="line">	<span class="keyword">if</span> (a + b &lt;= c || a + c &lt;= b || b + c &lt;= a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;the side length should fit the triangle inequation&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//由 Heron 公式计算三角形面积</span></span><br><span class="line">	<span class="type">double</span> s = (a + b + c) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(s * (s - a) * (s - b) * (s - c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> a, b, c;			<span class="comment">//三角形三边长</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Please input the side lengths of a triangle:&quot;</span>;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">double</span> s = <span class="built_in">Area</span>(a, b, c);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Area = &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">catch</span> (exception &amp;e)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Error:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Please input the side lengths of a triangle:3 4 5</span><br><span class="line">Area = 6</span><br></pre></td></tr></table></figure>

<p>程序运行结果 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Please input the side lengths of a triangle:0 5 5</span><br><span class="line">Error:the side length should be positive</span><br></pre></td></tr></table></figure>

<p>程序运行结果 3：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Please input the side lengths of a triangle:<span class="number">1</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line">Error:the side length should fit the triangle inequation</span><br></pre></td></tr></table></figure>

<p>C++ 标准程序库对于异常处理做了如下保证：C++ 标准程序库在面对异常时，保证不会发生资源泄露，也不会破坏容器的不变特性。</p>
<p>1）对于以结点实现为基础的容器，如 list，set，multiset，map 和 multimap，如果结点构造失败，容器应当保持不变。同样需要保证删除结点操作不会失败。在顺序关联容器中插入多个元素时，为保证数据的有序排列，应当保证如果插入不成功，则容器元素不做任何改动。对于删除操作，确保操作成功。比如，对于列表容器，除了 remove()，remove_if()，merge()，sort() 和 unique() 之外的所有操作，要么成功，要么对容器不作任何改动。</p>
<p>2）对于以数组实现为基础的容器，如 vector 和 deque，在插入和删除元素时，由于有时需要调用复制构造函数和复制赋值运算符，当这些操作失败而抛出异常时，容器的不变性能不能被保证。除此以外，对于这些容器的不变特性的保证程度以结点实现为基础的容器相同。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象-多态</title>
    <url>/2022/08/31/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="面向对象–多态"><a href="#面向对象–多态" class="headerlink" title="面向对象–多态"></a>面向对象–多态</h1><h2 id="1、多态概念"><a href="#1、多态概念" class="headerlink" title="1、多态概念"></a>1、多态概念</h2><p>多态是面向对象程序设计语言中数据抽象和继承之外的第三个基本特征。<span id="more"></span></p>
<p>多态性(polymorphism)提供接口与具体实现之间的另一层隔离，从而将”what”和”how”分离开来。多态性改善了代码的可读性和组织性，同时也使创建的程序具有可扩展性，项目不仅在最初创建时期可以扩展，而且当项目在需要有新的功能时也能扩展。</p>
<p>c++支持编译时多态(静态多态)和运行时多态(动态多态)，运算符重载和函数重载就是编译时多态，而派生类和虚函数实现运行时多态。静态多态和动态多态的区别就是函数地址是早绑定(静态联编)还是晚绑定(动态联编)。如果函数的调用，在编译阶段就可以确定函数的调用地址，并产生代码，就是静态多态(编译时多态)，就是说地址是早绑定的。而如果函数的调用地址不能编译不能在编译期间确定，而需要在运行时才能决定，这这就属于晚绑定(动态多态,运行时多态)。</p>
<p>如果子类定义了与父类中原型相同的函数会发生什么？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	 <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Parent:print() do...&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	 <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Child:print() do...&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Child child;</span><br><span class="line">	Parent *p = <span class="literal">NULL</span>;</span><br><span class="line">	p = &amp;child;</span><br><span class="line">	child.<span class="built_in">print</span>();</span><br><span class="line">	child.Parent::<span class="built_in">print</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数重写：在子类中定义与父类中原型相同的函数。函数重写只发生在父类与子类之间。父类中被重写的函数依然会继承给子类默认情况下子类中重写的函数将隐藏父类中的函数。通过作用域分辨符::可以访问到父类中被隐藏的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	 <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Parent:print() do...&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	 <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Child:print() do...&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、在编译此函数的时，编译器不可能知道指针 p 究竟指向了什么。</span></span><br><span class="line"><span class="comment">2、编译器没有理由报错。</span></span><br><span class="line"><span class="comment">3、于是，编译器认为最安全的做法是编译到父类的print函数，因为父类和子类肯定都有相同的print函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">howToPrint</span><span class="params">(Parent* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Child child;</span><br><span class="line">	Parent* pp = &amp;child;</span><br><span class="line">	Parent&amp; rp = child;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//child.print();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过指针</span></span><br><span class="line">	<span class="comment">//pp-&gt;print();</span></span><br><span class="line">	<span class="comment">//通过引用</span></span><br><span class="line">	<span class="comment">//rp.print();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">howToPrint</span>(&amp;child);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">run</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据实际的对象类型来判断重写函数的调用。</p>
<ul>
<li><p>如果父类指针指向的是父类对象则调用父类中定义的函数</p>
</li>
<li><p>如果父类指针指向的是子类对象则调用子类中定义的重写函数</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/630f141616f2c2beb1a19f3a.jpg"></p>
<p>C++中通过virtual关键字对多态进行支持，使用virtual声明的函数被重写后即可展现多态特性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caculator</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setA</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mA = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setB</span><span class="params">(<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mB = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setOperator</span><span class="params">(string oper)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mOperator = oper;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mOperator == <span class="string">&quot;+&quot;</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> mA + mB;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mOperator == <span class="string">&quot;-&quot;</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> mA - mB;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mOperator == <span class="string">&quot;*&quot;</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> mA * mB;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mOperator == <span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> mA / mB;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="type">int</span> mB;</span><br><span class="line">	string mOperator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这种程序不利于扩展，维护困难，如果修改功能或者扩展功能需要在源代码基础上修改</span></span><br><span class="line"><span class="comment">//面向对象程序设计一个基本原则:开闭原则(对修改关闭，对扩展开放)</span></span><br><span class="line"><span class="comment">//抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCaculator</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setA</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mA = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setB</span><span class="params">(<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mB = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="type">int</span> mB;</span><br><span class="line">	string mOperator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlusCaculator</span> : <span class="keyword">public</span> AbstractCaculator&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mA + mB;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinusCaculator</span> : <span class="keyword">public</span> AbstractCaculator&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mA - mB;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultipliesCaculator</span> : <span class="keyword">public</span> AbstractCaculator&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mA * mB;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoBussiness</span><span class="params">(AbstractCaculator* caculator)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	caculator-&gt;<span class="built_in">setA</span>(a);</span><br><span class="line">	caculator-&gt;<span class="built_in">setB</span>(b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;计算结果：&quot;</span> &lt;&lt; caculator-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> caculator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、向上类型转换"><a href="#2、向上类型转换" class="headerlink" title="2、向上类型转换"></a>2、向上类型转换</h2><p>对象可以作为自己的类或者作为它的基类的对象来使用。还能通过基类的地址来操作它。取一个对象的地址(指针或引用)，并将其作为基类的地址来处理，这种称为向上类型转换。也就是说：父类引用或指针可以指向子类对象，通过父类指针或引用来操作子类对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物在唱歌...&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小狗在唱歌...&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoBussiness</span><span class="params">(Animal&amp; animal)</span></span>&#123;</span><br><span class="line">	animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Dog dog;</span><br><span class="line">	<span class="built_in">DoBussiness</span>(dog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序运行结果是: 动物在唱歌</p>
<p>给DoBussiness传入的对象是dog，而不是animal对象，输出的结果应该是Dog::speak</p>
<p>解决这个问题，需要了解下绑定(捆绑,binding)概念。把函数体与函数调用相联系称为绑定(捆绑，binding)。</p>
<p>当绑定在程序运行之前(由编译器和连接器)完成时，称为早绑定(early binding).C语言中只有一种函数调用方式，就是早绑定。上面的问题就是由于早绑定引起的，因为编译器在只有Animal地址时并不知道要调用的正确函数。编译是根据指向对象的指针或引用的类型来选择函数调用。这个时候由于DoBussiness的参数类型是Animal&amp;,编译器确定了应该调用的speak是Animal::speak的，而不是真正传入的对象Dog::speak。解决方法就是迟绑定(迟捆绑,动态绑定,运行时绑定，late binding),意味着绑定要根据对象的实际类型，发生在运行。</p>
<p>C++语言要实现这种动态绑定，必须有某种机制来确定运行时对象的类型并调用合适的成员函数。对于一种编译语言，编译器并不知道实际的对象类型（编译器并不知道Animal类型的指针或引用指向的实际的对象类型）。</p>
<p>C++动态多态性是通过虚函数来实现的，虚函数允许子类（派生类）重新定义父类（基类）成员函数，而子类（派生类）重新定义父类（基类）虚函数的做法称为覆盖(override)，或者称为重写。</p>
<p>对于特定的函数进行动态绑定，c++要求在基类中声明这个函数的时候使用virtual关键字，动态绑定也就对virtual函数起作用。</p>
<ul>
<li><p>为创建一个需要动态绑定的虚成员函数，可以简单在这个函数声明前面加上virtual关键字，定义时候不需要。</p>
</li>
<li><p>如果一个函数在基类中被声明为virtual，那么在所有派生类中它都是virtual的。</p>
</li>
<li><p>在派生类中virtual函数的重定义称为重写(override)。</p>
</li>
<li><p>virtual关键字只能修饰成员函数。</p>
</li>
<li><p>构造函数不能为虚函数。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物在唱歌...&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小狗在唱歌...&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoBussiness</span><span class="params">(Animal&amp; animal)</span></span>&#123;</span><br><span class="line">	animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Dog dog;</span><br><span class="line">	<span class="built_in">DoBussiness</span>(dog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态绑定什么时候发生？所有的工作都是由编译器在幕后完成。当我们告诉通过创建一个virtual函数来告诉编译器要进行动态绑定，那么编译器就会根据动态绑定机制来实现我们的要求， 不会再执行早绑定。</p>
<p>C++的动态捆绑机制是怎么样的？</p>
<p>首先，看看编译器如何处理虚函数。当编译器发现类中有虚函数的时候，编译器会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在类中秘密增加一个指针，这个指针就是vpointer(缩写vptr)，这个指针是指向对象的虚函数表。在多态调用的时候，根据vptr指针，找到虚函数表来实现动态绑定。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B类为空，那么大小应该是1字节，实际情况是这样吗？</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A size:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;B size:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译阶段，编译器秘密增加了一个vptr指针，但是此时vptr指针并没有初始化指向虚函数表(vtable)，什么时候vptr才会指向虚函数表？在对象构建的时候，也就是在对象初始化调用构造函数的时候。编译器首先默认会在我们所编写的每一个构造函数中，增加一些vptr指针初始化的代码。如果没有提供构造函数，编译器会提供默认的构造函数，那么就会在默认构造函数里做此项工作，初始化vptr指针，使之指向本对象的虚函数表。</p>
<p>起初，子类继承基类，子类继承了基类的vptr指针，这个vptr指针是指向基类虚函数表，当子类调用构造函数，使得子类的vptr指针指向了子类的虚函数表。</p>
<p>多态的成立条件：</p>
<ul>
<li><p>有继承</p>
</li>
<li><p>子类重写父类虚函数函数</p>
<p>   a) 返回值，函数名字，函数参数，必须和父类完全一致(析构函数除外)</p>
<p>   b) 子类中virtual关键字可写可不写，建议写</p>
</li>
<li><p>类型兼容，父类指针，父类引用 指向 子类对象</p>
</li>
</ul>
<h2 id="3、抽象基类和纯虚函数-pure-virtual-function"><a href="#3、抽象基类和纯虚函数-pure-virtual-function" class="headerlink" title="3、抽象基类和纯虚函数(pure virtual function)"></a>3、抽象基类和纯虚函数(pure virtual function)</h2><p>在设计时，常常希望基类仅仅作为其派生类的一个接口。这就是说，仅想对基类进行向上类型转换，使用它的接口，而不希望用户实际的创建一个基类的对象。同时创建一个纯虚函数允许接口中放置成员原函数，而不一定要提供一段可能对这个函数毫无意义的代码。做到这点，可以在基类中加入至少一个纯虚函数(pure virtual function)，使得基类称为抽象类(abstract class)。</p>
<ul>
<li><p>纯虚函数使用关键字virtual，并在其后面加上&#x3D;0。如果试图去实例化一个抽象类，编译器则会阻止这种操作。</p>
</li>
<li><p>当继承一个抽象类的时候，必须实现所有的纯虚函数，否则由抽象类派生的类也是一个抽象类。</p>
</li>
<li><p>virtual void fun() &#x3D; 0;告诉编译器在vtable中为函数保留一个位置，但在这个特定位置不放地址。</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/630f143716f2c2beb1a1b33f.jpg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//规定流程</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MakeDrink</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">Boil</span>();</span><br><span class="line">		<span class="built_in">Brew</span>();</span><br><span class="line">		<span class="built_in">PourInCup</span>();</span><br><span class="line">		<span class="built_in">PutSomething</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> AbstractDrinking&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> AbstractDrinking&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入食盐!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoBussiness</span><span class="params">(AbstractDrinking* drink)</span></span>&#123;</span><br><span class="line">	drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line">	<span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">DoBussiness</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">DoBussiness</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、纯虚函数和多继承"><a href="#4、纯虚函数和多继承" class="headerlink" title="4、纯虚函数和多继承"></a>4、纯虚函数和多继承</h2><p>绝大数面向对象语言都不支持多继承，但是绝大数面向对象对象语言都支持接口的概念，c++中没有接口的概念，但是可以通过纯虚函数实现接口。接口类中只有函数原型定义，没有任何数据定义。多重继承接口不会带来二义性和复杂性问题。接口类只是一个功能声明，并不是功能实现，子类需要根据功能说明定义功能实现。除了析构函数外，其他声明都是纯虚函数。</p>
<h3 id="4-1、虚析构函数"><a href="#4-1、虚析构函数" class="headerlink" title="4.1、虚析构函数"></a>4.1、虚析构函数</h3><p>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">People</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;构造函数 People!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">People</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数 People!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> : <span class="keyword">public</span> People&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Worker</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;构造函数 Worker!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		pName = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;打印子类的名字!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Worker</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数 Worker!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">delete</span> pName;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* pName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	People* people = <span class="keyword">new</span> Worker;</span><br><span class="line">	people-&gt;~<span class="built_in">People</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2、纯虚析构函数"><a href="#4-2、纯虚析构函数" class="headerlink" title="4.2、纯虚析构函数"></a>4.2、纯虚析构函数</h3><p>纯虚析构函数在c++中是合法的，但是在使用的时候有一个额外的限制：必须为纯虚析构函数提供一个函数体。那么问题是：如果给虚析构函数提供函数体了，那怎么还能称作纯虚析构函数呢？</p>
<p>纯虚析构函数和非纯析构函数之间唯一的不同之处在于纯虚析构函数使得基类是抽象类，不能创建基类的对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非纯虚析构函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">A</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//纯析构函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">B</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B::~<span class="built_in">B</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	A a; <span class="comment">//A类不是抽象类，可以实例化对象</span></span><br><span class="line">	B b; <span class="comment">//B类是抽象类，不可以实例化对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、重载-重定义-重写"><a href="#5、重载-重定义-重写" class="headerlink" title="5、重载  重定义 重写"></a>5、重载  重定义 重写</h2><ul>
<li><p>重载，同一作用域的同名函数</p>
<p> 1）同一个作用域</p>
<p> 2）参数个数，参数顺序，参数类型不同</p>
<p>3）和函数返回值，没有关系</p>
<p>4）const也可以作为重载条件  &#x2F;&#x2F;do(const Teacher&amp; t){}  do(Teacher&amp; t)</p>
</li>
<li><p>重定义（隐藏）</p>
<p>1）有继承</p>
<p>2）子类（派生类）重新定义父类（基类）的同名成员（非virtual函数）</p>
</li>
<li><p>重写（覆盖）</p>
<p>1）有继承</p>
<p>2）子类（派生类）重写父类（基类）的virtual函数</p>
<p>3）函数返回值，函数名字，函数参数，必须和基类中的虚函数一致</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//同一作用域下，func1函数重载</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//重定义基类的func2,隐藏了基类的func2方法</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="comment">//重写基类的func3函数，也可以覆盖基类func3</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象-多继承</title>
    <url>/2022/08/31/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="面向对象–多继承"><a href="#面向对象–多继承" class="headerlink" title="面向对象–多继承"></a>面向对象–多继承</h1><h2 id="1、多继承概念"><a href="#1、多继承概念" class="headerlink" title="1、多继承概念"></a>1、多继承概念</h2><p>多继承：一个类有多个直接基类的继承关系称为多继承。<span id="more"></span></p>
<p>多继承声明语法：</p>
<p>class  派生类名 : 访问控制  基类名 ,  访问控制  基类名 ,  … , 访问控制  基类名</p>
<p>  {</p>
<p>​       数据成员和成员函数声明</p>
<p>  }；</p>
<p><img src="https://pic.imgdb.cn/item/630f136716f2c2beb1a13272.jpg"></p>
<p>类 C 可以根据访问控制同时继承类 A 和类 B 的成员，并添加自己的成员</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Base1::func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Base2::func1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Base2::func2&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//派生类继承Base1、Base2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	Derived derived;</span><br><span class="line">	<span class="comment">//func1是从Base1继承来的还是从Base2继承来的？</span></span><br><span class="line">	<span class="comment">//derived.func1(); </span></span><br><span class="line">	derived.<span class="built_in">func2</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//解决歧义:显示指定调用那个基类的func1</span></span><br><span class="line">	derived.Base1::<span class="built_in">func1</span>(); </span><br><span class="line">	derived.Base2::<span class="built_in">func1</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多继承会带来一些二义性的问题， 如果两个基类中有同名的函数或者变量，那么通过派生类对象去访问这个函数或变量时就不能明确到底调用从基类1继承的版本还是从基类2继承的版本？解决方法就是显示指定调用那个基类的版本。</p>
<p>多继承的派生类构造和访问</p>
<ul>
<li><p>多个基类的派生类构造函数可以用初始式调用基类构造函数初始化数据成员</p>
</li>
<li><p>执行顺序与单继承构造函数情况类似。多个直接基类构造函数执行顺序取决于定义派生类时指定的各个继承基类的顺序。</p>
</li>
<li><p>一个派生类对象拥有多个直接或间接基类的成员。不同名成员访问不会出现二义性。如果不同的基类有同名成员，派生类对象访问时应该加以识别。</p>
</li>
</ul>
<h2 id="2、菱形继承和虚继承"><a href="#2、菱形继承和虚继承" class="headerlink" title="2、菱形继承和虚继承"></a>2、菱形继承和虚继承</h2><p>两个派生类继承同一个基类而又有某个类同时继承者两个派生类，这种继承被称为菱形继承，或者钻石型继承。</p>
<p><img src="https://pic.imgdb.cn/item/630f138516f2c2beb1a14480.jpg"></p>
<p>这种继承所带来的问题：</p>
<p>1）羊继承了动物的数据和函数，鸵同样继承了动物的数据和函数，当草泥马调用函数或者数据时，就会产生二义性。</p>
<p>2）草泥马继承自动物的函数和数据继承了两份，其实应该清楚，这份数据只需要一份就可以。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigBase</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BigBase</span>()&#123; mParam = <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;BigBase::func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mParam;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> : <span class="keyword">public</span> BigBase&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> : <span class="keyword">public</span> BigBase&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	Derived derived;</span><br><span class="line">	<span class="comment">//1. 对“func”的访问不明确</span></span><br><span class="line">	<span class="comment">//derived.func();</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; derived.mParam &lt;&lt; endl;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;derived.Base1::mParam:&quot;</span> &lt;&lt; derived.Base1::mParam &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;derived.Base2::mParam:&quot;</span> &lt;&lt; derived.Base2::mParam &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2. 重复继承</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Derived size:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Derived) &lt;&lt; endl; <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述问题如何解决？对于调用二义性，那么可通过指定调用那个基类的方式来解决，那么重复继承怎么解决？</p>
<p>对于这种菱形继承所带来的两个问题，c++提供了一种方式，采用虚基类。采用虚基类方式将代码修改如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigBase</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BigBase</span>()&#123; mParam = <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;BigBase::func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mParam;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> BigBase&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> BigBase&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	Derived derived;</span><br><span class="line">	<span class="comment">//二义性问题解决</span></span><br><span class="line">	derived.<span class="built_in">func</span>();</span><br><span class="line">	cout &lt;&lt; derived.mParam &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//输出结果:12</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Derived size:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Derived) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序Base1 ，Base2采用虚继承方式继承BigBase,那么BigBase被称为虚基类。通过虚继承解决了菱形继承所带来的二义性问题。但是虚基类是如何解决二义性的呢？并且derived大小为12字节，这是怎么回事？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigBase</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BigBase</span>()&#123; mParam = <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;BigBase::func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">public</span>: <span class="type">int</span> mParam;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0 <span class="comment">//虚继承</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> BigBase&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> BigBase&#123;&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">//普通继承</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> :  <span class="keyword">public</span> BigBase&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> :  <span class="keyword">public</span> BigBase&#123;&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>当使用虚继承时，虚基类是被共享的，也就是在继承体系中无论被继承多少次，对象内存模型中均只会出现一个虚基类的子对象（这和多继承是完全不同的）。即使共享虚基类，但是必须要有一个类来完成基类的初始化（因为所有的对象都必须被初始化，哪怕是默认的），同时还不能够重复进行初始化，那到底谁应该负责完成初始化呢？C++标准中选择在每一次继承子类中都必须书写初始化语句（因为每一次继承子类可能都会用来定义对象），但是虚基类的初始化是由最后的子类完成，其他的初始化语句都不会调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigBase</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">BigBase</span>(<span class="type">int</span> x)&#123;mParam = x;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;cout &lt;&lt; <span class="string">&quot;BigBase::func&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mParam;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> BigBase&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>() :<span class="built_in">BigBase</span>(<span class="number">10</span>)&#123;&#125; <span class="comment">//不调用BigBase构造</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> BigBase&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base2</span>() :<span class="built_in">BigBase</span>(<span class="number">10</span>)&#123;&#125; <span class="comment">//不调用BigBase构造</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Derived</span>() :<span class="built_in">BigBase</span>(<span class="number">10</span>)&#123;&#125; <span class="comment">//调用BigBase构造</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//每一次继承子类中都必须书写初始化语句</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Derived derived;</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚继承只能解决具备公共祖先的多继承所带来的二义性问题，不能解决没有公共祖先的多继承的。工程开发中真正意义上的多继承是几乎不被使用，因为多重继承带来的代码复杂性远多于其带来的便利，多重继承对代码维护性上的影响是灾难性的，在设计方法上，任何多继承都可以用单继承代替。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象-继承和派生-2</title>
    <url>/2022/08/31/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="面向对象–继承中的构造和析构"><a href="#面向对象–继承中的构造和析构" class="headerlink" title="面向对象–继承中的构造和析构"></a>面向对象–继承中的构造和析构</h1><h2 id="1、继承中的对象模型"><a href="#1、继承中的对象模型" class="headerlink" title="1、继承中的对象模型"></a>1、继承中的对象模型</h2><p>类在C++编译器的内部可以理解为结构体。子类是由父类成员叠加子类新成员得到的。<span id="more"></span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Aclass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="type">int</span> mB;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bclass</span> : <span class="keyword">public</span> Aclass&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mC;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cclass</span> : <span class="keyword">public</span> Bclass&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mD;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A size:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Aclass) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;B size:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Bclass) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C size:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Cclass) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、继承中的对象构造和析构"><a href="#2、继承中的对象构造和析构" class="headerlink" title="2、继承中的对象构造和析构"></a>2、继承中的对象构造和析构</h2><p>在继承关系中，如何初始化父类成员？父类与子类的构造函数有什么关系？</p>
<ul>
<li><p>在子类对象构造时，需要调用父类构造函数对其继承得来的成员进行初始化</p>
</li>
<li><p>在子类对象析构时，需要调用父类析构函数对其继承得来的成员进行清理</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/630f12b616f2c2beb1a0d280.jpg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A类构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">A</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A类析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B类构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">B</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;B类析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">C</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C类构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">C</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C类析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	C c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承中，对象的构造和析构调用原则：</p>
<p>1）子类对象在创建时会首先调用父类的构造函数</p>
<p>2）父类构造函数执行结束后，执行子类的构造函数</p>
<p>3）当父类的构造函数有参数时，需要在子类的初始化列表中显示调用</p>
<p>4）析构函数调用的先后顺序与构造函数相反</p>
<h2 id="3、继承和组合混合的时候，对象的构造和析构"><a href="#3、继承和组合混合的时候，对象的构造和析构" class="headerlink" title="3、继承和组合混合的时候，对象的构造和析构"></a>3、继承和组合混合的时候，对象的构造和析构</h2><p>当继承和组合混合的术后，对象的构造和析构原则是先构造父类，再构造成员变量、最后构造自己。先析构自己，在析构成员变量、最后析构父类。先构造的对象，后释放。</p>
<p><img src="https://pic.imgdb.cn/item/630f12d316f2c2beb1a0e2f0.jpg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承和组合混搭情况下，构造函数、析构函数调用顺序研究</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Object</span>(<span class="type">const</span> <span class="type">char</span>* s)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Object()&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Object</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;~Object()&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> : <span class="keyword">public</span> Object</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Parent</span>(<span class="type">const</span> <span class="type">char</span>* s) : <span class="built_in">Object</span>(s)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Parent()&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Parent</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;~Parent()&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Object o1;</span><br><span class="line">	Object o2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Child</span>() : <span class="built_in">o2</span>(<span class="string">&quot;o2&quot;</span>), <span class="built_in">o1</span>(<span class="string">&quot;o1&quot;</span>), <span class="built_in">Parent</span>(<span class="string">&quot;Parameter from Child!&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;Child()&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Child</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;~Child()&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Child child;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、继承中同名成员的处理方法"><a href="#4、继承中同名成员的处理方法" class="headerlink" title="4、继承中同名成员的处理方法"></a>4、继承中同名成员的处理方法</h2><ul>
<li><p>当子类成员和父类成员同名时，子类依然从父类继承同名成员</p>
</li>
<li><p>如果子类有成员和父类同名，子类访问其成员默认访问子类的成员(本作用域，就近原则)</p>
</li>
<li><p>在子类通过作用域::进行同名成员区分(在派生类中使用基类的同名成员，显示使用类名限定符)</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>():<span class="built_in">mParam</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123; cout &lt;&lt; mParam &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mParam;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Derived</span>():<span class="built_in">mParam</span>(<span class="number">10</span>)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//在派生类中使用和基类的同名成员,显示使用类名限定符</span></span><br><span class="line">		cout &lt;&lt; Base::mParam &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; mParam &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回基类重名成员</span></span><br><span class="line">	<span class="function"><span class="type">int</span>&amp; <span class="title">getBaseParam</span><span class="params">()</span></span>&#123; <span class="keyword">return</span>  Base::mParam; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mParam;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	Derived derived;</span><br><span class="line">	<span class="comment">//派生类和基类成员属性重名，子类访问成员默认是子类成员</span></span><br><span class="line">	cout &lt;&lt; derived.mParam &lt;&lt; endl; <span class="comment">//10</span></span><br><span class="line">	derived.<span class="built_in">Print</span>();</span><br><span class="line">	<span class="comment">//类外如何获得基类重名成员属性</span></span><br><span class="line">	derived.<span class="built_in">getBaseParam</span>() = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base:mParam:&quot;</span> &lt;&lt; derived.<span class="built_in">getBaseParam</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意: 如果重新定义了基类中的重载函数，将会发生什么？任何时候重新定义基类中的一个重载函数，在新类中所有的其他版本将被自动隐藏。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base::void func1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> param)</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base::void func1(int param)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base::void myfunc()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derived1::void myfunc()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//改变成员函数的参数列表</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> param1, <span class="type">int</span> param2)</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derived2::void func1(int param1,int param2)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived3</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//改变成员函数的返回值</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> param)</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Derived3::int func1(int param)&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	Derived1 derived1;</span><br><span class="line">	derived1.<span class="built_in">func1</span>();</span><br><span class="line">	derived1.<span class="built_in">func1</span>(<span class="number">20</span>);</span><br><span class="line">	derived1.<span class="built_in">myfunc</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	Derived2 derived2;</span><br><span class="line">	<span class="comment">//derived2.func1();  //func1被隐藏</span></span><br><span class="line">	<span class="comment">//derived2.func1(20); //func2被隐藏</span></span><br><span class="line">	derived2.<span class="built_in">func1</span>(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//重载func1之后，基类的函数被隐藏</span></span><br><span class="line">	derived2.<span class="built_in">myfunc</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	Derived3 derived3;</span><br><span class="line">	<span class="comment">//derived3.func1();  没有重新定义的重载版本被隐藏</span></span><br><span class="line">	derived3.<span class="built_in">func1</span>(<span class="number">20</span>);</span><br><span class="line">	derived3.<span class="built_in">myfunc</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Derive1 重定义了Base类的myfunc函数，derive1可访问func1及其重载版本的函数。</p>
</li>
<li><p>Derive2通过改变函数参数列表的方式重新定义了基类的func1函数，则从基类中继承来的其他重载版本被隐藏，不可访问</p>
</li>
<li><p>Derive3通过改变函数返回类型的方式重新定义了基类的func1函数，则从基类继承来的没有重新定义的重载版本的函数将被隐藏。</p>
</li>
</ul>
<h2 id="5、非自动继承的函数"><a href="#5、非自动继承的函数" class="headerlink" title="5、非自动继承的函数"></a>5、非自动继承的函数</h2><p>不是所有的函数都能自动从基类继承到派生类中。构造函数和析构函数用来处理对象的创建和析构操作，构造和析构函数只知道对它们的特定层次的对象做什么，也就是说构造函数和析构函数不能被继承，必须为每一个特定的派生类分别创建。</p>
<p>另外operator&#x3D;也不能被继承，因为它完成类似构造函数的行为。也就是说尽管我们知道如何由&#x3D;右边的对象如何初始化&#x3D;左边的对象的所有成员，但是这个并不意味着对其派生类依然有效。在继承的过程中，如果没有创建这些函数，编译器会自动生成它们。</p>
<h2 id="6、派生类中的static关键字"><a href="#6、派生类中的static关键字" class="headerlink" title="6、派生类中的static关键字"></a>6、派生类中的static关键字</h2><p>静态成员函数和非静态成员函数的共同点:</p>
<p>1）都可以被继承到派生类中。</p>
<p>2） 如果重新定义一个静态成员函数，所有在基类中的其他重载函数会被隐藏。</p>
<p>3）如果我们改变基类中一个函数的特征，所有使用该函数名的基类版本都会被隐藏。</p>
<p>4）静态成员函数不能是虚函数（virtual function）.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getNum</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> sNum; &#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getNum</span><span class="params">(<span class="type">int</span> param)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sNum + param;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> sNum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Base::sNum = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> sNum; <span class="comment">//基类静态成员属性将被隐藏</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">//重定义一个函数，基类中重载的函数被隐藏</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getNum</span><span class="params">(<span class="type">int</span> param1, <span class="type">int</span> param2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sNum + param1 + param2;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">//改变基类函数的某个特征，返回值或者参数个数，将会隐藏基类重载的函数</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">getNum</span><span class="params">(<span class="type">int</span> param1, <span class="type">int</span> param2)</span></span>&#123;</span><br><span class="line">		cout &lt;&lt;  sNum + param1 + param2 &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Derived::sNum = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象-继承和派生-1</title>
    <url>/2022/08/31/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="面向对象–继承与派生"><a href="#面向对象–继承与派生" class="headerlink" title="面向对象–继承与派生"></a>面向对象–继承与派生</h1><p>面向对象程序设计有4个主要特点：<strong>抽象、封装、继承和多态性</strong>。<span id="more"></span></p>
<p>已经讲解了类和对象，了解了面向对象程序设计的两个重要特征一数据抽象与封装，已经能够设计出基于对象的程序，这是面向对象程序设计的基础。要较好地进行面向对象程序设计，还必须了解面向对象程序设计另外两个重要特征——继承和多态</p>
<p>继承是面向对象程序设计最重要的特征。</p>
<h2 id="1、继承概念"><a href="#1、继承概念" class="headerlink" title="1、继承概念"></a>1、继承概念</h2><p>万事万物中皆有继承，是重要的现象。</p>
<p><img src="https://pic.imgdb.cn/item/630f11ed16f2c2beb1a05aa1.jpg"></p>
<p>具有is-a关系的 机制称为“继承”。继承关系具有传递性，不具有对称性。</p>
<p>c++最重要的特征是代码重用，通过继承机制可以利用已有的数据类型来定义新的数据类型，新的类不仅拥有旧类的成员，还拥有新定义的成员。</p>
<p>一个B类继承于A类，或称从类A派生类B。这样的话，类A成为基类（父类）， 类B成为派生类（子类）。</p>
<p>派生类中的成员，包含两大部分：</p>
<ul>
<li><p>一类是从基类继承过来的，一类是自己增加的成员。</p>
</li>
<li><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/630f120b16f2c2beb1a06bfa.jpg"></p>
<h2 id="2、派生类定义"><a href="#2、派生类定义" class="headerlink" title="2、派生类定义"></a>2、派生类定义</h2><h3 id="2-1、语法"><a href="#2-1、语法" class="headerlink" title="2.1、语法"></a>2.1、语法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名 :  继承方式 基类名</span><br><span class="line">&#123;    </span><br><span class="line">  <span class="comment">//派生类新增的数据成员和成员函数  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三种继承方式： </p>
<ul>
<li><p>public ：   公有继承</p>
</li>
<li><p>private ：  私有继承</p>
</li>
<li><p>protected ： 保护继承</p>
</li>
</ul>
<p>C++中的继承方式（public、private、protected）会影响子类的对外访问属性。</p>
<p>从继承源上分： </p>
<ul>
<li><p>单继承：指每个派生类只直接继承了一个基类的特征</p>
</li>
<li><p>多继承：指多个基类派生出一个派生类的继承关系，多继承的派生类直接继承了不止一个基类的特征</p>
</li>
</ul>
<p>注意，子类（派生类）继承了父类什么？子类（派生类）对象和父类对象的关系？</p>
<p>1）子类拥有父类的所有成员变量和成员函数 </p>
<p>2）子类可以拥有父类没有的方法和属性</p>
<p>3）子类就是一种特殊的父类</p>
<p>4）子类对象可以当作父类对象使用</p>
<h3 id="2-2、派生类的访问控制"><a href="#2-2、派生类的访问控制" class="headerlink" title="2.2、派生类的访问控制"></a>2.2、派生类的访问控制</h3><p>派生类继承了基类的全部成员变量和成员方法（除了构造和析构之外的成员方法），但是这些成员的访问属性，在派生过程中是可以调整的。不同的继承方式会改变继承成员的访问属性。</p>
<p><img src="https://pic.imgdb.cn/item/630f122e16f2c2beb1a07eb5.jpg"></p>
<p>如下案例：</p>
<p><img src="https://pic.imgdb.cn/item/630f124016f2c2beb1a08b1d.jpg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> mB;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mC;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 公有(public)继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintB</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; mA &lt;&lt; endl; <span class="comment">//可访问基类public属性</span></span><br><span class="line">		cout &lt;&lt; mB &lt;&lt; endl; <span class="comment">//可访问基类protected属性</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; mC &lt;&lt; endl; //不可访问基类private属性</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubB</span> : <span class="keyword">public</span> B&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintSubB</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; mA &lt;&lt; endl; <span class="comment">//可访问基类public属性</span></span><br><span class="line">		cout &lt;&lt; mB &lt;&lt; endl; <span class="comment">//可访问基类protected属性</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; mC &lt;&lt; endl; //不可访问基类private属性</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	B b;</span><br><span class="line">	cout &lt;&lt; b.mA &lt;&lt; endl; <span class="comment">//可访问基类public属性</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; b.mB &lt;&lt; endl; //不可访问基类protected属性</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; b.mC &lt;&lt; endl; //不可访问基类private属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 私有(private)继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">private</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintC</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; mA &lt;&lt; endl; <span class="comment">//可访问基类public属性</span></span><br><span class="line">		cout &lt;&lt; mB &lt;&lt; endl; <span class="comment">//可访问基类protected属性</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; mC &lt;&lt; endl; //不可访问基类private属性</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubC</span> : <span class="keyword">public</span> C&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintSubC</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; mA &lt;&lt; endl; //不可访问基类public属性</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; mB &lt;&lt; endl; //不可访问基类protected属性</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; mC &lt;&lt; endl; //不可访问基类private属性</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	C c;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; c.mA &lt;&lt; endl; //不可访问基类public属性</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; c.mB &lt;&lt; endl; //不可访问基类protected属性</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; c.mC &lt;&lt; endl; //不可访问基类private属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 保护(protected)继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">protected</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintD</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; mA &lt;&lt; endl; <span class="comment">//可访问基类public属性</span></span><br><span class="line">		cout &lt;&lt; mB &lt;&lt; endl; <span class="comment">//可访问基类protected属性</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; mC &lt;&lt; endl; //不可访问基类private属性</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubD</span> : <span class="keyword">public</span> D&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintD</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; mA &lt;&lt; endl; <span class="comment">//可访问基类public属性</span></span><br><span class="line">		cout &lt;&lt; mB &lt;&lt; endl; <span class="comment">//可访问基类protected属性</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; mC &lt;&lt; endl; //不可访问基类private属性</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">	D d;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; d.mA &lt;&lt; endl; //不可访问基类public属性</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; d.mB &lt;&lt; endl; //不可访问基类protected属性</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; d.mC &lt;&lt; endl; //不可访问基类private属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>总结：C++中的继承方式（public、private、protected）会影响子类的对外访问属性。判断某一句话，能否被访问</p>
<p>1）看调用语句，这句话写在子类的内部、外部</p>
<p>2）看子类如何从父类继承（public、private、protected）	</p>
<p>3）看父类中的访问级别（public、private、protected）</p>
<p>因此，在设计类的时候可以如下思考：</p>
<p>1）需要被外界访问的成员直接设置为public</p>
<p>2）只能在当前类中访问的成员设置为private</p>
<p>3）只能在当前类和子类中访问的成员设置为protected，protected成员的访问权限介于public和private之间。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象-运算符重载</title>
    <url>/2022/08/31/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="面向对象–运算符重载"><a href="#面向对象–运算符重载" class="headerlink" title="面向对象–运算符重载"></a>面向对象–运算符重载</h1><p>重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋予新的含义，使之实现新功能，因此，一个函数名就可以用来代表不同功能的函数，也就是”一名多用”。<span id="more"></span></p>
<p>运算符也可以重载。实际上，我们已经在不知不觉之中使用了运算符重载。例如，大 家都已习惯于用加法运算符”+”对整数、单精度数和双精度数进行加法运算，如5+8， 5.8 +3.67等，其实计算机对整数、单精度数和双精度数的加法操作过程是很不相同的， 但由于C++已经对运算符”+”进行了重载，所以就能适用于int, float, doUble类型的运算。</p>
<p>又如”&lt;&lt;“是C++的位运算中的位移运算符（左移），但在输出操作中又是与流对象cout 配合使用的流插入运算符，”&gt;&gt;“也是位移运算符(右移），但在输入操作中又是与流对象 cin 配合使用的流提取运算符。这就是运算符重载(operator overloading)。C++系统对”&lt;&lt;“和”&gt;&gt;“进行了重载，用户在不同的场合下使用它们时，作用是不同 的。对”&lt;&lt;“和”&gt;&gt;“的重载处理是放在头文件stream中的。因此，如果要在程序中用”&lt;&lt; “和”&gt;&gt;”作流插入运算符和流提取运算符，必须在本文件模块中包含头文件stream(当然还应当包括”using namespace std“)。</p>
<p>现在要讨论的问题是：用户能否根据自己的需要对C++已提供的运算符进行重载，赋予它们新的含义，使之一名多用。</p>
<h2 id="1、语法"><a href="#1、语法" class="headerlink" title="1、语法"></a>1、语法</h2><p>在c++中，可以定义一个处理类的新运算符。这种定义很像一个普通的函数定义，只是函数的名字由关键字operator及其紧跟的运算符组成。差别仅此而已。它像任何其他函数一样也是一个函数，当编译器遇到适当的模式时，就会调用这个函数。</p>
<p>定义重载的运算符就像定义函数，只是该函数的名字是operator@，这里的@代表了被重载的运算符。函数的参数中参数个数取决于两个因素。</p>
<ul>
<li><p>运算符是一元(一个参数)的还是二元(两个参数)；</p>
</li>
<li><p>运算符被定义为全局函数(对于一元是一个参数，对于二元是两个参数)还是成员函数(对于一元没有参数，对于二元是一个参数)</p>
</li>
</ul>
<p>用复数类举例，假设自定义了一个复数类Complex。现有如下计算 Complexc3 &#x3D; c1 + c2;由于Complex是用户自定义类型，编译器根本不知道如何进行加减。编译器给提供了运算符重载机制，让用户自己去完成，自定义类型的加减操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">	<span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(Complex &amp;c1, Complex &amp;c2);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printCom</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;<span class="string">&quot; + &quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot;i &quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Complex myAdd(Complex &amp;c1, Complex &amp;c2)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	Complex tmp(c1.a+ c2.a, c1.b + c2.b);</span></span><br><span class="line"><span class="comment">	return tmp;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">Complex <span class="keyword">operator</span>+(Complex &amp;c1, Complex &amp;c2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">tmp</span><span class="params">(c1.a+ c2.a, c1.b + c2.b)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">c2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Complex c3 = c1 + c2;  //用户自定义类型 编译器无法让变量相加</span></span><br><span class="line">	<span class="comment">//Complex myAdd(Complex &amp;c1, Complex &amp;c2);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1 普通函数</span></span><br><span class="line">	<span class="comment">//Complex c3 = myAdd(c1, c2);</span></span><br><span class="line">	<span class="comment">//c3.printCom();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2 operator+ 函数名称</span></span><br><span class="line">	<span class="comment">//Complex c3 = operator+(c1, c2);</span></span><br><span class="line">	<span class="comment">//c3.printCom();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//3 +替换 函数名</span></span><br><span class="line">	Complex c3 = c1 + c2; <span class="comment">//思考C++编译器如何支持操作符重载机制的 (根据类型)</span></span><br><span class="line">	c3.<span class="built_in">printCom</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//4 把Complex类变成私有属性</span></span><br><span class="line">	<span class="comment">//友元函数的应用场景</span></span><br><span class="line">	<span class="comment">//friend Complex operator+(Complex &amp;c1, Complex &amp;c2);</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;hello...&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、可重载的运算符"><a href="#2、可重载的运算符" class="headerlink" title="2、可重载的运算符"></a>2、可重载的运算符</h2><p>几乎C中所有的运算符都可以重载，但运算符重载的使用时相当受限制的。特别是不能使用C中当前没有意义的运算符(例如用**求幂)不能改变运算符优先级，不能改变运算符的参数个数。这样的限制有意义，否则，所有这些行为产生的运算符只会混淆而不是澄清寓语意。</p>
<p><img src="https://pic.imgdb.cn/item/630ed11416f2c2beb17a69d4.jpg"></p>
<p>运算符重载的两种方法：</p>
<p>1）成员函数重载运算符</p>
<p>2）友元函数重载运算符</p>
<p>不管是成员函数重载运算符还是友元函数重载运算符，运算符的使用方法相同，但传递参数的方式不同，实现方式不同，应用场景不同。区别在于，成员函数有this指针，友元函数没有this指针。</p>
<p><img src="https://pic.imgdb.cn/item/630ed12316f2c2beb17a73d0.jpg"></p>
<p><img src="https://pic.imgdb.cn/item/630ed13716f2c2beb17a7ede.jpg"></p>
<h3 id="2-1、自增自减-x2F-–-运算符重载"><a href="#2-1、自增自减-x2F-–-运算符重载" class="headerlink" title="2.1、自增自减(++&#x2F;–)运算符重载"></a>2.1、自增自减(++&#x2F;–)运算符重载</h3><p>重载的++和–运算符有点让人不知所措，因为希望能根据它们出现在所作用对象的前面还是后面来调用不同的函数。解决办法很简单，例如当编译器看到++a(前置++)，它就调用operator++(a)，当编译器看到a++（后置++），它就会去调用operator++(a,int).</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,Complex&amp; complex)&#123;</span><br><span class="line">		os &lt;&lt; <span class="string">&quot;A:&quot;</span> &lt;&lt; complex.mA &lt;&lt; <span class="string">&quot; B:&quot;</span> &lt;&lt; complex.mB &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> os;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>()&#123;</span><br><span class="line">		mA = <span class="number">0</span>;</span><br><span class="line">		mB = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载前置++</span></span><br><span class="line">	Complex&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">		mA++;</span><br><span class="line">		mB++;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载后置++</span></span><br><span class="line">	Complex <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;	</span><br><span class="line">		Complex temp;</span><br><span class="line">		temp.mA = <span class="keyword">this</span>-&gt;mA;</span><br><span class="line">		temp.mB = <span class="keyword">this</span>-&gt;mB;</span><br><span class="line">		mA++;</span><br><span class="line">		mB++;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//前置--</span></span><br><span class="line">	Complex&amp; <span class="keyword">operator</span>--()&#123;</span><br><span class="line">		mA--;</span><br><span class="line">		mB--;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//后置--</span></span><br><span class="line">	Complex <span class="keyword">operator</span>--(<span class="type">int</span>)&#123;</span><br><span class="line">		Complex temp;</span><br><span class="line">		temp.mA = mA;</span><br><span class="line">		temp.mB = mB;</span><br><span class="line">		mA--;</span><br><span class="line">		mB--;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowComplex</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;A:&quot;</span> &lt;&lt; mA &lt;&lt; <span class="string">&quot; B:&quot;</span> &lt;&lt; mB &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="type">int</span> mB;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Complex complex;</span><br><span class="line">	complex++;</span><br><span class="line">	cout &lt;&lt; complex;</span><br><span class="line">	++complex;</span><br><span class="line">	cout &lt;&lt; complex;</span><br><span class="line"></span><br><span class="line">	Complex ret = complex++;</span><br><span class="line">	cout &lt;&lt; ret;</span><br><span class="line">	cout &lt;&lt; complex;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	ret--;</span><br><span class="line">	--ret;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret:&quot;</span> &lt;&lt; ret;</span><br><span class="line">	complex--;</span><br><span class="line">	--complex;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;complex:&quot;</span> &lt;&lt; complex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2、指针运算符-、-gt-重载"><a href="#2-2、指针运算符-、-gt-重载" class="headerlink" title="2.2、指针运算符(*、-&gt;)重载"></a>2.2、指针运算符(*、-&gt;)重载</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> param)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mParam = param;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Param:&quot;</span> &lt;&lt; mParam &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mParam;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPointer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SmartPointer</span>(Person* person)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pPerson = person;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载指针的-&gt;、*操作符</span></span><br><span class="line">	Person* <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">		<span class="keyword">return</span> pPerson;</span><br><span class="line">	&#125;</span><br><span class="line">	Person&amp; <span class="keyword">operator</span>*()&#123;</span><br><span class="line">		<span class="keyword">return</span> *pPerson;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">SmartPointer</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span> (pPerson != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">delete</span> pPerson;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Person* pPerson;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Person* person = new Person(100);</span></span><br><span class="line">	<span class="comment">//如果忘记释放，那么就会造成内存泄漏</span></span><br><span class="line"></span><br><span class="line">	<span class="function">SmartPointer <span class="title">pointer</span><span class="params">(<span class="keyword">new</span> Person(<span class="number">100</span>))</span></span>;</span><br><span class="line">	pointer-&gt;<span class="built_in">PrintPerson</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3、赋值-x3D-运算符重载"><a href="#2-3、赋值-x3D-运算符重载" class="headerlink" title="2.3、赋值(&#x3D;)运算符重载"></a>2.3、赋值(&#x3D;)运算符重载</h3><p>赋值符常常混淆。这是因为’&#x3D;’在编程中是最基本的运算符，可以进行赋值操作，也能引起拷贝构造函数的调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="type">const</span> Person&amp; person)&#123;</span><br><span class="line">		os &lt;&lt; <span class="string">&quot;ID:&quot;</span> &lt;&lt; person.mID &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; person.mAge &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> os;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> id,<span class="type">int</span> age)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mID = id;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载赋值运算符</span></span><br><span class="line">	Person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Person&amp; person)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mID = person.mID;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = person.mAge;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mID;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. =号混淆的地方</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">person1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	Person person2 = person1; <span class="comment">//调用拷贝构造</span></span><br><span class="line">	<span class="comment">//如果一个对象还没有被创建，则必须初始化，也就是调用构造函数</span></span><br><span class="line">	<span class="comment">//上述例子由于person2还没有初始化，所以会调用构造函数</span></span><br><span class="line">	<span class="comment">//由于person2是从已有的person1来创建的，所以只有一个选择</span></span><br><span class="line">	<span class="comment">//就是调用拷贝构造函数</span></span><br><span class="line">	person2 = person1; <span class="comment">//调用operator=函数</span></span><br><span class="line">	<span class="comment">//由于person2已经创建，不需要再调用构造函数，这时候调用的是重载的赋值运算符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 赋值重载案例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">person1</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">person2</span><span class="params">(<span class="number">30</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;person1:&quot;</span> &lt;&lt; person1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;person2:&quot;</span> &lt;&lt; person2;</span><br><span class="line">	person2 = person1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;person2:&quot;</span> &lt;&lt; person2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常见错误，当准备给两个相同对象赋值时，应该首先检查一下这个对象是否对自身赋值了</span></span><br><span class="line"><span class="comment">//对于本例来讲，无论如何执行这些赋值运算都是无害的，但如果对类的实现进行修改，那么将会出现差异；</span></span><br><span class="line"><span class="comment">//3. 类中指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span>&#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Person2&amp; person)&#123;</span><br><span class="line">		os &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; person.pName &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; person.mID &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; person.mAge &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> os;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person2</span>(<span class="type">char</span>* name,<span class="type">int</span> id, <span class="type">int</span> age)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pName = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pName, name);</span><br><span class="line">		<span class="keyword">this</span>-&gt;mID = id;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">	<span class="comment">//重载赋值运算符</span></span><br><span class="line">	Person2&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Person2&amp; person)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//注意:由于当前对象已经创建完毕，那么就有可能pName指向堆内存</span></span><br><span class="line">		<span class="comment">//这个时候如果直接赋值，会导致内存没有及时释放</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>-&gt;pName = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(person.pName) + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pName,person.pName);</span><br><span class="line">		<span class="keyword">this</span>-&gt;mID = person.mID;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = person.mAge;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person2</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* pName;</span><br><span class="line">	<span class="type">int</span> mID;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person2 <span class="title">person1</span><span class="params">(<span class="string">&quot;John&quot;</span>,<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person2 <span class="title">person2</span><span class="params">(<span class="string">&quot;Edward&quot;</span>,<span class="number">30</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;person1:&quot;</span> &lt;&lt; person1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;person2:&quot;</span> &lt;&lt; person2;</span><br><span class="line">	person2 = person1;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;person2:&quot;</span> &lt;&lt; person2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有重载赋值运算符，编译器会自动创建默认的赋值运算符重载函数。行为类似默认拷贝构造，进行简单值拷贝。</p>
<h3 id="2-4、等于和不等于-x3D-x3D-、-x3D-运算符重载"><a href="#2-4、等于和不等于-x3D-x3D-、-x3D-运算符重载" class="headerlink" title="2.4、等于和不等于(&#x3D;&#x3D;、!&#x3D;)运算符重载"></a>2.4、等于和不等于(&#x3D;&#x3D;、!&#x3D;)运算符重载</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Complex</span>(<span class="type">char</span>* name,<span class="type">int</span> id,<span class="type">int</span> age)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pName = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pName, name);</span><br><span class="line">		<span class="keyword">this</span>-&gt;mID = id;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载==号操作符</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Complex&amp; complex)&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;pName,complex.pName) == <span class="number">0</span> &amp;&amp; </span><br><span class="line">		    <span class="keyword">this</span>-&gt;mID == complex.mID &amp;&amp; </span><br><span class="line">			<span class="keyword">this</span>-&gt;mAge == complex.mAge)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//重载!=操作符</span></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Complex&amp; complex)&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;pName, complex.pName) != <span class="number">0</span> || </span><br><span class="line">		    <span class="keyword">this</span>-&gt;mID != complex.mID || </span><br><span class="line">			<span class="keyword">this</span>-&gt;mAge != complex.mAge)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Complex</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* pName;</span><br><span class="line">	<span class="type">int</span> mID;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Complex <span class="title">complex1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Complex <span class="title">complex2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (complex1 == complex2)&#123; cout &lt;&lt; <span class="string">&quot;相等!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="keyword">if</span> (complex1 != complex2)&#123; cout &lt;&lt; <span class="string">&quot;不相等!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5、函数调用符号-重载"><a href="#2-5、函数调用符号-重载" class="headerlink" title="2.5、函数调用符号()重载"></a>2.5、函数调用符号()重载</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x + y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x + y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Complex complex;</span><br><span class="line">	cout &lt;&lt; complex.<span class="built_in">Add</span>(<span class="number">10</span>,<span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//对象当做函数来调用</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">complex</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、运算符重载总结"><a href="#3、运算符重载总结" class="headerlink" title="3、运算符重载总结"></a>3、运算符重载总结</h2><p>1） &#x3D;, [], () 和 -&gt; 操作符只能通过成员函数进行重载 </p>
<p>2） &lt;&lt; 和 &gt;&gt;只能通过全局函数配合友元函数进行重载 </p>
<p>3） 不要重载 &amp;&amp; 和 || 操作符，因为无法实现短路规则</p>
<p><img src="https://pic.imgdb.cn/item/630ed16e16f2c2beb17a9a84.jpg"></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象-友元</title>
    <url>/2022/08/31/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%8F%8B%E5%85%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="面向对象–友元"><a href="#面向对象–友元" class="headerlink" title="面向对象–友元"></a>面向对象–友元</h1><p>类的主要特点之一是数据隐藏，即类的私有成员无法在类的外部(作用域之外)访问。<span id="more"></span></p>
<p>但是，有时候需要在类的外部访问类的私有成员，怎么办？解决方法是使用友元函数，友元函数是一种特殊的函数，c++允许这个函数访问私有成员。这一点从现实生活中也可以很好的理解：比如你的家，有客厅，有你的卧室，那么你的客厅是Public的，所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去，但是呢，你也可以允许你的闺蜜好基友进去。程序员可以把一个全局函数、某个类中的成员函数、甚至整个类声明为友元。</p>
<h2 id="1、语法"><a href="#1、语法" class="headerlink" title="1、语法"></a>1、语法</h2><ul>
<li><p>friend关键字只出现在声明处</p>
</li>
<li><p>其他类、类成员函数、全局函数都可声明为友元</p>
</li>
<li><p>友元函数不是类的成员，不带this指针</p>
</li>
<li><p>友元函数可访问对象任意成员属性，包括私有属性</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="comment">//友元类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFriend</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//友元成员函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">LookAtBedRoom</span><span class="params">(Building&amp; building)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PlayInBedRoom</span><span class="params">(Building&amp; building)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>&#123;</span><br><span class="line">	<span class="comment">//全局函数做友元函数</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">CleanBedRoom</span><span class="params">(Building&amp; building)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">//成员函数做友元函数</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">MyFriend::LookAtBedRoom</span><span class="params">(Building&amp; building)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">MyFriend::PlayInBedRoom</span><span class="params">(Building&amp; building)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span>	</span></span><br><span class="line">	<span class="comment">//友元类</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">MyFriend</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string mSittingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string mBedroom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFriend::LookAtBedRoom</span><span class="params">(Building&amp; building)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;我的朋友参观&quot;</span> &lt;&lt; building.mBedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFriend::PlayInBedRoom</span><span class="params">(Building&amp; building)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;我的朋友玩耍在&quot;</span> &lt;&lt; building.mBedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//友元全局函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CleanBedRoom</span><span class="params">(Building&amp; building)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;友元全局函数访问&quot;</span> &lt;&lt; building.mBedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;mSittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;mBedroom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	Building building;</span><br><span class="line">	MyFriend myfriend;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CleanBedRoom</span>(building);</span><br><span class="line">	myfriend.<span class="built_in">LookAtBedRoom</span>(building);</span><br><span class="line">	myfriend.<span class="built_in">PlayInBedRoom</span>(building);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1．友元关系不能被继承。</p>
<p>2．友元关系是单向的，类A是类B的朋友，但类B不一定是类A的朋友。</p>
<p>3． 友元关系不具有传递性。类B是类A的朋友，类C是类B的朋友，但类C不一定是类A的朋友。</p>
<h2 id="2、友元应用"><a href="#2、友元应用" class="headerlink" title="2、友元应用"></a>2、友元应用</h2><p>编写电视机类，电视机有开机和关机状态，有音量，有频道，提供音量操作的方法，频道操作的方法。由于电视机只能逐一调整频道，不能指定频道，增加遥控类，遥控类除了拥有电视机已有的功能，再增加根据输入调台功能。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Remote</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Television</span>&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Remote</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">enum</span>&#123; On,Off &#125;; <span class="comment">//电视状态</span></span><br><span class="line">	<span class="keyword">enum</span>&#123; minVol,maxVol = <span class="number">100</span> &#125;; <span class="comment">//音量从0到100</span></span><br><span class="line">	<span class="keyword">enum</span>&#123; minChannel = <span class="number">1</span>,maxChannel = <span class="number">255</span> &#125;; <span class="comment">//频道从1到255</span></span><br><span class="line">	<span class="built_in">Television</span>()&#123;</span><br><span class="line">		mState = Off;</span><br><span class="line">		mVolume = minVol;</span><br><span class="line">		mChannel = minChannel;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打开电视机</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnOrOff</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mState = (<span class="keyword">this</span>-&gt;mState == On ? Off : On);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//调高音量</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">VolumeUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mVolume &gt;= maxVol)&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mVolume++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//调低音量</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">VolumeDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mVolume &lt;= minVol)&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mVolume--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//更换电视频道</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ChannelUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mChannel &gt;= maxChannel)&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mChannel++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ChannelDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mChannel &lt;= minChannel)&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mChannel--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//展示当前电视状态信息</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowTeleState</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;开机状态:&quot;</span> &lt;&lt; (mState == On ? <span class="string">&quot;已开机&quot;</span> : <span class="string">&quot;已关机&quot;</span>) &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (mState == On)&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;当前音量:&quot;</span> &lt;&lt; mVolume &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;当前频道:&quot;</span> &lt;&lt; mChannel &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mState; <span class="comment">//电视状态，开机，还是关机</span></span><br><span class="line">	<span class="type">int</span> mVolume; <span class="comment">//电视机音量</span></span><br><span class="line">	<span class="type">int</span> mChannel; <span class="comment">//电视频道</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电视机调台只能一个一个的调，遥控可以指定频道</span></span><br><span class="line"><span class="comment">//电视遥控器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Remote</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Remote</span>(Television* television)&#123;</span><br><span class="line">		pTelevision = television;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnOrOff</span><span class="params">()</span></span>&#123;</span><br><span class="line">		pTelevision-&gt;<span class="built_in">OnOrOff</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//调高音量</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">VolumeUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">		pTelevision-&gt;<span class="built_in">VolumeUp</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//调低音量</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">VolumeDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">		pTelevision-&gt;<span class="built_in">VolumeDown</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//更换电视频道</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ChannelUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">		pTelevision-&gt;<span class="built_in">ChannelUp</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ChannelDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">		pTelevision-&gt;<span class="built_in">ChannelDown</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置频道 遥控新增功能</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">SetChannel</span><span class="params">(<span class="type">int</span> channel)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (channel &lt; Television::minChannel || channel &gt; Television::maxChannel)&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pTelevision-&gt;mChannel = channel;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示电视当前信息</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowTeleState</span><span class="params">()</span></span>&#123;</span><br><span class="line">		pTelevision-&gt;<span class="built_in">ShowTeleState</span>();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Television* pTelevision;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//直接操作电视</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	Television television;</span><br><span class="line">	television.<span class="built_in">ShowTeleState</span>();</span><br><span class="line">	television.<span class="built_in">OnOrOff</span>(); <span class="comment">//开机</span></span><br><span class="line">	television.<span class="built_in">VolumeUp</span>(); <span class="comment">//增加音量+1</span></span><br><span class="line">	television.<span class="built_in">VolumeUp</span>(); <span class="comment">//增加音量+1</span></span><br><span class="line">	television.<span class="built_in">VolumeUp</span>(); <span class="comment">//增加音量+1</span></span><br><span class="line">	television.<span class="built_in">VolumeUp</span>(); <span class="comment">//增加音量+1</span></span><br><span class="line">	television.<span class="built_in">ChannelUp</span>(); <span class="comment">//频道+1</span></span><br><span class="line">	television.<span class="built_in">ChannelUp</span>(); <span class="comment">//频道+1</span></span><br><span class="line">	television.<span class="built_in">ShowTeleState</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过遥控操作电视</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//创建电视</span></span><br><span class="line">	Television television;</span><br><span class="line">	<span class="comment">//创建遥控</span></span><br><span class="line">	<span class="function">Remote <span class="title">remote</span><span class="params">(&amp;television)</span></span>;</span><br><span class="line">	remote.<span class="built_in">OnOrOff</span>();</span><br><span class="line">	remote.<span class="built_in">ChannelUp</span>();<span class="comment">//频道+1</span></span><br><span class="line">	remote.<span class="built_in">ChannelUp</span>();<span class="comment">//频道+1</span></span><br><span class="line">	remote.<span class="built_in">ChannelUp</span>();<span class="comment">//频道+1</span></span><br><span class="line">	remote.<span class="built_in">VolumeUp</span>();<span class="comment">//音量+1</span></span><br><span class="line">	remote.<span class="built_in">VolumeUp</span>();<span class="comment">//音量+1</span></span><br><span class="line">	remote.<span class="built_in">VolumeUp</span>();<span class="comment">//音量+1</span></span><br><span class="line">	remote.<span class="built_in">VolumeUp</span>();<span class="comment">//音量+1</span></span><br><span class="line">	remote.<span class="built_in">ShowTeleState</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象机制</title>
    <url>/2022/08/31/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="面向对象–C-面向对象机制"><a href="#面向对象–C-面向对象机制" class="headerlink" title="面向对象–C++面向对象机制"></a>面向对象–C++面向对象机制</h1><h2 id="1、c-对象模型"><a href="#1、c-对象模型" class="headerlink" title="1、c++对象模型"></a>1、c++对象模型</h2><p>C++对象模型可以概括为以下2部分：</p>
<ul>
<li><p>语言中直接支持面向对象程序设计的部分，主要涉及如构造函数、析构函数、虚函数、继承（单继承、多继承、虚继承）、多态等等。</p>
</li>
<li><p>对于各种支持的底层实现机制。<span id="more"></span></p>
</li>
</ul>
<p>在c++中，通过抽象数据类型（abstract data type，ADT），在类中定义数据和函数，来实现数据和函数直接的绑定。概括来说，在C++类中有两种成员数据：static、nonstatic；三种成员函数：static、nonstatic、virtual。</p>
<p><img src="https://pic.imgdb.cn/item/630ece9216f2c2beb1787656.jpg"></p>
<h2 id="2、c-中类的成员数据和成员函数的存储机制"><a href="#2、c-中类的成员数据和成员函数的存储机制" class="headerlink" title="2、c++中类的成员数据和成员函数的存储机制"></a>2、c++中类的成员数据和成员函数的存储机制</h2><p>c++实现了“封装”，那么数据(成员属性)和操作(成员函数)是什么样的呢？</p>
<ul>
<li><p>“数据”和“处理数据的操作(函数)”是分开存储的。</p>
</li>
<li><p>c++中的非静态数据成员直接内含在类对象中，就像c struct一样。</p>
</li>
<li><p>成员函数(member function)虽然内含在class声明之内，却不出现在对象中。</p>
</li>
<li><p>每一个非内联成员函数(non-inline member function)只会诞生一份函数实例.</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass01</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass02</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> sB;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass03</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printMyClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> sB;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass04</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printMyClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ShowMyClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;hello world！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> sB;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	MyClass01 mclass01;</span><br><span class="line">	MyClass02 mclass02;</span><br><span class="line">	MyClass03 mclass03;</span><br><span class="line">	MyClass04 mclass04;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;MyClass01:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(mclass01) &lt;&lt; endl; <span class="comment">//4</span></span><br><span class="line">	<span class="comment">//静态数据成员并不保存在类对象中</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;MyClass02:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(mclass02) &lt;&lt; endl; <span class="comment">//4</span></span><br><span class="line">	<span class="comment">//非静态成员函数不保存在类对象中</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;MyClass03:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(mclass03) &lt;&lt; endl; <span class="comment">//4</span></span><br><span class="line">	<span class="comment">//静态成员函数也不保存在类对象中</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;MyClass04:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(mclass04) &lt;&lt; endl; <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> i;  <span class="comment">//4</span></span><br><span class="line">	<span class="type">int</span> j; <span class="comment">//4</span></span><br><span class="line">	<span class="type">int</span> k;  <span class="comment">//4</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;; <span class="comment">//12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> i; </span><br><span class="line">	<span class="type">int</span> j; </span><br><span class="line">	<span class="type">int</span> k; </span><br><span class="line">	</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m; <span class="comment">//4</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getK</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> k; &#125; <span class="comment">//4</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setK</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; k = val; &#125;  <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">&#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m;</span><br><span class="line">&#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c1:%d \n&quot;</span>, <span class="built_in">sizeof</span>(C1));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c2:%d \n&quot;</span>, <span class="built_in">sizeof</span>(C2));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;s1:%d \n&quot;</span>, <span class="built_in">sizeof</span>(S1));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;s2:%d \n&quot;</span>, <span class="built_in">sizeof</span>(S2));</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的案例，可以得出：</p>
<p>C++类对象中的成员变量和成员函数是分开存储的</p>
<ul>
<li><p>成员变量：</p>
<ul>
<li>普通成员变量：存储于对象中，与struct变量有相同的内存布局和字节对齐方式</li>
<li>静态成员变量：存储于全局数据区中</li>
</ul>
</li>
<li><p>成员函数：存储于代码段中。</p>
</li>
</ul>
<p>问题出来了：很多对象共用一块代码？代码是如何区分具体对象的呢？</p>
<p>换句话说：int getK() const { return k; }，代码是如何区分，具体obj1、obj2、obj3对象的k值？</p>
<h2 id="3、this指针"><a href="#3、this指针" class="headerlink" title="3、this指针"></a>3、this指针</h2><p>c++的数据和操作是分开存储，并且每一个非内联成员函数(non-inline member function)只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p><img src="https://pic.imgdb.cn/item/630ecec516f2c2beb178a4da.jpg"></p>
<p>c++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象。c++规定，this指针是隐含在对象成员函数内的一种指针。当一个对象被创建后，它的每一个成员函数都含有一个系统自动生成的隐含指针this，用以保存这个对象的地址，也就是说虽然我们没有写上this指针，编译器在编译的时候也是会加上的。因此this也称为“指向本对象的指针”，this指针并不是对象的一部分，不会影响sizeof(对象)的结果。		this指针是C++实现封装的一种机制，它将对象和该对象调用的成员函数连接在一起，在外部看来，每一个对象都拥有自己的函数成员。一般情况下，并不写this，而是让系统进行默认设置。</p>
<h3 id="3-1、this指针的使用"><a href="#3-1、this指针的使用" class="headerlink" title="3.1、this指针的使用"></a>3.1、this指针的使用</h3><ul>
<li><p>当形参和成员变量同名时，可用this指针来区分。</p>
</li>
<li><p>在类的非静态成员函数中返回对象本身，可使用return *this。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//1. 当形参名和成员变量名一样时，this指针可用来区分</span></span><br><span class="line">	<span class="built_in">Person</span>(string name,<span class="type">int</span> age)&#123;</span><br><span class="line">		<span class="comment">//name = name;</span></span><br><span class="line">		<span class="comment">//age = age; //输出错误</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2. 返回对象本身的引用</span></span><br><span class="line">	<span class="comment">//重载赋值操作符</span></span><br><span class="line">	<span class="comment">//其实也是两个参数，其中隐藏了一个this指针</span></span><br><span class="line">	<span class="function">Person <span class="title">PersonPlusPerson</span><span class="params">(Person&amp; person)</span></span>&#123;</span><br><span class="line">		string newname = <span class="keyword">this</span>-&gt;name + person.name;</span><br><span class="line">		<span class="type">int</span> newage = <span class="keyword">this</span>-&gt;age + person.age;</span><br><span class="line">		<span class="function">Person <span class="title">newperson</span><span class="params">(newname, newage)</span></span>;</span><br><span class="line">		<span class="keyword">return</span> newperson;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 成员函数和全局函数(Perosn对象相加)</span></span><br><span class="line"><span class="function">Person <span class="title">PersonPlusPerson</span><span class="params">(Person&amp; p1,Person&amp; p2)</span></span>&#123;</span><br><span class="line">	string newname = p1.name + p2.name;</span><br><span class="line">	<span class="type">int</span> newage = p1.age + p2.age;</span><br><span class="line">	<span class="function">Person <span class="title">newperson</span><span class="params">(newname,newage)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> newperson;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">person</span><span class="params">(<span class="string">&quot;John&quot;</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line">	person.<span class="built_in">ShowPerson</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;---------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="function">Person <span class="title">person1</span><span class="params">(<span class="string">&quot;John&quot;</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">person2</span><span class="params">(<span class="string">&quot;001&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//1.全局函数实现两个对象相加</span></span><br><span class="line">	Person person3 = <span class="built_in">PersonPlusPerson</span>(person1, person2);</span><br><span class="line">	person1.<span class="built_in">ShowPerson</span>();</span><br><span class="line">	person2.<span class="built_in">ShowPerson</span>();</span><br><span class="line">	person3.<span class="built_in">ShowPerson</span>();</span><br><span class="line">	<span class="comment">//2. 成员函数实现两个对象相加</span></span><br><span class="line">	Person person4 = person1.<span class="built_in">PersonPlusPerson</span>(person2);</span><br><span class="line">	person4.<span class="built_in">ShowPerson</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2、const修饰成员函数"><a href="#3-2、const修饰成员函数" class="headerlink" title="3.2、const修饰成员函数"></a>3.2、const修饰成员函数</h3><p>const修饰成员函数时，const修饰this指针指向的内存区域，成员函数体内不可以修改本类中的任何普通成员变量，当成员变量类型符前用mutable修饰时例外。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//const修饰成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mID = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//在函数括号后面加上const,修饰成员变量不可修改,除了mutable变量</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">sonmeOperate</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="comment">//this-&gt;mAge = 200; //mAge不可修改</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;mID = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;ID:&quot;</span> &lt;&lt; mID &lt;&lt; <span class="string">&quot; mAge:&quot;</span> &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> mID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	Person person;</span><br><span class="line">	person.<span class="built_in">sonmeOperate</span>();</span><br><span class="line">	person.<span class="built_in">ShowPerson</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3、const修饰对象（常对象）"><a href="#3-3、const修饰对象（常对象）" class="headerlink" title="3.3、const修饰对象（常对象）"></a>3.3、const修饰对象（常对象）</h3><ul>
<li><p>常对象只能调用const的成员函数</p>
</li>
<li><p>常对象可访问 const 或非 const 数据成员，不能修改，除非成员用mutable修饰</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mAge = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;mID = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ChangePerson</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		mAge = <span class="number">100</span>;</span><br><span class="line">		mID = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mAge = <span class="number">1000</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;ID:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mID &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> mID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;	</span><br><span class="line">	<span class="type">const</span> Person person;</span><br><span class="line">	<span class="comment">//1. 可访问数据成员</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Age:&quot;</span> &lt;&lt; person.mAge &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//person.mAge = 300; //不可修改</span></span><br><span class="line">	person.mID = <span class="number">1001</span>; <span class="comment">//但是可以修改mutable修饰的成员变量</span></span><br><span class="line">	<span class="comment">//2. 只能访问const修饰的函数</span></span><br><span class="line">	<span class="comment">//person.ShowPerson();</span></span><br><span class="line">	person.<span class="built_in">ChangePerson</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象-对象的构造和析构深入</title>
    <url>/2022/08/31/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E6%B7%B1%E5%85%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="面向对象–对象的构造和析构深入"><a href="#面向对象–对象的构造和析构深入" class="headerlink" title="面向对象–对象的构造和析构深入"></a>面向对象–对象的构造和析构深入</h1><h2 id="1、浅拷贝和深拷贝"><a href="#1、浅拷贝和深拷贝" class="headerlink" title="1、浅拷贝和深拷贝"></a>1、浅拷贝和深拷贝</h2><h3 id="1-1、浅拷贝"><a href="#1-1、浅拷贝" class="headerlink" title="1.1、浅拷贝"></a>1.1、浅拷贝</h3><p>同一类型的对象之间可以赋值，使得两个对象的成员变量的值相同，两个对象仍然是独立的两个对象，这种情况被称为浅拷贝。<span id="more"></span></p>
<p>一般情况下，浅拷贝没有任何副作用，但是当类中有指针，并且指针指向动态分配的内存空间，析构函数做了动态内存释放的处理，会导致内存问题。</p>
<p><img src="https://pic.imgdb.cn/item/630ecb9816f2c2beb176d3b4.jpg"></p>
<h3 id="1-2、深拷贝"><a href="#1-2、深拷贝" class="headerlink" title="1.2、深拷贝"></a>1.2、深拷贝</h3><p>当类中有指针，并且此指针有动态分配空间，析构函数做了释放处理，往往需要自定义拷贝构造函数，自行给指针动态分配空间，深拷贝。</p>
<p><img src="https://pic.imgdb.cn/item/630ecba616f2c2beb176dbec.jpg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">char</span>* name,<span class="type">int</span> age)&#123;</span><br><span class="line">		pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(name) + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(pName,name);</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//增加拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; person)&#123;</span><br><span class="line">		pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(person.pName) + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(pName, person.pName);</span><br><span class="line">		mAge = person.mAge;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span> (pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">free</span>(pName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* pName;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Edward&quot;</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">	<span class="comment">//用对象p1初始化对象p2,调用c++提供的默认拷贝构造函数</span></span><br><span class="line">	Person p2 = p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、多个对象的构造和析构"><a href="#2、多个对象的构造和析构" class="headerlink" title="2、多个对象的构造和析构"></a>2、多个对象的构造和析构</h2><h3 id="2-1、初始化列表"><a href="#2-1、初始化列表" class="headerlink" title="2.1、初始化列表"></a>2.1、初始化列表</h3><p>构造函数和其他函数不同，除了有名字，参数列表，函数体之外还有初始化列表。</p>
<p>初始化列表简单使用:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">//传统方式初始化</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)&#123;</span><br><span class="line">		mA = a;</span><br><span class="line">		mB = b;</span><br><span class="line">		mC = c;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">//初始化列表方式初始化</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c):<span class="built_in">mA</span>(a),<span class="built_in">mB</span>(b),<span class="built_in">mC</span>(c)&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; mA &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; mB &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; mC &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="type">int</span> mB;</span><br><span class="line">	<span class="type">int</span> mC;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对象初始化列表出现原因</p>
<p>1）必须这样做：</p>
<p>如果有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，如果没有初始化列表，那么他将无法完成第一步，就会报错。</p>
<p>2）类成员中若有const修饰，必须在对象初始化的时候，给const int m 赋值</p>
<p>当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，</p>
<p>因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。</p>
<p>注意：初始化成员列表(参数列表)只能在构造函数使用。成员变量的初始化顺序与声明的顺序相关，与在初始化列表中的顺序无关，初始化列表先于构造函数的函数体执行。</p>
<h3 id="2-2、类对象作为成员"><a href="#2-2、类对象作为成员" class="headerlink" title="2.2、类对象作为成员"></a>2.2、类对象作为成员</h3><p>在类中定义的数据成员一般都是基本的数据类型。但是类中的成员也可以是对象，叫做对象成员。</p>
<p>C++中对对象的初始化是非常重要的操作，当创建一个对象的时候，c++编译器必须确保调用了所有子对象的构造函数。如果所有的子对象有默认构造函数，编译器可以自动调用他们。但是如果子对象没有默认的构造函数，或者想指定调用某个构造函数怎么办？</p>
<p>那么是否可以在类的构造函数直接调用子类的属性完成初始化呢？但是如果子类的成员属性是私有的，是没有办法访问并完成初始化的。</p>
<p>解决办法非常简单：对于子类调用构造函数，c++为此提供了专门的语法，即构造函数初始化列表。</p>
<p>当调用构造函数时，首先按各对象成员在类定义中的顺序（和参数列表的顺序无关）依次调用它们的构造函数，对这些对象初始化，最后再调用本身的函数体。也就是说，先调用对象成员的构造函数，再调用本身的构造函数。</p>
<p>析构函数和构造函数调用顺序相反，先构造，后析构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//汽车类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Car</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Car 默认构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mName = <span class="string">&quot;大众汽车&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Car</span>(string name)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Car 带参数构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mName = name;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Car</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Car 析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string mName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拖拉机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tractor</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Tractor</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Tractor 默认构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mName = <span class="string">&quot;爬土坡专用拖拉机&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Tractor</span>(string name)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Tractor 带参数构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mName = name;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Tractor</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Tractor 析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string mName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">	<span class="comment">//类mCar不存在合适的构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(string name)&#123;</span><br><span class="line">		mName = name;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="comment">//初始化列表可以指定调用构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(string carName, string tracName, string name) : <span class="built_in">mTractor</span>(tracName), <span class="built_in">mCar</span>(carName), <span class="built_in">mName</span>(name)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person 构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GoWorkByCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; mName &lt;&lt; <span class="string">&quot;开着&quot;</span> &lt;&lt; mCar.mName &lt;&lt; <span class="string">&quot;去上班!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">GoWorkByTractor</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; mName &lt;&lt; <span class="string">&quot;开着&quot;</span> &lt;&lt; mTractor.mName &lt;&lt; <span class="string">&quot;去上班!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person 析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string mName;</span><br><span class="line">	Car mCar;</span><br><span class="line">	Tractor mTractor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//Person person(&quot;宝马&quot;, &quot;东风拖拉机&quot;, &quot;赵四&quot;);</span></span><br><span class="line">	<span class="function">Person <span class="title">person</span><span class="params">(<span class="string">&quot;刘能&quot;</span>)</span></span>;</span><br><span class="line">	person.<span class="built_in">GoWorkByCar</span>();</span><br><span class="line">	person.<span class="built_in">GoWorkByTractor</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、explicit关键字"><a href="#3、explicit关键字" class="headerlink" title="3、explicit关键字"></a>3、explicit关键字</h2><p>c++提供了关键字explicit，禁止通过构造函数进行的隐式转换。声明为explicit的构造函数不能在隐式转换中使用。</p>
<ul>
<li><p>explicit用于修饰构造函数,防止隐式转化。</p>
</li>
<li><p>是针对单参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造)而言。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">MyString</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;MyString(int n)!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* str)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;MyString(const char* str)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//给字符串赋值？还是初始化？</span></span><br><span class="line">	<span class="comment">//MyString str1 = 1; </span></span><br><span class="line">	<span class="function">MyString <span class="title">str2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//寓意非常明确，给字符串赋值</span></span><br><span class="line">	MyString str3 = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">	<span class="function">MyString <span class="title">str4</span><span class="params">(<span class="string">&quot;abcd&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、动态对象创建"><a href="#4、动态对象创建" class="headerlink" title="4、动态对象创建"></a>4、动态对象创建</h2><p>在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代malloc和free函数。</p>
<p>注意： new和delete是运算符，不是函数，因此执行效率高</p>
<h3 id="4-1、C动态分配内存方法"><a href="#4-1、C动态分配内存方法" class="headerlink" title="4.1、C动态分配内存方法"></a>4.1、C动态分配内存方法</h3><p>为了在运行时动态分配内存，c在他的标准库中提供了一些函数,malloc以及它的变种calloc和realloc,释放内存的free,这些函数是有效的、但是原始的，需要程序员理解和小心使用。为了使用c的动态内存分配函数在堆上创建一个类的实例，必须这样做:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		mAge = <span class="number">20</span>;</span><br><span class="line">		pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">&quot;john&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(pName, <span class="string">&quot;john&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		mAge = <span class="number">20</span>;</span><br><span class="line">		pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">&quot;john&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(pName, <span class="string">&quot;john&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Clean</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">free</span>(pName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">	<span class="type">char</span>* pName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//分配内存</span></span><br><span class="line">	Person* person = (Person*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Person));</span><br><span class="line">	<span class="keyword">if</span>(person == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//调用初始化函数</span></span><br><span class="line">	person-&gt;<span class="built_in">Init</span>();</span><br><span class="line">	<span class="comment">//清理对象</span></span><br><span class="line">	person-&gt;<span class="built_in">Clean</span>();</span><br><span class="line">	<span class="comment">//释放person对象</span></span><br><span class="line">	<span class="built_in">free</span>(person);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码，注意：</p>
<ol>
<li><p>程序员必须确定对象的长度。</p>
</li>
<li><p>malloc返回一个 void* 指针，C++不允许将 void* 赋值给其他任何指针，必须强转转换。</p>
</li>
<li><p>malloc可能申请内存失败，所以必须判断返回值来确保内存分配成功。</p>
</li>
</ol>
<p>用户在使用对象之前必须记住对他初始化，构造函数不能显示调用初始化(构造函数是由编译器调用)，用户有可能忘记调用初始化函数。</p>
<p>C的动态内存分配函数太复杂，容易令人混淆，是不可接受的C++中推荐使用运算符new 和 delete。</p>
<h3 id="4-2、new-和-delete"><a href="#4-2、new-和-delete" class="headerlink" title="4.2、new 和 delete"></a>4.2、new 和 delete</h3><p>C++中解决动态内存分配的方案是把创建一个对象所需要的操作都结合在一个称为new的运算符里。当用new创建一个对象时，它就在堆里为对象分配内存并调用构造函数完成初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Person* person = <span class="keyword">new</span> Person;</span><br><span class="line">相当于:</span><br><span class="line">Person* person = (Person*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Person));</span><br><span class="line">	<span class="keyword">if</span>(person == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">person-&gt;<span class="built_in">Init</span>();</span><br></pre></td></tr></table></figure>

<p>new操作符能确定在调用构造函数初始化之前内存分配是成功的，所有不用显式确定调用是否成功。在堆里创建对象的过程变得简单了，只需要一个简单的表达式，它带有内置的长度计算、类型转换和安全检查。这样在堆创建一个对象和在栈里创建对象一样简单。</p>
<p>new表达式的反面是delete表达式。delete表达式先调用析构函数，然后释放内存。正如new表达式返回一个指向对象的指针一样，delete需要一个对象的地址。delete只适用于由new创建的对象。如果使用一个由malloc或者calloc或者realloc创建的对象使用delete,这个行为是未定义的。因为大多数new和delete的实现机制都使用了malloc和free,所以很可能没有调用析构函数就释放了内存。如果正在删除的对象的指针是NULL,将不发生任何事，因此建议在删除指针后，立即把指针赋值为NULL，以免对它删除两次，对一些对象删除两次可能会产生某些问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">&quot;undefined&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(pName, <span class="string">&quot;undefined&quot;</span>);</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">char</span>* name, <span class="type">int</span> age)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(name) + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(pName, name);</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; pName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">delete</span> pName;</span><br><span class="line">			pName = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span>* pName;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person* person1 = <span class="keyword">new</span> Person;</span><br><span class="line">	Person* person2 = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;John&quot;</span>,<span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">	person1-&gt;<span class="built_in">ShowPerson</span>();</span><br><span class="line">	person2-&gt;<span class="built_in">ShowPerson</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> person1;</span><br><span class="line">	<span class="keyword">delete</span> person2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new和delete运算符使用的一般格式为：</p>
<p><img src="https://pic.imgdb.cn/item/630ecc0016f2c2beb1770912.jpg"></p>
<p>用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。</p>
<p>new运算符的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">//开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>);  <span class="comment">//开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址</span></span><br><span class="line"><span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];  <span class="comment">//开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址</span></span><br><span class="line"><span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>][<span class="number">4</span>];  <span class="comment">//开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址</span></span><br><span class="line"><span class="type">float</span> *p=<span class="keyword">new</span> <span class="built_in">float</span> (<span class="number">3.14159</span>);  <span class="comment">//开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/630ecc1916f2c2beb17713f9.jpg"></p>
<p>使用new和delete在堆上创建数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建字符数组</span></span><br><span class="line"><span class="type">char</span>* pStr = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//创建整型数组</span></span><br><span class="line"><span class="type">int</span>* pArr1 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100</span>]; </span><br><span class="line"><span class="comment">//创建整型数组并初始化</span></span><br><span class="line"><span class="type">int</span>* pArr2 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放数组内存</span></span><br><span class="line"><span class="keyword">delete</span>[] pStr;</span><br><span class="line"><span class="keyword">delete</span>[] pArr1;</span><br><span class="line"><span class="keyword">delete</span>[] pArr2;</span><br></pre></td></tr></table></figure>

<p>当创建一个对象数组的时候，必须对数组中的每一个对象调用构造函数，除了在栈上可以聚合初始化，必须提供一个默认的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(<span class="string">&quot;undefined&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcpy</span>(pName, <span class="string">&quot;undefined&quot;</span>);</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">char</span>* name, <span class="type">int</span> age)&#123;</span><br><span class="line">		pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(name));</span><br><span class="line">		<span class="built_in">strcpy</span>(pName, name);</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span> (pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">delete</span> pName;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span>* pName;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//栈聚合初始化</span></span><br><span class="line">	Person person[] = &#123; <span class="built_in">Person</span>(<span class="string">&quot;john&quot;</span>, <span class="number">20</span>), <span class="built_in">Person</span>(<span class="string">&quot;Smith&quot;</span>, <span class="number">22</span>) &#125;;</span><br><span class="line">	cout &lt;&lt; person[<span class="number">1</span>].pName &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//创建堆上对象数组必须提供构造函数</span></span><br><span class="line">	Person* workers = <span class="keyword">new</span> Person[<span class="number">20</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果对一个void*指针执行delete操作，这将可能成为一个程序错误，除非指针指向的内容是非常简单的，因为它将不执行析构函数.以下代码未调用析构函数，导致可用内存减少。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">char</span>* name, <span class="type">int</span> age)&#123;</span><br><span class="line">		pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(name));</span><br><span class="line">		<span class="built_in">strcpy</span>(pName,name);</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		<span class="keyword">if</span> (pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">delete</span> pName;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span>* pName;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">void</span>* person = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">&quot;john&quot;</span>,<span class="number">20</span>);</span><br><span class="line">	<span class="keyword">delete</span> person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3、动态创建对象小结"><a href="#4-3、动态创建对象小结" class="headerlink" title="4.3、动态创建对象小结"></a>4.3、动态创建对象小结</h3><p>1）问题：malloc、free和new、delete可以混搭使用吗？也就是说malloc分配的内存，可以调用delete吗？通过new创建的对象，可以调用free来释放吗？不可以</p>
<ul>
<li><p>malloc free函数，是c关键字</p>
</li>
<li><p>new delete 操作符，是c++的关键字</p>
</li>
<li><p>new 在堆上分配内存 （分配基础类型 、分配数组类型、分配对象） delete 释放内存</p>
</li>
<li><p>malloc不会调用类的构造函数，free不会调用类的析构函数</p>
</li>
</ul>
<p>2）使用new和delete采用相同形式</p>
<p>​	以下代码有没有什么问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Person* person = <span class="keyword">new</span> Person[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> person;</span><br></pre></td></tr></table></figure>

<p>使用了new也搭配使用了delete，问题在于Person有10个对象，那么其他9个对象可能没有调用析构函数，也就是说其他9个对象可能删除不完全，因为它们的析构函数没有被调用。</p>
<p>现在清楚使用new的时候发生了两件事： 一、分配内存；二、调用构造函数，那么调用delete的时候也有两件事：一、析构函数；二、释放内存。</p>
<p>那么刚才那段代码最大的问题在于：person指针指向的内存中到底有多少个对象，因为这个决定应该有多少个析构函数应该被调用。换句话说，person指针指向的是一个单一的对象还是一个数组对象，由于单一对象和数组对象的内存布局是不同的。更明确的说，数组所用的内存通常还包括“数组大小记录”，使得delete的时候知道应该调用几次析构函数。单一对象的话就没有这个记录。单一对象和数组对象的内存布局可理解为下图:</p>
<p><img src="https://pic.imgdb.cn/item/630ecc4616f2c2beb1773102.jpg"></p>
<p>本图只是为了说明，编译器不一定如此实现，但是很多编译器是这样做的。</p>
<p>当使用一个delete的时候，必须让delete知道指针指向的内存空间中是否存在一个“数组大小记录”的办法就是告诉它。当使用delete[]，那么delete就知道是一个对象数组，从而清楚应该调用几次析构函数。</p>
<p><em><strong>结论：</strong></em></p>
<p><strong>如果在new表达式中使用[]，必须在相应的delete表达式中也使用[]。如果在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。</strong></p>
<h2 id="5、静态成员"><a href="#5、静态成员" class="headerlink" title="5、静态成员"></a>5、静态成员</h2><p>在类定义中，它的成员（包括成员变量和成员函数），这些成员可以用关键字static声明为静态的，称为静态成员。不管这个类创建了多少个对象，静态成员只有一个拷贝，这个拷贝被所有属于这个类的对象共享。</p>
<h3 id="5-1、静态成员变量"><a href="#5-1、静态成员变量" class="headerlink" title="5.1、静态成员变量"></a>5.1、静态成员变量</h3><p>在一个类中，若将一个成员变量声明为static，这种成员称为静态成员变量。与一般的数据成员不同，无论建立了多少个对象，都只有一个静态数据的拷贝。静态成员变量，属于某个类，所有对象共享。静态变量，是在编译阶段就分配空间，对象还没有创建时，就已经分配空间。</p>
<ul>
<li><p>关键字static可以用于说明一个类的成员，静态成员提供了一个同类对象的共享机制</p>
</li>
<li><p>把一个类的成员说明为 static时，这个类无论有多少个对象被创建，这些对象共享这个static成员</p>
</li>
<li><p>静态成员局部于类，它不是对象成员</p>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/630ecc7d16f2c2beb17750dd.jpg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//类的静态成员属性</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> sNum;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> sOther;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外初始化，初始化时不加static</span></span><br><span class="line"><span class="type">int</span> Person::sNum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> Person::sOther = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1. 通过类名直接访问</span></span><br><span class="line">	Person::sNum = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Person::sNum:&quot;</span> &lt;&lt; Person::sNum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2. 通过对象访问</span></span><br><span class="line">	Person p1, p2;</span><br><span class="line">	p1.sNum = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.sNum:&quot;</span> &lt;&lt; p1.sNum &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.sNum:&quot;</span> &lt;&lt; p2.sNum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3. 静态成员也有访问权限，类外不能访问私有成员</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;Person::sOther:&quot; &lt;&lt; Person::sOther &lt;&lt; endl;</span></span><br><span class="line">	Person p3;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;p3.sOther:&quot; &lt;&lt; p3.sOther &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">counter</span></span><br><span class="line">&#123; <span class="keyword">public</span> :</span><br><span class="line">      <span class="built_in">counter</span> (<span class="type">int</span> a) &#123; mem = a; &#125;</span><br><span class="line">      <span class="type">int</span> mem;		<span class="comment">//公有数据成员</span></span><br><span class="line">      <span class="type">static</span>  <span class="type">int</span>  Smem ;	<span class="comment">//公有静态数据成员</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="type">int</span>  counter :: Smem = <span class="number">1</span> ;	<span class="comment">//初始值为1 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="function">counter <span class="title">c</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> i ;</span><br><span class="line">    <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i ++ )</span><br><span class="line">      &#123; counter::Smem += i ;</span><br><span class="line">         cout &lt;&lt; counter::Smem &lt;&lt; <span class="string">&#x27;\t&#x27;</span> ;  <span class="comment">//访问静态成员变量方法2</span></span><br><span class="line">      &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;c.Smem = &quot;</span>&lt;&lt;c.Smem&lt;&lt;endl; <span class="comment">//访问静态成员变量方法1</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;c.mem = &quot;</span>&lt;&lt;c.mem&lt;&lt;endl;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2、静态成员函数"><a href="#5-2、静态成员函数" class="headerlink" title="5.2、静态成员函数"></a>5.2、静态成员函数</h3><p>在类定义中，前面有static说明的成员函数称为静态成员函数。静态成员函数使用方式和静态变量一样，同样在对象没有创建前，即可通过类名调用。静态成员函数主要为了访问静态变量，但是，不能访问普通成员变量。</p>
<p>静态成员函数的意义，不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封装。</p>
<ul>
<li><p>静态成员函数只能访问静态变量，不能访问普通成员变量</p>
</li>
<li><p>静态成员函数的使用和静态成员变量一样</p>
</li>
<li><p>静态成员函数也有访问权限</p>
</li>
<li><p>普通成员函数可访问静态成员变量、也可以访问非经常成员变量</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//普通成员函数可以访问static和non-static成员属性</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">changeParam1</span><span class="params">(<span class="type">int</span> param)</span></span>&#123;</span><br><span class="line">		mParam = param;</span><br><span class="line">		sNum = param;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//静态成员函数只能访问static成员属性</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">changeParam2</span><span class="params">(<span class="type">int</span> param)</span></span>&#123;</span><br><span class="line">		<span class="comment">//mParam = param; //无法访问</span></span><br><span class="line">		sNum = param;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">changeParam3</span><span class="params">(<span class="type">int</span> param)</span></span>&#123;</span><br><span class="line">		<span class="comment">//mParam = param; //无法访问</span></span><br><span class="line">		sNum = param;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mParam;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> sNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员属性类外初始化</span></span><br><span class="line"><span class="type">int</span> Person::sNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1. 类名直接调用</span></span><br><span class="line">	Person::<span class="built_in">changeParam2</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2. 通过对象调用</span></span><br><span class="line">	Person p;</span><br><span class="line">	p.<span class="built_in">changeParam2</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3. 静态成员函数也有访问权限</span></span><br><span class="line">	<span class="comment">//Person::changeParam3(100); //类外无法访问私有静态成员函数</span></span><br><span class="line">	<span class="comment">//Person p1;</span></span><br><span class="line">	<span class="comment">//p1.changeParam3(200);</span></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3、const静态成员属性"><a href="#5-3、const静态成员属性" class="headerlink" title="5.3、const静态成员属性"></a>5.3、const静态成员属性</h3><p>如果一个类的成员，既要实现共享，又要实现不可改变，那就用 static const 修饰。定义静态const数据成员时，最好在类内部初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//static const int mShare = 10;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">static</span> <span class="type">int</span> mShare = <span class="number">10</span>; <span class="comment">//只读区，不可修改</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; Person::mShare &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//Person::mShare = 20;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象-对象的构造和析构</title>
    <url>/2022/08/31/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="面向对象–对象的构造和析构"><a href="#面向对象–对象的构造和析构" class="headerlink" title="面向对象–对象的构造和析构"></a>面向对象–对象的构造和析构</h1><p>c++中OO思想来源于现实，是对现实事物的抽象模拟，具体来说，当创建对象的时候，这个对象应该有一个初始状态，当对象销毁之前应该销毁自己创建的一些数据。对象的初始化和清理也是两个非常重要的安全问题，一个对象或者变量没有初始时，对其使用后果是未知，同样的使用完一个变量，没有及时清理，也会造成一定的安全问题。c++提供这种问题的解决方案，构造函数和析构函数，这两个函数将会被编译器自动调用，完成对象初始化和对象清理工作。<span id="more"></span></p>
<p>无论你是否喜欢，对象的初始化和清理工作是编译器强制我们要做的事情，即使你不提供初始化操作和清理操作，编译器也会给你增加默认的操作，只是这个默认初始化操作不会做任何事，所以编写类就应该顺便提供初始化函数。</p>
<p>为什么初始化操作是自动调用而不是手动调用？既然是必须操作，那么自动调用会更好，如果靠程序员自觉，那么就会存在遗漏初始化的情况出现。</p>
<h2 id="1、构造函数和析构函数"><a href="#1、构造函数和析构函数" class="headerlink" title="1、构造函数和析构函数"></a>1、构造函数和析构函数</h2><p>构造函数主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</p>
<p>析构函数主要用于对象销毁前系统自动调用，执行一些清理工作。</p>
<p>构造函数语法： 构造函数函数名和类名相同，没有返回值，不能有void，但可以有参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ClassName()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>析构函数语法： 析构函数函数名是在类名前面加”~”组成，没有返回值，不能有void，不能有参数，不能重载。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">~ClassName()&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;构造函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		pName = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="string">&quot;John&quot;</span>));</span><br><span class="line">		<span class="built_in">strcpy</span>(pName, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">		mTall = <span class="number">150</span>;</span><br><span class="line">		mMoney = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">free</span>(pName);</span><br><span class="line">			pName = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">char</span>* pName;</span><br><span class="line">	<span class="type">int</span> mTall;</span><br><span class="line">	<span class="type">int</span> mMoney;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Person person;</span><br><span class="line">	cout &lt;&lt; person.pName &lt;&lt; person.mTall &lt;&lt; person.mMoney &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、构造函数的分类"><a href="#2、构造函数的分类" class="headerlink" title="2、构造函数的分类"></a>2、构造函数的分类</h2><ul>
<li><p>按参数类型：分为无参构造函数和有参构造函数</p>
</li>
<li><p>按类型分类：普通构造函数和拷贝构造函数(复制构造函数)</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;no param constructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;1 param constructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数(复制构造函数) 使用另一个对象初始化本对象</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; person)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;copy constructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = person.mAge;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印年龄</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Age:&quot;</span> &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1. 无参构造调用方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用无参构造函数</span></span><br><span class="line">	Person person1; </span><br><span class="line">	person1.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无参构造函数错误调用方式</span></span><br><span class="line">	<span class="comment">//Person person2();</span></span><br><span class="line">	<span class="comment">//person2.PrintPerson();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 调用有参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第一种 括号法，最常用</span></span><br><span class="line">	<span class="function">Person <span class="title">person01</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">	person01.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	<span class="function">Person <span class="title">person02</span><span class="params">(person01)</span></span>;</span><br><span class="line">	person02.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种 匿名对象(显示调用构造函数)</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="number">200</span>); <span class="comment">//匿名对象，没有名字的对象</span></span><br><span class="line"></span><br><span class="line">	Person person03 = <span class="built_in">Person</span>(<span class="number">300</span>);</span><br><span class="line">	person03.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意: 使用匿名对象初始化判断调用哪一个构造函数，要看匿名对象的参数类型</span></span><br><span class="line">	<span class="function">Person <span class="title">person06</span><span class="params">(Person(<span class="number">400</span>))</span></span>; <span class="comment">//等价于 Person person06 = Person(400);</span></span><br><span class="line">	person06.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种 =号法 隐式转换</span></span><br><span class="line">	Person person04 = <span class="number">100</span>; <span class="comment">//Person person04 =  Person(100)</span></span><br><span class="line">	person04.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用拷贝构造</span></span><br><span class="line">	Person person05 = person04; <span class="comment">//Person person05 =  Person(person04)</span></span><br><span class="line">	person05.<span class="built_in">PrintPerson</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意：假设b为A的实例化对象，A a &#x3D; A(b) 和 A(b)的区别？</p>
<p>当A(b) 有变量来接的时候，那么编译器认为他是一个匿名对象，当没有变量来接的时候，编译器认为A(b) 等价于 A b.</p>
<p>注意：不能调用拷贝构造函数去初始化匿名对象,也就是说以下代码错误的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Teacher</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;默认构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Teacher</span>(<span class="type">const</span> Teacher&amp; teacher)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	Teacher t1;</span><br><span class="line">	<span class="comment">//error C2086:“Teacher t1”: 重定义</span></span><br><span class="line">	<span class="built_in">Teacher</span>(t1);  <span class="comment">//此时等价于 Teacher t1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、拷贝构造函数调用的时机"><a href="#3、拷贝构造函数调用的时机" class="headerlink" title="3、拷贝构造函数调用的时机"></a>3、拷贝构造函数调用的时机</h2><ul>
<li><p>对象以值传递的方式传给函数参数</p>
</li>
<li><p>函数局部对象以值传递的方式从函数返回(vs debug模式下调用一次拷贝构造，qt不调用任何构造)</p>
</li>
<li><p>用一个对象初始化另一个对象</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;no param contructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;param constructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; person)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;copy constructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = person.mAge;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Person</span>()&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;destructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1. 旧对象初始化新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(p)</span></span>;</span><br><span class="line">	Person p2 = <span class="built_in">Person</span>(p);</span><br><span class="line">	Person p3 = p; <span class="comment">// 相当于Person p2 = Person(p);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 传递的参数是普通对象，函数参数也是普通对象，传递将会调用拷贝构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doBussiness</span><span class="params">(Person p)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="built_in">doBussiness</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 函数返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">MyBusiness</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部p:&quot;</span> &lt;&lt; (<span class="type">int</span>*)&amp;p &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//vs release、qt下没有调用拷贝构造函数</span></span><br><span class="line">	<span class="comment">//vs debug下调用一次拷贝构造函数</span></span><br><span class="line">	Person p = <span class="built_in">MyBusiness</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部p:&quot;</span> &lt;&lt; (<span class="type">int</span>*)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器存在一种对返回值的优化技术，RVO(Return Value Optimization)。在vs debug模式下并没有进行这种优化，所以函数MyBusiness中创建p对象，调用了一次构造函数，当编译器发现要返回这个局部的对象时，编译器通过调用拷贝构造生成一个临时Person对象返回，然后调用p的析构函数。</p>
<p>从常理来分析的话，这个匿名对象和这个局部的p对象是相同的两个对象，那么如果能直接返回p对象，就会省去一个拷贝构造和一个析构函数的开销，在程序中一个对象的拷贝也是非常耗时的，如果减少这种拷贝和析构的次数，那么从另一个角度来说，也是编译器对程序执行效率上进行了优化。</p>
<p>所以在这里，编译器偷偷做了一层优化：</p>
<p>当这样去调用: Person p &#x3D; MyBusiness();</p>
<p>编译器偷偷将代码更改为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyBussiness</span><span class="params">(Person&amp; _result)</span></span>&#123;</span><br><span class="line">       _result.X:<span class="built_in">X</span>(); <span class="comment">//调用Person默认拷贝构造函数</span></span><br><span class="line">       <span class="comment">//.....对_result进行处理</span></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Person p; <span class="comment">//这里只分配空间，不初始化</span></span><br><span class="line">   <span class="built_in">MyBussiness</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、默认构造函数"><a href="#4、默认构造函数" class="headerlink" title="4、默认构造函数"></a>4、默认构造函数</h2><p>二个特殊的构造函数</p>
<p>1）默认无参构造函数</p>
<p>当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空</p>
<p>2）默认拷贝构造函数</p>
<p>当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制</p>
<h2 id="5、构造函数调用规则"><a href="#5、构造函数调用规则" class="headerlink" title="5、构造函数调用规则"></a>5、构造函数调用规则</h2><p>默认情况下，c++编译器至少为写的类增加3个函数</p>
<ul>
<li><p>默认构造函数(无参，函数体为空)</p>
</li>
<li><p>默认析构函数(无参，函数体为空)</p>
</li>
<li><p>默认拷贝构造函数，对类中非静态成员属性简单值拷贝</p>
</li>
</ul>
<p>如果用户定义拷贝构造函数，c++不会再提供任何默认构造函数</p>
<p>如果用户定义了普通构造(非拷贝)，c++不在提供默认无参构造，但是会提供默认拷贝构造</p>
<h2 id="6、构造析构小结"><a href="#6、构造析构小结" class="headerlink" title="6、构造析构小结"></a>6、构造析构小结</h2><p>1）构造函数是C++中用于初始化对象状态的特殊函数</p>
<p>2）构造函数在对象创建时自动被调用</p>
<p>3）构造函数和普通成员函数都遵循重载规则</p>
<p>4）拷贝构造函数是对象正确初始化的重要保证</p>
<p>5）必要的时候，必须手工编写拷贝构造函数 </p>
]]></content>
      <categories>
        <category>技术</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面向对象-基础</title>
    <url>/2022/08/31/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="面向对象-基础"><a href="#面向对象-基础" class="headerlink" title="面向对象-基础"></a>面向对象-基础</h1><p>面向对象编程（OOP）是一种特殊的、设计程序的概念性方法， C++通过一些特性改进了C语言，使得应用这种方法更容易。<span id="more"></span></p>
<p>下面是最重要的OOP特性： </p>
<ul>
<li><p>抽象； </p>
</li>
<li><p>封装和数据隐藏； </p>
</li>
<li><p>多态； </p>
</li>
<li><p>继承； </p>
</li>
<li><p>代码的可重用性</p>
</li>
</ul>
<p>为了实现这些特性并将它们组合在一起，C++所做的最重要的改进是提供了类。</p>
<h2 id="1、类和对象"><a href="#1、类和对象" class="headerlink" title="1、类和对象"></a>1、类和对象</h2><p>思考：编程实现求圆的周长和面积</p>
<p>数据描述：	</p>
<p>半径，周长，面积均用实型数表示</p>
<p>数据处理：</p>
<p>输入半径 <strong>r</strong>；</p>
<p>计算周长 &#x3D; 2<em>π</em><strong>r</strong> ；</p>
<p>计算面积 &#x3D; π* <strong>r</strong>2 ；</p>
<p>输出半径，周长，面积；</p>
<p>方法1：用结构化方法编程，求圆的周长和面积</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// count the girth and area of circle</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line">using name <span class="built_in">std</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">   <span class="type">double</span> r, girth, area ; 		</span><br><span class="line">   <span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.1415</span> ;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Please input radius:\n&quot;</span> ; <span class="comment">//操作符重载</span></span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; r ;  <span class="comment">//输入</span></span><br><span class="line">   girth = <span class="number">2</span> * PI * r ; </span><br><span class="line">   area = PI * r * r ;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;radius = &quot;</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;girth = &quot;</span> &lt;&lt; girth &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;area = &quot;</span> &lt;&lt; area &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法2：用面向对象方法编程，求圆的周长和面积</p>
<p><img src="https://pic.imgdb.cn/item/630ec68f16f2c2beb17446c9.jpg"></p>
<p><img src="https://pic.imgdb.cn/item/630ec6a416f2c2beb17451d2.jpg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> name std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;  <span class="type">double</span> radius ; <span class="comment">//成员变量</span></span><br><span class="line">  <span class="keyword">public</span> : <span class="comment">//类的访问控制</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set_Radius</span><span class="params">( <span class="type">double</span> r )</span> </span>&#123; radius = r ; &#125; <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Get_Radius</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span>  radius ; &#125; <span class="comment">//通过成员函数设置成员变量</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Get_Girth</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span>  <span class="number">2</span> * <span class="number">3.14f</span> * radius ; &#125; <span class="comment">//通过成员函数获取成员变量</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Get_Area</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span>  <span class="number">3.14f</span> * radius * radius ; &#125;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   Circle A, B ; <span class="comment">//用类定义对象</span></span><br><span class="line">   A.<span class="built_in">Set_Radius</span>( <span class="number">6.23</span> ) ; <span class="comment">//类的调用</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;A.Radius = &quot;</span> &lt;&lt; A.<span class="built_in">Get_Radius</span>() &lt;&lt; endl ;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;A.Girth = &quot;</span> &lt;&lt; A.<span class="built_in">Get_Girth</span>() &lt;&lt; endl ;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;A.Area = &quot;</span> &lt;&lt; A.<span class="built_in">Get_Area</span>() &lt;&lt; endl ;</span><br><span class="line">   B.<span class="built_in">Set_Radius</span>( <span class="number">10.5</span> ) ;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;B.radius = &quot;</span> &lt;&lt; B.<span class="built_in">Get_Radius</span>() &lt;&lt; endl ;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;B.Girth=&quot;</span> &lt;&lt; B.<span class="built_in">Get_Girth</span>() &lt;&lt; endl ;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;B.Area = &quot;</span> &lt;&lt; B.<span class="built_in">Get_Area</span>() &lt;&lt; endl ; </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用面向对象方法时，首先从用户的角度考虑对象——描述对象、所需的数据以及描述用户与数据交互所需的操作。完成对接口的描述后，需要确定如何实现接口和数据存储。最后，使用新的设计方案创建 出程序。 </p>
<p><strong>总结：建立类、对象、成员变量、成员函数，输入输入流基本概念。</strong></p>
<h3 id="1-1、基本概念"><a href="#1-1、基本概念" class="headerlink" title="1.1、基本概念"></a>1.1、基本概念</h3><p>1）类、对象、成员变量、成员函数</p>
<p>类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操纵数据的方法组合成一个自定义的类型。对象是类的实例。</p>
<p><img src="https://pic.imgdb.cn/item/630ec6e316f2c2beb174718c.jpg"></p>
<p><img src="https://pic.imgdb.cn/item/630ec6f116f2c2beb17477e0.png"></p>
<p>2）面向对象的特征：抽象、封装、继承、多态</p>
<ul>
<li><strong>封装</strong></li>
</ul>
<p>封装就是隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别，将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。</p>
<p>封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员。</p>
<p>面相对象使用程序处理事情时以对象为中心去分析，与面向过程不同，面向过程关心处理的逻辑、流程等问题，而不关心事件主体。而面向对象即面向主体，所以我们在解决问题时应该先进行对象的封装（对象是封装类的实例，比如张三是人，人是一个封装类，张三只是对象中的一个实例、一个对象）。比如我们日常生活中的小兔子、小绵羊都可以封装为一个类。</p>
<p><img src="https://pic.imgdb.cn/item/630ec74b16f2c2beb174a2b2.jpg"></p>
<p>比如兔子的属性有两只耳朵、四只腿、一双眼睛、三瓣嘴等；行为（功能）有跑、跳、吃素等。</p>
<ul>
<li><strong>继承</strong></li>
</ul>
<p>继承是面向对象的基本特征之一，继承机制允许创建分等级层次的类。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。类似下面这个图：</p>
<p><img src="https://pic.imgdb.cn/item/630ec76416f2c2beb174b16f.png"></p>
<p>在上面已经封装了兔子这个类，其他动物也一样可以进行封装。在封装过程中发现兔子、绵羊这两个类具有相似的功能或特性如吃草，所以可以抽取共有特征和方法形成高一层的类，如这里的食草动物、食肉动物。继承之间是子父类的关系。继承机制可以很好的描述一个类的生态，也提高了代码复用率。</p>
<ul>
<li><strong>多态</strong></li>
</ul>
<p>多态同一个行为具有多个不同表现形式或形态的能力。是指一个类实例（对象）的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p>
<p>多态的优点：</p>
<ul>
<li>消除类型之间的耦合关系</li>
<li>可替换性</li>
<li>可扩充性</li>
<li>接口性</li>
<li>灵活性</li>
<li>简化性</li>
</ul>
<p>简言之，多态其实是在继承的基础上的。比如说今天要去动物园参观动物，那么你说我们去参观兔子、参观绵羊、参观狮子、参观豹子都是对的，但你不能说我们去参观汽车。在这个例子中，子类具有多态性：除了使用自己的身份，还能充当父类。</p>
<h2 id="2、类的封装"><a href="#2、类的封装" class="headerlink" title="2、类的封装"></a>2、类的封装</h2><p>编写程序的目的是为了解决现实中的问题，而这些问题的构成都是由各种事物组成，在计算机中要解决这种问题，首先要做就是要将这个问题的参与者：事和物抽象到计算机程序中，也就是用程序语言表示现实的事物。那么现在问题是如何用程序语言来表示现实事物？现实世界的事物所具有的共性就是每个事物都具有自身的属性，一些自身具有的行为，所以如果能把事物的属性和行为表示出来，那么就可以抽象出来这个事物。</p>
<p>比如要表示人这个对象，在c语言中，可以这么表示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_Person</span>&#123;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;Person;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_Aninal</span>&#123;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> type; <span class="comment">//动物种类</span></span><br><span class="line">&#125;Ainmal;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PersonEat</span><span class="params">(Person* person)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s在吃人吃的饭!\n&quot;</span>,person-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AnimalEat</span><span class="params">(Ainmal* animal)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s在吃动物吃的饭!\n&quot;</span>, animal-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	Person person;</span><br><span class="line">	<span class="built_in">strcpy</span>(person.name, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">	person.age = <span class="number">30</span>;</span><br><span class="line">	<span class="built_in">AnimalEat</span>(&amp;person);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个结构体用来表示一个对象所包含的属性，函数用来表示一个对象所具有的行为，这样我们就表示出来一个事物，在c语言中，行为和属性是分开的，也就是说吃饭这个属性不属于某类对象，而属于所有的共同的数据，所以不单单是PeopleEat可以调用Person数据，AnimalEat也可以调用Person数据，那么万一调用错误，将会导致问题发生。从这个案例可以体会到，属性和行为应该放在一起，一起表示一个具有属性和行为的对象。</p>
<p>1）封装，是面向对象程序设计最基本的特性。把数据（属性）和函数（操作）合成一个整体，这在计算机世界中是用类与对象实现的。</p>
<p>2）封装，把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p>
<p>注意：有2层含义（把属性和方法进行封装 ，对属性和方法进行访问控制）</p>
<p>C++中类的封装</p>
<ul>
<li><p>成员变量，C++中用于表示类属性的变量</p>
</li>
<li><p>成员函数，C++中用于表示类行为的函数</p>
</li>
</ul>
<p>类成员的访问控制，在C++中可以给成员变量和成员函数定义访问级别。</p>
<ul>
<li>访问权限<ul>
<li>在类的内部(作用域范围内)，没有访问权限之分，所有成员可以相互访问</li>
<li>在类的外部(作用域范围外)，访问权限才有意义：public，private，protected</li>
<li>在类的外部，只有public修饰的成员才能被访问，在没有涉及继承与派生时，private和protected是同等级的，外部不允许访问。</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/630ec80816f2c2beb1750338.jpg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装两层含义</span></span><br><span class="line"><span class="comment">//1. 属性和行为合成一个整体</span></span><br><span class="line"><span class="comment">//2. 访问控制，现实事物本身有些属性和行为是不对外开放</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="comment">//人具有的行为(函数)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Dese</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;我有钱，年轻，个子又高，就爱嘚瑟!&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line"><span class="comment">//人的属性(变量)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mTall; <span class="comment">//多高，可以让外人知道</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> mMoney; <span class="comment">// 有多少钱,只能儿子孙子知道</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mAge; <span class="comment">//年龄，不想让外人知道</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	p.mTall = <span class="number">220</span>;</span><br><span class="line">	<span class="comment">//p.mMoney 保护成员外部无法访问</span></span><br><span class="line">	<span class="comment">//p.mAge 私有成员外部无法访问</span></span><br><span class="line">	p.<span class="built_in">Dese</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>struct和class关键字区别</strong></p>
<ul>
<li><p>在用struct定义类时，所有成员的默认属性为public</p>
</li>
<li><p>在用class定义类时，所有成员的默认属性为private</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	B b;</span><br><span class="line">	<span class="comment">//a.mAge; //无法访问私有成员</span></span><br><span class="line">	b.mAge; <span class="comment">//可正常外部访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将成员变量设置为private</strong></p>
<ul>
<li><p>可赋予客户端访问数据的一致性。</p>
<p>如果成员变量不是public，客户端唯一能够访问对象的方法就是通过成员函数。如果类中所有public权限的成员都是函数，客户在访问类成员时只会默认访问函数，不需要考虑访问的成员需不需要添加(),这就省下了许多搔首弄耳的时间。</p>
</li>
<li><p>可细微划分访问控制。</p>
<p>使用成员函数可使得对变量的控制处理更加精细。如果让所有的成员变量为public，每个人都可以读写它。如果设置为private，可以实现“不准访问”、“只读访问”、“读写访问”，甚至可以写出“只写访问”。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccessLevels</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//对只读属性进行只读访问</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getReadOnly</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> readOnly; &#125;</span><br><span class="line">	<span class="comment">//对读写属性进行读写访问</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setReadWrite</span><span class="params">(<span class="type">int</span> val)</span></span>&#123; readWrite = val; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getReadWrite</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> readWrite; &#125;</span><br><span class="line">	<span class="comment">//对只写属性进行只写访问</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setWriteOnly</span><span class="params">(<span class="type">int</span> val)</span></span>&#123; writeOnly = val; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> readOnly; <span class="comment">//对外只读访问</span></span><br><span class="line">	<span class="type">int</span> noAccess; <span class="comment">//外部不可访问</span></span><br><span class="line">	<span class="type">int</span> readWrite; <span class="comment">//读写访问</span></span><br><span class="line">	<span class="type">int</span> writeOnly; <span class="comment">//只写访问</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="3、面向对象程序设计案例"><a href="#3、面向对象程序设计案例" class="headerlink" title="3、面向对象程序设计案例"></a>3、面向对象程序设计案例</h2><h3 id="3-1、设计立方体类"><a href="#3-1、设计立方体类" class="headerlink" title="3.1、设计立方体类"></a>3.1、设计立方体类</h3><p>设计立方体类(cube)，求出立方体的面积和体积，求两个立方体，是否相等（全局函数和成员函数）。</p>
<p><img src="https://pic.imgdb.cn/item/630ec82c16f2c2beb17513d1.jpg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//立方体类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cub</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setL</span><span class="params">(<span class="type">int</span> l)</span></span>&#123; mL = l; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setW</span><span class="params">(<span class="type">int</span> w)</span></span>&#123; mW = w; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setH</span><span class="params">(<span class="type">int</span> h)</span></span>&#123; mH = h; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getL</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> mL; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getW</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> mW; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getH</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> mH; &#125;</span><br><span class="line">	<span class="comment">//立方体面积</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">caculateS</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> (mL*mW + mL*mH + mW*mH) * <span class="number">2</span>; &#125;</span><br><span class="line">	<span class="comment">//立方体体积</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">caculateV</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> mL * mW * mH; &#125;</span><br><span class="line">	<span class="comment">//成员方法</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">CubCompare</span><span class="params">(Cub&amp; c)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">getL</span>() == c.<span class="built_in">getL</span>() &amp;&amp; <span class="built_in">getW</span>() == c.<span class="built_in">getW</span>() &amp;&amp; <span class="built_in">getH</span>() == c.<span class="built_in">getH</span>())&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mL; <span class="comment">//长</span></span><br><span class="line">	<span class="type">int</span> mW; <span class="comment">//宽</span></span><br><span class="line">	<span class="type">int</span> mH; <span class="comment">//高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较两个立方体是否相等</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CubCompare</span><span class="params">(Cub&amp; c1, Cub&amp; c2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (c1.<span class="built_in">getL</span>() == c2.<span class="built_in">getL</span>() &amp;&amp; c1.<span class="built_in">getW</span>() == c2.<span class="built_in">getW</span>() &amp;&amp; c1.<span class="built_in">getH</span>() == c2.<span class="built_in">getH</span>())&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Cub c1, c2;</span><br><span class="line">	c1.<span class="built_in">setL</span>(<span class="number">10</span>);</span><br><span class="line">	c1.<span class="built_in">setW</span>(<span class="number">20</span>);</span><br><span class="line">	c1.<span class="built_in">setH</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	c2.<span class="built_in">setL</span>(<span class="number">20</span>);</span><br><span class="line">	c2.<span class="built_in">setW</span>(<span class="number">20</span>);</span><br><span class="line">	c2.<span class="built_in">setH</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c1面积:&quot;</span> &lt;&lt; c1.<span class="built_in">caculateS</span>() &lt;&lt; <span class="string">&quot; 体积:&quot;</span> &lt;&lt; c1.<span class="built_in">caculateV</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c2面积:&quot;</span> &lt;&lt; c2.<span class="built_in">caculateS</span>() &lt;&lt; <span class="string">&quot; 体积:&quot;</span> &lt;&lt; c2.<span class="built_in">caculateV</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//比较两个立方体是否相等</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">CubCompare</span>(c1, c2))&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;c1和c2相等!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;c1和c2不相等!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (c1.<span class="built_in">CubCompare</span>(c2))&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;c1和c2相等!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;c1和c2不相等!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2、设计圆类，描述点和圆的关系"><a href="#3-2、设计圆类，描述点和圆的关系" class="headerlink" title="3.2、设计圆类，描述点和圆的关系"></a>3.2、设计圆类，描述点和圆的关系</h3><p>设计一个圆形类（AdvCircle），和一个点类（Point），计算点在圆内部还是圆外。即：求点和圆的关系（圆内和圆外）</p>
<p>假如圆心坐标为x0, y0, 半径为r，点的坐标为x1, y1：</p>
<p>1）点在圆上：(x1-x0)<em>(x1-x0) + (y1-y0)</em>(y1-y0) &#x3D;&#x3D; r*r</p>
<p>2）点在圆内：(x1-x0)<em>(x1-x0) + (y1-y0)</em>(y1-y0) &lt; r*r</p>
<p>3）点在圆外：(x1-x0)<em>(x1-x0) + (y1-y0)</em>(y1-y0) &gt; r*r</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; mX = x; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> y)</span></span>&#123; mY = y; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> mX; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> mY; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> mX;</span><br><span class="line">	<span class="type">int</span> mY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//圆类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setP</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">		mP.<span class="built_in">setX</span>(x);</span><br><span class="line">		mP.<span class="built_in">setY</span>(y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setR</span><span class="params">(<span class="type">int</span> r)</span></span>&#123; mR = r; &#125;</span><br><span class="line">	<span class="function">Point&amp; <span class="title">getP</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> mP; &#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getR</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> mR; &#125;</span><br><span class="line">	<span class="comment">//判断点和圆的关系</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">IsPointInCircle</span><span class="params">(Point&amp; point)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> distance = (point.<span class="built_in">getX</span>() - mP.<span class="built_in">getX</span>()) * (point.<span class="built_in">getX</span>() - mP.<span class="built_in">getX</span>()) + (point.<span class="built_in">getY</span>() - mP.<span class="built_in">getY</span>()) * (point.<span class="built_in">getY</span>() - mP.<span class="built_in">getY</span>());</span><br><span class="line">		<span class="type">int</span> radius = mR * mR;</span><br><span class="line">		<span class="keyword">if</span> (distance &lt; radius)&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Point(&quot;</span> &lt;&lt; point.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; point.<span class="built_in">getY</span>() &lt;&lt; <span class="string">&quot;)在圆内!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (distance &gt; radius)&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Point(&quot;</span> &lt;&lt; point.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; point.<span class="built_in">getY</span>() &lt;&lt; <span class="string">&quot;)在圆外!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Point(&quot;</span> &lt;&lt; point.<span class="built_in">getX</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; point.<span class="built_in">getY</span>() &lt;&lt; <span class="string">&quot;)在圆上!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Point mP; <span class="comment">//圆心</span></span><br><span class="line">	<span class="type">int</span> mR; <span class="comment">//半径</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//实例化圆对象</span></span><br><span class="line">	Circle circle;</span><br><span class="line">	circle.<span class="built_in">setP</span>(<span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">	circle.<span class="built_in">setR</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="comment">//实例化点对象</span></span><br><span class="line">	Point point;</span><br><span class="line">	point.<span class="built_in">setX</span>(<span class="number">25</span>);</span><br><span class="line">	point.<span class="built_in">setY</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	circle.<span class="built_in">IsPointInCircle</span>(point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++对C的函数扩展</title>
    <url>/2022/08/31/C-%E5%AF%B9C%E7%9A%84%E5%87%BD%E6%95%B0%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-对C的函数扩展"><a href="#C-对C的函数扩展" class="headerlink" title="C++对C的函数扩展"></a>C++对C的函数扩展</h1><h2 id="1、内联函数"><a href="#1、内联函数" class="headerlink" title="1、内联函数"></a>1、内联函数</h2><p>在c中我们经常把一些短并且执行频繁的计算写成宏，而不是函数，这样做的理由是为了执行效率，宏可以避免函数调用的开销，这些都由预处理来完成。<span id="more"></span>但是在c++出现之后，使用预处理宏会出现两个问题：</p>
<ul>
<li><p>第一个在c中也会出现，宏看起来像一个函数调用，但是会有隐藏一些难以发现的错误。</p>
</li>
<li><p>第二个问题是c++特有的，预处理器不允许访问类的成员，也就是说预处理器宏不能用作类类的成员函数。</p>
</li>
</ul>
<p>为了保持预处理宏的效率又增加安全性，而且还能像一般成员函数那样可以在类里访问自如，c++引入了内联函数(inline function)。内联函数为了继承宏函数的效率，没有函数调用时开销，然后又可以像普通函数那样，可以进行参数，返回值类型的安全检查，又可以作为成员函数。</p>
<h3 id="1-1、预处理宏的缺陷"><a href="#1-1、预处理宏的缺陷" class="headerlink" title="1.1、预处理宏的缺陷"></a>1.1、预处理宏的缺陷</h3><p>预处理器宏存在问题的关键是我们可能认为预处理器的行为和编译器的行为是一样的。当然也是由于宏函数调用和函数调用在外表看起来是一样的，因此也容易被混淆。但是其中也会有一些微妙的问题出现：</p>
<p>如下两段代码示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(x,y) x+y</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret1 = <span class="built_in">ADD</span>(<span class="number">10</span>, <span class="number">20</span>) * <span class="number">10</span>; <span class="comment">//希望的结果是300</span></span><br><span class="line">	<span class="type">int</span> ret2 = <span class="built_in">Add</span>(<span class="number">10</span>, <span class="number">20</span>) * <span class="number">10</span>; <span class="comment">//希望结果也是300</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret1:&quot;</span> &lt;&lt; ret1 &lt;&lt; endl; <span class="comment">//210</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret2:&quot;</span> &lt;&lt; ret2 &lt;&lt; endl; <span class="comment">//300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COMPARE(x,y) ((x) &lt; (y) ? (x) : (y))</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Compare</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;COMPARE(++a, b):&quot; &lt;&lt; COMPARE(++a, b) &lt;&lt; endl; // 3</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Compare(int x,int y):&quot;</span> &lt;&lt; <span class="built_in">Compare</span>(++a, b) &lt;&lt; endl; <span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2、内联函数"><a href="#1-2、内联函数" class="headerlink" title="1.2、内联函数"></a>1.2、内联函数</h3><p>内联函数本身也是一个真正的函数。内联函数具有普通函数的所有行为。唯一不同之处在于内联函数会在适当的地方像预定义宏一样展开，所以不需要函数调用的开销。因此应该不使用宏，使用内联函数。在普通函数(非成员函数)函数前面加上inline关键字使之成为内联函数。但是必须注意函数体和声明结合在一起，否则编译器将它作为普通函数来对待。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br></pre></td></tr></table></figure>

<p>以上写法没有任何效果，仅仅是声明函数，应该如下方式来做：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：编译器将会检查函数参数列表使用是否正确，并返回值(进行必要的转换)。这些是预处理器无法完成的。内联函数的确占用空间，但是内联函数相对于普通函数的优势只是省去了函数调用时候的压栈，跳转，返回的开销。可以理解为内联函数是以空间换时间。</p>
<h3 id="1-3、总结"><a href="#1-3、总结" class="headerlink" title="1.3、总结"></a>1.3、总结</h3><ul>
<li><p>必须inline int myfunc(int a, int b)和函数体的实现，写在一块。</p>
</li>
<li><p>C++编译器可以将一个函数进行内联编译，被C++编译器内联编译的函数叫做内联函数。内联函数在最终生成的代码中是没有定义的。C++编译器直接将函数体插入在函数调用的地方 。内联函数没有普通函数调用时的额外开销(压栈，跳转，返回)。</p>
</li>
<li><p>C++编译器不一定准许函数的内联请求！</p>
</li>
<li><p>内联函数是一种特殊的函数，具有普通函数的特征（参数检查，返回类型等）。内联函数是对编译器的一种请求，因此编译器可能拒绝这种请求。内联函数由编译器处理，直接将编译后的函数体插入调用的地方。宏代码片段由预处理器处理， 进行简单的文本替换，没有任何编译过程。</p>
</li>
<li><p>现代C++编译器能够进行编译优化，因此一些函数即使没有inline声明，也可能被编译器内联编译。另外，一些现代C++编译器提供了扩展语法，能够对函数进行强制内联。</p>
<p>如：g++中的_attribute_((always_inline))属性</p>
</li>
<li><p>C++中内联编译的限制：不能存在任何形式的循环语句 ；不能存在过多的条件判断语句；函数体不能过于庞大；不能对函数进行取址操作；函数内联声明必须在调用语句之前。</p>
</li>
</ul>
<p>编译器对于内联函数的限制并不是绝对的，内联函数相对于普通函数的优势只是省去了函数调用时压栈，跳转和返回的开销。因此，当函数体的执行开销远大于压栈，跳转和返回所用的开销时，那么内联将无意义。</p>
<h2 id="2、函数的默认参数"><a href="#2、函数的默认参数" class="headerlink" title="2、函数的默认参数"></a>2、函数的默认参数</h2><p>c++在声明函数原型的时可为一个或者多个参数指定默认(缺省)的参数值，当函数调用的时候如果没有指定这个值，编译器会自动用默认值代替。</p>
<p>函数默认参数的规则：</p>
<ul>
<li><p>只有参数列表后面部分的参数才可以提供默认参数值。</p>
</li>
<li><p>一旦在一个函数调用中开始使用默认参数值，那么这个参数后的所有参数都必须使用默认参数值。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunc01</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">20</span>)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a + b  = &quot;</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意点:</span></span><br><span class="line"><span class="comment">//1. 形参b设置默认参数值，那么后面位置的形参c也需要设置默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunc02</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b = <span class="number">10</span>,<span class="type">int</span> c = <span class="number">10</span>)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//2. 如果函数声明和函数定义分开，函数声明设置了默认参数，函数定义不能再设置默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunc03</span><span class="params">(<span class="type">int</span> a = <span class="number">0</span>,<span class="type">int</span> b = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunc03</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//1.如果没有传参数，那么使用默认参数</span></span><br><span class="line">	<span class="built_in">TestFunc01</span>();</span><br><span class="line">	<span class="comment">//2. 如果传一个参数，那么第二个参数使用默认参数</span></span><br><span class="line">	<span class="built_in">TestFunc01</span>(<span class="number">100</span>);</span><br><span class="line">	<span class="comment">//3. 如果传入两个参数，那么两个参数都使用传入的参数</span></span><br><span class="line">	<span class="built_in">TestFunc01</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：函数的默认参数从左向右，如果一个参数设置了默认参数，那么这个参数之后的参数都必须设置默认参数。如果函数声明和函数定义分开写，函数声明和函数定义不能同时设置默认参数。</p>
<h2 id="3、函数的占位参数"><a href="#3、函数的占位参数" class="headerlink" title="3、函数的占位参数"></a>3、函数的占位参数</h2><p>c++在声明函数时，可以设置占位参数。占位参数只有参数类型声明，而没有参数名声明。一般情况下，在函数体内部无法使用占位参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunc01</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">//函数内部无法使用占位参数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a + b = &quot;</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//占位参数也可以设置默认值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunc02</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> = <span class="number">20</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">//函数内部依旧无法使用占位参数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a + b = &quot;</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//错误调用，占位参数也是参数，必须传参数</span></span><br><span class="line">	<span class="comment">//TestFunc01(10,20); </span></span><br><span class="line">	<span class="comment">//正确调用</span></span><br><span class="line">	<span class="built_in">TestFunc01</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">	<span class="comment">//正确调用</span></span><br><span class="line">	<span class="built_in">TestFunc02</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">	<span class="comment">//正确调用</span></span><br><span class="line">	<span class="built_in">TestFunc02</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将占位参数与默认参数结合起来使用。为以后程序的扩展留下线索，兼容C语言程序中可能出现的不规范写法。C++可以声明占位符参数，占位符参数一般用于程序扩展和对C代码的兼容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果默认参数和占位参数在一起，都能调用起来</span></span><br><span class="line">	<span class="built_in">func2</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">func2</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、函数重载-overload"><a href="#4、函数重载-overload" class="headerlink" title="4、函数重载(overload)"></a>4、函数重载(overload)</h2><p>函数重载(Function Overload)：用同一个函数名定义不同的函数，当函数名和不同的参数搭配时函数的含义不同。</p>
<p>实现函数重载的条件是指同一个作用域，名字相同的函数至少满足下面的一个条件：</p>
<ul>
<li><p>参数个数不同</p>
</li>
<li><p>参数类型不同</p>
</li>
<li><p>参数顺序不同</p>
</li>
</ul>
<p>函数返回值不是函数重载的判断标准。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 函数重载条件</span></span><br><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;无参数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">(<span class="type">int</span> a)</span></span>&#123; cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">(string b)</span></span>&#123; cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; b &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">(<span class="type">int</span> a, string b)</span></span>&#123; cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">(string b, <span class="type">int</span> a)</span></span>&#123;cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.返回值不作为函数重载依据</span></span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">(string b, <span class="type">int</span> a)</span></span>&#123;&#125;</span><br><span class="line">	<span class="comment">//int MyFunc(string b, int a)&#123;&#125; //无法重载仅按返回值区分的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么函数返回值不作为重载条件呢？</p>
<p>当编译器能从上下文中确定唯一的函数的时，如int ret &#x3D; func(),这个当然是没有问题的。然而在编写程序过程中可以忽略返回值。那么这个时候，一个函数为void func(int x)；另一个为int func(int x)； 当直接调用func(10)这个时候编译器就不确定调用那个函数。所以在c++中禁止使用返回值作为重载的条件。</p>
<p>注意：函数重载和默认参数一起使用，需要额外注意二义性问题的产生。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1个参数的允许吗</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	c = <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 存在二义性，调用失败，编译不能通过 </span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Press enter to continue ...&quot;</span>);</span><br><span class="line">	<span class="built_in">getchar</span>();	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数重载和函数指针结合</p>
<p>当使用重载函数名对函数指针进行赋值时，根据重载规则挑选与函数指针参数列表一致的候选者。严格匹配候选者的函数类型与函数指针的函数类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// int(int a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strlen</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*PFUNC)</span><span class="params">(<span class="type">int</span> a)</span></span>; <span class="comment">// int(int a)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">	PFUNC p = func;</span><br><span class="line"></span><br><span class="line">	c = <span class="built_in">p</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Press enter to continue ...&quot;</span>);</span><br><span class="line">	<span class="built_in">getchar</span>();	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、函数重载实现原理"><a href="#5、函数重载实现原理" class="headerlink" title="5、函数重载实现原理"></a>5、函数重载实现原理</h2><p>编译器为了实现函数重载，也是默认做了一些幕后的工作，编译器用不同的参数类型来修饰不同的函数名，比如void func()； 编译器可能会将函数名修饰成func，当编译器碰到void func(int x)，编译器可能将函数名修饰为_func_int，当编译器碰到void func(int x,char c)，编译器可能会将函数名修饰为_func_int_char，这里使用”可能”这个字眼是因为编译器如何修饰重载的函数名称并没有一个统一的标准，所以不同的编译器可能会产生不同的内部名。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x,<span class="type">char</span> y)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>以上三个函数在linux下生成的编译之后的函数名为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_Z4funcv <span class="comment">//v 代表void,无参数</span></span><br><span class="line">_Z4funci <span class="comment">//i 代表参数为int类型</span></span><br><span class="line">_Z4funcic <span class="comment">//i 代表第一个参数为int类型，第二个参数为char类型</span></span><br></pre></td></tr></table></figure>

<h2 id="6、extern-“C”浅析"><a href="#6、extern-“C”浅析" class="headerlink" title="6、extern “C”浅析"></a>6、extern “C”浅析</h2><p>以下在Linux下测试:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c函数: void MyFunc()&#123;&#125; ,被编译成函数: MyFunc</span><br><span class="line">c++函数: void MyFunc()&#123;&#125;,被编译成函数: _Z6Myfuncv</span><br></pre></td></tr></table></figure>

<p>在这个测试中，由于C++中需要支持函数重载，所以C和C++中对同一个函数经过编译后生成的函数名是不相同的，这就导致了一个问题，如果在C++中调用一个使用C语言编写模块中的某个函数，那么C++是根据C++的名称修饰方式来查找并链接这个函数，那么就会发生链接错误，以上例中，C++中调用MyFunc函数，在链接阶段会去找Z6Myfuncv，结果是没有找到的，因为这个MyFunc函数是c语言编写的，生成的符号是MyFunc。</p>
<p>那么如果想在C++调用C的函数怎么办？</p>
<p>extern “C”的主要作用就是为了实现C++代码能够调用其他C语言代码。加上extern “C”后，这部分代码编译器按c语言的方式进行编译和链接，而不是按C++的方式。</p>
<p>MyModule.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYMODULE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYMODULE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>MyModule.c</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;MyModule.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TestExternC.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">		<span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">			<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">			<span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line">		<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			<span class="meta">#<span class="keyword">include</span><span class="string">&quot;MyModule.h&quot;</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">func1</span>();</span><br><span class="line">	cout &lt;&lt; <span class="built_in">func2</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的引用</title>
    <url>/2022/08/31/C-%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="引用（reference）"><a href="#引用（reference）" class="headerlink" title="引用（reference）"></a>引用（reference）</h1><h2 id="1、引用基本用法"><a href="#1、引用基本用法" class="headerlink" title="1、引用基本用法"></a>1、引用基本用法</h2><p>引用是c++对c的重要扩充。在c&#x2F;c++中指针的作用基本都是一样的，但是c++增加了另外一种给函数传递地址的途径，这就是按引用传递(pass-by-reference)，它也存在于其他一些编程语言中，并不是c++的发明。<span id="more"></span></p>
<p>变量名概念：</p>
<ul>
<li><p>变量名实质上是一段连续内存空间的别名，是一个标号(门牌号)</p>
</li>
<li><p>程序中通过变量来申请并命名内存空间</p>
</li>
<li><p>通过变量的名字可以使用存储空间</p>
</li>
</ul>
<p>那么，对一段连续的内存空间只能取一个别名吗？c++中新增了引用的概念，引用可以作为一个已定义变量的别名。</p>
<p>引用的语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Type&amp; ref = val;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//给变量a取一个别名b</span></span><br><span class="line">	<span class="type">int</span>&amp; b = a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//操作b就相当于操作a本身</span></span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//一个变量可以有n个别名</span></span><br><span class="line">	<span class="type">int</span>&amp; c = a;</span><br><span class="line">	c = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c:&quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//a,b,c的地址都是相同的</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c:&quot;</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li><p>&amp;在此不是求地址运算，而是起标识作用。</p>
</li>
<li><p>类型标识符是指目标变量的类型</p>
</li>
<li><p>必须在声明引用变量时进行初始化。</p>
</li>
<li><p>引用初始化之后不能改变。</p>
</li>
<li><p>不能有NULL引用。必须确保引用是和一块合法的存储单元关联。</p>
</li>
<li><p>可以建立对数组的引用。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用引用注意事项</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//1) 引用必须初始化</span></span><br><span class="line">	<span class="comment">//int&amp; ref; //报错:必须初始化引用</span></span><br><span class="line">	<span class="comment">//2) 引用一旦初始化，不能改变引用</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span>&amp; ref = a;</span><br><span class="line">	ref = b; <span class="comment">//不能改变引用</span></span><br><span class="line">	<span class="comment">//3) 不能对数组建立引用</span></span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">	<span class="comment">//int&amp; ref3[10] = arr;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立对数组的引用有如下方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 建立数组引用方法一</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> ArrRef[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    ArrRef&amp; aRef = arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i ++)&#123;</span><br><span class="line">        aRef[i] = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 建立数组引用方法二</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">int</span>(&amp;f)[<span class="number">10</span>] = arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        f[i] = i+<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、函数中的引用"><a href="#2、函数中的引用" class="headerlink" title="2、函数中的引用"></a>2、函数中的引用</h2><p>最常见看见引用的地方是在函数参数和返回值中。当引用被用作函数参数时，在函数内对任何引用的修改，将对函数外的参数产生改变。可以通过传递一个指针来做相同的事情，但引用具有更清晰的语法。如果从函数中返回一个引用，必须像从函数中返回一个指针一样对待。当函数返回值时，引用关联的内存一定要存在。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ValueSwap</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = m;</span><br><span class="line">	m = n;</span><br><span class="line">	n = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PointerSwap</span><span class="params">(<span class="type">int</span>* m,<span class="type">int</span>* n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *m;</span><br><span class="line">	*m = *n;</span><br><span class="line">	*n = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReferenceSwap</span><span class="params">(<span class="type">int</span>&amp; m,<span class="type">int</span>&amp; n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = m;</span><br><span class="line">	m = n;</span><br><span class="line">	n = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//值传递</span></span><br><span class="line">	<span class="built_in">ValueSwap</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//地址传递</span></span><br><span class="line">	<span class="built_in">PointerSwap</span>(&amp;a, &amp;b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//引用传递</span></span><br><span class="line">	<span class="built_in">ReferenceSwap</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单：	</p>
<ol>
<li><p>函数调用时传递的实参不必加“&amp;”符 。</p>
</li>
<li><p>在被调函数中不必在参数前加“*”符。</p>
</li>
</ol>
<p>引用作为其它变量的别名而存在，因此在一些场合可以代替指针。C++主张用引用传递取代地址传递的方式，因为引用语法容易且不易出错。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">TestFun01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">TestFunc02</span><span class="params">()</span></span>&#123;	</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;static int a : &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ret01 = <span class="built_in">TestFun01</span>();</span><br><span class="line">	<span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line">	<span class="built_in">TestFunc02</span>();</span><br><span class="line">	<span class="built_in">TestFunc02</span>() = <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">TestFunc02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>不能返回局部变量的引用。</p>
</li>
<li><p>函数当左值，必须返回引用。</p>
</li>
</ul>
<h2 id="3、引用的意义和本质"><a href="#3、引用的意义和本质" class="headerlink" title="3、引用的意义和本质"></a>3、引用的意义和本质</h2><h3 id="3-1、引用的意义"><a href="#3-1、引用的意义" class="headerlink" title="3.1、引用的意义"></a>3.1、引用的意义</h3><p>1）引用作为其它变量的别名而存在，因此在一些场合可以代替指针</p>
<p>2）引用相对于指针来说具有更好的可读性和实用性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">swap1</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2、引用的本质"><a href="#3-2、引用的本质" class="headerlink" title="3.2、引用的本质"></a>3.2、引用的本质</h3><p>引用的本质在c++内部实现是一个指针常量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Type&amp; ref = val; <span class="comment">// Type* const ref = &amp;val;</span></span><br></pre></td></tr></table></figure>

<p>c++编译器在编译过程中使用常指针作为引用的内部实现，因此引用所占用的空间大小与指针相同，只是这个过程是编译器内部实现，用户不可见。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFunc</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span>&amp; aRef = a; <span class="comment">//自动转换为 int* const aRef = &amp;a;这也能说明引用为什么必须初始化</span></span><br><span class="line">	aRef = <span class="number">20</span>; <span class="comment">//内部发现aRef是引用，自动帮我们转换为: *aRef = 20;</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;aRef:&quot;</span> &lt;&lt; aRef &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">testFunc</span>(a);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结如下：</p>
<p>1）引用在C++中的内部实现是一个常指针    Type&amp; name çèType* const name</p>
<p>2）C++编译器在编译过程中使用常指针作为引用的内部实现，因此引用所占用的空间大小与指针相同。</p>
<p>3）从使用的角度，引用会让人误会其只是一个别名，没有自己的存储空间。这是C++为了实用性而做出的细节隐藏</p>
<h2 id="4、指针引用"><a href="#4、指针引用" class="headerlink" title="4、指针引用"></a>4、指针引用</h2><p>在c语言中如果想改变一个指针的指向而不是它所指向的内容，函数声明可能这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>**)</span></span>;</span><br></pre></td></tr></table></figure>

<p>给指针变量取一个别名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Type* pointer = <span class="literal">NULL</span>;  </span><br><span class="line">Type*&amp; = pointer;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//指针间接修改teacher的年龄</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AllocateAndInitByPointer</span><span class="params">(Teacher** teacher)</span></span>&#123;</span><br><span class="line">	*teacher = (Teacher*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Teacher));</span><br><span class="line">	(*teacher)-&gt;mAge = <span class="number">200</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//引用修改teacher年龄</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AllocateAndInitByReference</span><span class="params">(Teacher*&amp; teacher)</span></span>&#123;</span><br><span class="line">	teacher-&gt;mAge = <span class="number">300</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//创建Teacher</span></span><br><span class="line">	Teacher* teacher = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//指针间接赋值</span></span><br><span class="line">	<span class="built_in">AllocateAndInitByPointer</span>(&amp;teacher);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;AllocateAndInitByPointer:&quot;</span> &lt;&lt; teacher-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//引用赋值,将teacher本身传到ChangeAgeByReference函数中</span></span><br><span class="line">	<span class="built_in">AllocateAndInitByReference</span>(teacher);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;AllocateAndInitByReference:&quot;</span> &lt;&lt; teacher-&gt;mAge &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">free</span>(teacher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、常量引用"><a href="#5、常量引用" class="headerlink" title="5、常量引用"></a>5、常量引用</h2><p>常量引用的定义格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> Type&amp; ref = val;</span><br></pre></td></tr></table></figure>

<p>常量引用注意：</p>
<ul>
<li><p>字面量不能赋给引用，但是可以赋给const引用</p>
</li>
<li><p>const修饰的引用，不能修改。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; aRef = a; <span class="comment">//此时aRef就是a</span></span><br><span class="line">	<span class="comment">//aRef = 200; 不能通过aRef的值</span></span><br><span class="line">	a = <span class="number">100</span>; <span class="comment">//OK</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;aRef:&quot;</span> &lt;&lt; aRef &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//不能把一个字面量赋给引用</span></span><br><span class="line">	<span class="comment">//int&amp; ref = 100;</span></span><br><span class="line">	<span class="comment">//但是可以把一个字面量赋给常引用</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">100</span>; <span class="comment">//int temp = 200; const int&amp; ret = temp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> const引用使用场景</p>
<ul>
<li><p>常量引用主要用在函数的形参，尤其是类的拷贝&#x2F;复制构造函数。</p>
</li>
<li><p>将函数的形参定义为常量引用的好处:</p>
<ul>
<li><p>引用不产生新的变量，减少形参与实参传递时的开销。</p>
</li>
<li><p>由于引用可能导致实参随形参改变而改变，将其定义为常量引用可以消除这种副作用。</p>
</li>
</ul>
</li>
<li><p>如果希望实参随着形参的改变而改变，那么使用一般的引用，如果不希望实参随着形参改变，那么使用常引用。</p>
</li>
</ul>
<p>案例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//普通引用</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> &amp;b = a;</span><br><span class="line">	<span class="comment">//常量引用 ：让变量引用只读属性</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> &amp;c = a;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">//常量引用初始化 分为两种</span></span><br><span class="line">	<span class="comment">//1 用变量 初始化 常量引用</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = <span class="number">20</span>;</span><br><span class="line">		<span class="type">const</span> <span class="type">int</span>&amp; y = x;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;y:%d \n&quot;</span>, y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2 用常量 初始化 常量引用</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//int &amp;m = 10; //引用是内存空间的别名 字面量10没有内存空间 没有方法做引用</span></span><br><span class="line">		<span class="type">const</span> <span class="type">int</span> &amp;m = <span class="number">10</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;hello...&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>const引用总结：</p>
<p>1）const &amp; int e  相当于 const int * const e</p>
<p>2）普通引用 相当于 int *const  e</p>
<p>3）当使用常量（字面量）对const引用进行初始化时，C++编译器会为常量值分配空间，并将引用名作为这段空间的别名</p>
<p>4）使用字面量对const引用初始化后，将生成一个只读变量</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的const</title>
    <url>/2022/08/31/C-%E4%B8%AD%E7%9A%84const/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-x2F-C-中的const"><a href="#C-x2F-C-中的const" class="headerlink" title="C&#x2F;C++中的const"></a>C&#x2F;C++中的const</h1><h2 id="1、const概述"><a href="#1、const概述" class="headerlink" title="1、const概述"></a>1、const概述</h2><p>const单词字面意思为常数，不变的。它是c&#x2F;c++中的一个关键字，是一个限定符，它用来限定一个变量不允许改变，它将一个对象转换成一个常量。<span id="more"></span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">A = <span class="number">100</span>; <span class="comment">//编译错误,const是一个常量，不可修改</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> <span class="type">const</span> b;<span class="comment">// 代表一个常整形数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *c;<span class="comment">// c是一个指向常整形数的指针(所指向的内存数据不能被修改，但是本身可以修改)</span></span><br><span class="line">    <span class="type">int</span> * <span class="type">const</span> d;<span class="comment">//d 常指针（指针变量不能被修改，但是它所指向内存空间可以被修改）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> e ;<span class="comment">//e一个指向常整形的常指针（指针和它所指向的内存空间，均不能被修改）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">const</span> )</span></span></span><br></pre></td></tr></table></figure>

<h2 id="2、C-x2F-C-中的const"><a href="#2、C-x2F-C-中的const" class="headerlink" title="2、C&#x2F;C++中的const"></a>2、C&#x2F;C++中的const</h2><h3 id="2-1、C中的const"><a href="#2-1、C中的const" class="headerlink" title="2.1、C中的const"></a>2.1、C中的const</h3><p>常量的引进是在c++早期版本中，当时标准C规范正在制定。那时，尽管C委员会决定在C中引入const，但是，他们c中的const理解为”一个不能改变的普通变量”，也就是认为const应该是一个只读变量，既然是变量那么就会给const分配内存，并且在c中const是一个全局只读变量，c语言中const修饰的只读变量是外部连接的。</p>
<p>如果这么写:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> arrSize = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[arrSize];</span><br></pre></td></tr></table></figure>

<p>这将得出一个错误。 因为arrSize占用某块内存，所以C编译器不知道它在编译时的值是多少？</p>
<h3 id="2-2、C-中的const"><a href="#2-2、C-中的const" class="headerlink" title="2.2、C++中的const"></a>2.2、C++中的const</h3><p>在C中，一个const总是需要一块内存空间。在C++中，是否为const常量分配内存空间依赖于如何使用。一般说来，如果一个const仅仅用来把一个名字用一个值代替(就像使用#define一样)，那么该存储局空间就不必创建。如果存储空间没有分配内存的话，在进行完数据类型检查后，为了代码更加有效，值也许会折叠到代码中。不过，取一个const地址，或者把它定义为extern，则会为该const创建内存空间。在C++中，出现在所有函数之外的const作用于整个文件(也就是说它在该文件外不可见)，默认为内部连接，C++中其他的标识符一般默认为外部连接。</p>
<ul>
<li><p>当const常量为全局，并且需要在其它文件中使用，会分配存储空间</p>
</li>
<li><p>当使用&amp;操作符，取const常量的地址时，会分配存储空间</p>
</li>
<li><p>当const int &amp;a &#x3D; 10; const修饰引用时，也会分配存储空间</p>
</li>
</ul>
<h3 id="2-3、C和C-中的const的异同"><a href="#2-3、C和C-中的const的异同" class="headerlink" title="2.3、C和C++中的const的异同"></a>2.3、C和C++中的const的异同</h3><ul>
<li>C语言全局const会被存储到只读数据段。C++中全局const当声明extern或者对变量取地址时，编译器会分配存储地址，变量存储在只读数据段。两个都受到了只读数据段的保护，不可修改。</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> constA = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="type">int</span>* p = (<span class="type">int</span>*)&amp;constA;</span><br><span class="line">     *p = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  以上代码在C&#x2F;C++中编译通过，在运行期，修改constA的值时，发生写入错误。原因是修改只读数据段的数据。</p>
<ul>
<li><p>C语言中局部const存储在堆栈区，只是不能通过变量直接修改const只读变量的值，但是可以跳过编译器的检查，通过指针间接修改const值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> constA = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)&amp;constA;</span><br><span class="line">*p = <span class="number">300</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;constA:%d\n&quot;</span>,constA);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p:%d\n&quot;</span>, *p);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constA:300</span><br><span class="line">*p:300</span><br></pre></td></tr></table></figure>

<p>C语言中，通过指针间接赋值修改了constA的值。</p>
</li>
<li><p>C++中对于局部的const变量要区别对待：</p>
<p>1）对于基础数据类型，也就是const int a &#x3D; 10这种，编译器会把它放到符号表中，不分配内存，当对其取地址时，会分配内存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> constA = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)&amp;constA;</span><br><span class="line">*p = <span class="number">300</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;constA:&quot;</span> &lt;&lt; constA &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p:&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constA:10</span><br><span class="line">*p:300</span><br></pre></td></tr></table></figure>

<p>constA在符号表中，当我们对constA取地址，这个时候为constA分配了新的空间，*p操作的是分配的空间，而constA是从符号表获得的值。</p>
<p>2）对于基础数据类型，如果用一个变量初始化const变量，如果const int a &#x3D; b,那么也是会给a分配内存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> constA = b;</span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)&amp;constA;</span><br><span class="line">*p = <span class="number">300</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;constA:&quot;</span> &lt;&lt; constA &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p:&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constA:300</span><br><span class="line">*p:300</span><br></pre></td></tr></table></figure>

<p>constA 分配了内存，所以可以修改constA内存中的值。</p>
<p>3） 对于自定数据类型，比如类对象，那么也会分配内存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> Person person; <span class="comment">//未初始化age</span></span><br><span class="line"><span class="comment">//person.age = 50; //不可修改</span></span><br><span class="line">Person* pPerson = (Person*)&amp;person;</span><br><span class="line"><span class="comment">//指针间接修改</span></span><br><span class="line">pPerson-&gt;age = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pPerson-&gt;age:&quot;</span> &lt;&lt; pPerson-&gt;age &lt;&lt; endl;</span><br><span class="line">pPerson-&gt;age = <span class="number">200</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pPerson-&gt;age:&quot;</span> &lt;&lt; pPerson-&gt;age &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pPerson-&gt;age:100</span><br><span class="line">pPerson-&gt;age:200</span><br></pre></td></tr></table></figure>

<p>为person分配了内存，所以可以通过指针的间接赋值修改person对象。</p>
</li>
<li><p>C中const默认为外部连接，C++中const默认为内部连接.当c语言两个文件中都有const int a的时候，编译器会报重定义的错误。而在C++中，则不会，因为C++中的const默认是内部连接的。如果想让C++中的const具有外部连接，必须显示声明为: extern const int a &#x3D; 10;</p>
</li>
</ul>
<p>const由C++采用，并加进标准C中，尽管他们很不一样。在C中，编译器对待const如同对待变量一样，只不过带有一个特殊的标记，意思是”你不能改变我”。在C++中定义const时，编译器为它创建空间，所以如果在两个不同文件定义多个同名的const，链接器将发生链接错误。简而言之，const在C++中用的更好。</p>
<h2 id="3、const和-define"><a href="#3、const和-define" class="headerlink" title="3、const和#define"></a>3、const和#define</h2><p>在旧版本C中，如果想建立一个常量，必须使用预处理器</p>
<p>#define MAX 1024;</p>
<p>定义的宏MAX从未被编译器看到过，因为在预处理阶段，所有的MAX已经被替换为了1024，于是MAX并没有将其加入到符号表中。但使用这个常量获得一个编译错误信息时，可能会带来一些困惑，因为这个信息可能会提到1024，但是并没有提到MAX。如果MAX被定义在一个不是你写的头文件中，你可能并不知道1024代表什么，也许解决这个问题要花费很长时间。</p>
<p>解决办法就是用一个常量替换上面的宏。</p>
<p>const int max&#x3D; 1024;</p>
<h3 id="3-1、const和-define相同之处"><a href="#3-1、const和-define相同之处" class="headerlink" title="3.1、const和#define相同之处"></a>3.1、const和#define相同之处</h3><p>C++中的const修饰的，是一个真正的常量，而不是C中变量（只读）。在const修饰的常量编译期间，就已经确定下来了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#define N 10 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">1</span>; </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b = <span class="number">2</span>; </span><br><span class="line">    <span class="type">int</span> array[a + b ] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;(a+b); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;array[%d] = %d\n&quot;</span>, i, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2、const和-define的区别"><a href="#3-2、const和-define的区别" class="headerlink" title="3.2、const和#define的区别"></a>3.2、const和#define的区别</h3><p>C++中的const常量类似于宏定义，const int c &#x3D; 5; 等价于 #define c 5</p>
<p>C++中的const常量与宏定义不同，const常量是由编译器处理的，提供类型检查和作用域检查 ，宏定义由预处理器处理，单纯的文本替换</p>
<ul>
<li><p>const有类型，可进行编译器类型安全检查。#define无类型，不可进行类型检查.</p>
</li>
<li><p>const有作用域，而#define不重视作用域，默认定义处到文件结尾.如果定义在指定作用域下有效的常量，那么#define就不能用。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PARAM 128</span></span><br><span class="line"><span class="type">const</span> <span class="type">short</span> param = <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">short</span> a)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;short!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;int&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>宏常量没有类型，所以调用了int类型重载的函数。const有类型，所以调用希望的short类型函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> A 20 </span></span><br><span class="line">    <span class="comment">//#undef A  //卸载宏常量A</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl; //不可访问，超出了const int a作用域</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A:&quot;</span> &lt;&lt; A &lt;&lt; endl; <span class="comment">//#define作用域从定义到文件结束或者到#undef，可访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">func2</span>();</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>宏常量不重视作用域.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MySpace&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> num 1024</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; MySpace::NUM &lt;&lt; endl; //错误</span></span><br><span class="line">	<span class="comment">//int num = 100; //命名冲突</span></span><br><span class="line">	cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>宏常量没有命名空间</p>
<p>综上得到结论：<strong>尽量以const替换#define</strong></p>
]]></content>
      <categories>
        <category>技术</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++对C的扩展</title>
    <url>/2022/08/31/C-%E5%AF%B9C%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-对C的扩展"><a href="#C-对C的扩展" class="headerlink" title="C++对C的扩展"></a>C++对C的扩展</h1><h2 id="1、命名空间"><a href="#1、命名空间" class="headerlink" title="1、命名空间"></a>1、命名空间</h2><h3 id="1-1、命名空间（namespace）"><a href="#1-1、命名空间（namespace）" class="headerlink" title="1.1、命名空间（namespace）"></a>1.1、命名空间（namespace）</h3><p>在c++中，名称（name）可以是符号常量、变量、函数、结构、枚举、类和对象等等。<span id="more"></span>工程越大，名称互相冲突性的可能性越大。另外使用多个厂商的类库时，也可能导致名称冲突。为了避免，在大规模程序的设计中，以及在程序员使用各种各样的C++库时，这些标识符的命名发生冲突，标准C++引入关键字namespace（命名空间&#x2F;名字空间&#x2F;名称空间），可以更好地控制标识符的作用域。C++标准程序库中的所有标识符都被定义于一个名为std的namespace中。</p>
<ul>
<li><p><iostream>和&lt;iostream.h&gt;格式不一样，前者没有后缀，实际上，在你的编译器include文件夹里面可以看到，二者是两个文件，打开文件就会发现，里面的代码是不一样的。后缀为.h的头文件c++标准已经明确提出不支持了，早些的实现将标准库功能定义在全局空间里，声明在带.h后缀的头文件里，c++标准为了和C区别开，也为了正确使用命名空间，规定头文件不使用后缀.h。 因此</p>
<p>1）当使用&lt;iostream.h&gt;时，相当于在c中调用库函数，使用的是全局命名空间，也就是早期的c++实现；</p>
<p>2）当使用<iostream>的时候，该头文件没有定义全局命名空间，必须使用namespace std；这样才能正确使用cout。</p>
</li>
<li><p>由于namespace的概念，使用C++标准程序库的任何标识符时，可以有三种选择：</p>
<p>1）直接指定标识符。例如std::ostream而不是ostream。完整语句如下： std::cout &lt;&lt; std::hex &lt;&lt; 3.4 &lt;&lt; std::endl;</p>
<p>2）使用using关键字。 using std::cout; using std::endl; using std::cin; 以上程序可以写成 cout &lt;&lt; std::hex &lt;&lt; 3.4 &lt;&lt; endl;</p>
<p>3）最方便的就是使用using namespace std; 例如： using namespace std;这样命名空间std内定义的所有标识符都有效（曝光）。就好像它们被声明为全局变量一样。那么以上语句可以如下写: cout &lt;&lt;hex &lt;&lt; 3.4 &lt;&lt; endl;因为标准库非常的庞大，所以程序员在选择的类的名称或函数名 时就很有可能和标准库中的某个名字相同。所以为了避免这种情况所造成的名字冲突，就把标准库中的一切都被放在名字空间std中。但这又会带来了一个新问 题。无数原有的C++代码都依赖于使用了多年的伪标准库中的功能，他们都是在全局空间下的。所以就有了&lt;iostream.h&gt; 和<iostream>等等这样的头文件，一个是为了兼容以前的C++代码，一个是为了支持新的标准。命名空间std封装的是标准程序库的名称，标准程序库为了和以前的头文件区别，一般不加”.h”</p>
</li>
</ul>
<h3 id="1-2、namespace语法"><a href="#1-2、namespace语法" class="headerlink" title="1.2、namespace语法"></a>1.2、namespace语法</h3><ul>
<li><p>创建命名空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;B::a : &quot;</span> &lt;&lt; B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>命名空间只能全局范围内定义（以下写法错误）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">namespace</span> A&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">namespace</span> B&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;B::a : &quot;</span> &lt;&lt; B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>命名空间可嵌套命名空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">namespace</span> B&#123;</span><br><span class="line">		<span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::B::a : &quot;</span> &lt;&lt; A::B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>命名空间是开放的，即可以随时把新的成员加入已有的命名空间中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;hello namespace!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">	A::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>声明和实现分离</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MySpace&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> param)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySpace::func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;MySpace::func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySpace::func2</span><span class="params">(<span class="type">int</span> param)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;MySpace::func2 : &quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>无名命名空间，该命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了static，使得其可以作为内部连接</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello namespace&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a : &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>命名空间别名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> veryLongName&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello namespace&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">namespace</span> shortName = veryLongName;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;veryLongName::a : &quot;</span> &lt;&lt; shortName::a &lt;&lt; endl;</span><br><span class="line">	veryLongName::<span class="built_in">func</span>();</span><br><span class="line">	shortName::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-3、命名空间的使用（using声明）"><a href="#1-3、命名空间的使用（using声明）" class="headerlink" title="1.3、命名空间的使用（using声明）"></a>1.3、命名空间的使用（using声明）</h3><ul>
<li><p>using声明可使得指定的标识符可用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="type">int</span> paramA = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> paramB = <span class="number">30</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcA&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcA&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//1. 通过命名空间域运算符</span></span><br><span class="line">	cout &lt;&lt; A::paramA &lt;&lt; endl;</span><br><span class="line">	A::<span class="built_in">funcA</span>();</span><br><span class="line">	<span class="comment">//2. using声明</span></span><br><span class="line">	<span class="keyword">using</span> A::paramA;</span><br><span class="line">	<span class="keyword">using</span> A::funcA;</span><br><span class="line">	cout &lt;&lt; paramA &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; paramB &lt;&lt; endl; //不可直接访问</span></span><br><span class="line">	<span class="built_in">funcA</span>();</span><br><span class="line">	<span class="comment">//3. 同名冲突</span></span><br><span class="line">	<span class="comment">//int paramA = 20; //相同作用域注意同名冲突</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>using声明碰到函数重载，如果命名空间包含一组用相同名字重载的函数，using声明就声明了这个重载函数的所有集合</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span>  <span class="title">func</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> A::func;</span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>using编译指令使整个命名空间标识符可用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="type">int</span> paramA = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> paramB = <span class="number">30</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcA&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcB&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">	cout &lt;&lt; paramA &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; paramB &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">funcA</span>();</span><br><span class="line">	<span class="built_in">funcB</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//不会产生二义性</span></span><br><span class="line">	<span class="type">int</span> paramA = <span class="number">30</span>;</span><br><span class="line">	cout &lt;&lt; paramA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line">	<span class="type">int</span> paramA = <span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> paramB = <span class="number">30</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcA&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello funcB&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> B;</span><br><span class="line">	<span class="comment">//二义性产生，不知道调用A还是B的paramA</span></span><br><span class="line">    <span class="comment">//这时可以使用作用域解析运算符，则不会出现二义性</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; paramA &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2、全局变量检测增强"><a href="#2、全局变量检测增强" class="headerlink" title="2、全局变量检测增强"></a>2、全局变量检测增强</h2><p>​	如下C语言代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//赋值，当做定义</span></span><br><span class="line"><span class="type">int</span> a; <span class="comment">//没有赋值，当做声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a:%d\n&quot;</span>,a);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码在c++下编译失败,在c下编译通过。</p>
<p>在C语言中，重复定义多个同名的全局变量是合法的。在C++中，不允许定义多个同名的全局变量。C语言中多个同名的全局变量最终会被链接到全局数据区的同一个地址空间上。C++直接拒绝这种二义性的做法。</p>
<h2 id="3、更严格的类型要求"><a href="#3、更严格的类型要求" class="headerlink" title="3、更严格的类型要求"></a>3、更严格的类型要求</h2><h3 id="3-1、C-中所有的变量和函数都必须有类型"><a href="#3-1、C-中所有的变量和函数都必须有类型" class="headerlink" title="3.1、C++中所有的变量和函数都必须有类型"></a>3.1、C++中所有的变量和函数都必须有类型</h3><p>C语言中的默认类型在C++中是不合法的，C++中所有的变量和函数都必须有类型。如下C语言代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//i没有写类型，可以是任意类型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun1</span><span class="params">(i)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i没有写类型，可以是任意类型</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun2</span><span class="params">(i)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有写参数，代表可以传任何类型的实参</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun3</span><span class="params">()</span>&#123; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fun33333333333333333\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C语言，如果函数没有参数，建议写void，代表没有参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun4</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fun4444444444444\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g()&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">	fun1(<span class="number">10</span>);</span><br><span class="line">	fun2(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">	fun3(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;g = %d\n&quot;</span>, g());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更换成.cpp试试</span></span><br></pre></td></tr></table></figure>

<p>以上c代码c编译器编译可通过，c++编译器无法编译通过。</p>
<ul>
<li><p>在C语言中，int fun() 表示返回值为int，接受任意参数的函数，int fun(void) 表示返回值为int的无参函数。</p>
</li>
<li><p>在C++ 中，int fun() 和int fun(void) 具有相同的意义，都表示返回值为int的无参函数。</p>
<p>C++更加强调类型，任意的程序元素都必须显示指明类型</p>
</li>
</ul>
<h3 id="3-2、更严格的类型转换"><a href="#3-2、更严格的类型转换" class="headerlink" title="3.2、更严格的类型转换"></a>3.2、更严格的类型转换</h3><p>在C++，不同类型的变量一般是不能直接赋值的，需要相应的强转。如下C语言代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">COLOR</span>&#123;</span> GREEN, RED, YELLOW &#125; color;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">	color mycolor = GREEN;</span><br><span class="line">	mycolor = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;mycolor:%d\n&quot;</span>, mycolor);</span><br><span class="line">	<span class="type">char</span>* p = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更换成.cpp试试</span></span><br></pre></td></tr></table></figure>

<p>以上c代码c编译器编译可通过，c++编译器无法编译通过</p>
<h2 id="4、struct类型增强"><a href="#4、struct类型增强" class="headerlink" title="4、struct类型增强"></a>4、struct类型增强</h2><ul>
<li><p>C语言的struct定义了一组变量的集合，C编译器并不认为这是一种新的类型。C++中的struct是一个新类型的定义声明。</p>
</li>
<li><p>C中定义结构体变量需要加上struct关键字，c++不需要</p>
<p>如以下C++代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 结构体中即可以定义成员变量，也可以定义成员函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	string mName;</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span></span>&#123; mName = name; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span></span>&#123; mAge = age; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. c++中定义结构体变量不需要加struct关键字</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Student student;</span><br><span class="line">	student.<span class="built_in">setName</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">	student.<span class="built_in">setAge</span>(<span class="number">20</span>);</span><br><span class="line">	student.<span class="built_in">showStudent</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5、bool类型关键字"><a href="#5、bool类型关键字" class="headerlink" title="5、bool类型关键字"></a>5、bool类型关键字</h2><p>标准c++的bool类型有两种内建的常量true(转换为整数1)和false(转换为整数0)表示状态。这三个名字都是关键字。</p>
<ul>
<li><p>bool类型只有两个值，true(1值)，false(0值)</p>
</li>
<li><p>bool类型占1个字节大小</p>
</li>
<li><p>给bool类型赋值时，非0值会自动转换为true(1)，0值会自动转换false(0)</p>
</li>
</ul>
<p>理论上bool只占用一个字节，如果多个bool变量定义在一起，可能会各占一个bit，这取决于编译器的实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">bool</span> b = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b = %d, sizeof(b) = %d\n&quot;</span>, b, <span class="built_in">sizeof</span>(b));</span><br><span class="line"></span><br><span class="line">	b = <span class="number">4</span>;</span><br><span class="line">	a = b;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">	b = <span class="number">-4</span>;</span><br><span class="line">	a = b;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">	a = <span class="number">10</span>;</span><br><span class="line">	b = a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="literal">false</span>) &lt;&lt; endl; <span class="comment">//为1，//bool类型占一个字节大小</span></span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>; <span class="comment">// c语言中没有这种类型</span></span><br><span class="line">	flag = <span class="number">100</span>; <span class="comment">//给bool类型赋值时，非0值会自动转换为true(1),0值会自动转换false(0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意的是，c语言中也有bool类型，在c99标准之前是没有bool关键字，c99标准已经有bool类型，包含头文件stdbool.h，就可以使用和c++一样的bool类型。</p>
<h2 id="6、三目运算符功能增强"><a href="#6、三目运算符功能增强" class="headerlink" title="6、三目运算符功能增强"></a>6、三目运算符功能增强</h2><ul>
<li><p>C语言三目运算表达式返回值为数据值，为右值，不能赋值。如下C代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ret:%d\n&quot;</span>, a &gt; b ? a : b);</span><br><span class="line"><span class="comment">//思考一个问题，(a &gt; b ? a : b) 三目运算表达式返回的是什么？</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//(a &gt; b ? a : b) = 100;</span></span><br><span class="line"><span class="comment">//返回的是右值</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>C++语言三目运算表达式返回值为变量本身(引用)，为左值，可以赋值。如下C++代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ret:%d\n&quot;</span>, a &gt; b ? a : b);</span><br><span class="line"><span class="comment">//思考一个问题，(a &gt; b ? a : b) 三目运算表达式返回的是什么？</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//返回的是左值，变量的引用</span></span><br><span class="line">(a &gt; b ? a : b) = <span class="number">100</span>;<span class="comment">//返回的是左值，变量的引用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>注意：三目运算符可能返回的值中如果有一个是常量值，则不能作为左值使用，如 (a &lt; b ? 1 : b )&#x3D; 30;</p>
</li>
</ul>
<p><strong>左值和右值：</strong></p>
<p>在c++中可以放在赋值操作符左边的是左值，可以放到赋值操作符右面的是右值。</p>
<p>有些变量即可以当左值，也可以当右值。</p>
<p>左值为Lvalue，L代表Location，表示内存可以寻址，可以赋值。</p>
<p>右值为Rvalue，R代表Read,就是可以知道它的值。</p>
<p>比如:int temp &#x3D; 10; temp在内存中有地址，10没有，但是可以Read到它的值。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++概述</title>
    <url>/2022/08/31/C-%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-概述"><a href="#C-概述" class="headerlink" title="C++概述"></a>C++概述</h1><h2 id="1、C-简介"><a href="#1、C-简介" class="headerlink" title="1、C++简介"></a>1、C++简介</h2><p>“C++”中的++来自于C语言中的递增运算符++，该运算符将变量加1。C++起初也叫”c with clsss”.通过名称表明，C++是对C的扩展，因此C++是c语言的超集，这意味着任何有效的c程序都是有效的c++程序。c++程序可以使用已有的c程序库。库是编程模块的集合，可以在程序中调用它们。库对很多常见的编程问题提供了可靠的解决方法，因此可以节省程序员大量的时间和工作量。<span id="more"></span></p>
<p>​C++语言在c语言的基础上添加了面向对象编程和泛型编程的支持。C++继承了c语言高效，简洁，快速和可移植的传统。C++融合了3种不同的编程方式:</p>
<ul>
<li><p>C语言代表的过程新语言。</p>
</li>
<li><p>C++在C语言基础上添加的类代表的面向对象语言。</p>
</li>
<li><p>C++模板支持的泛型编程。</p>
</li>
</ul>
<p>C语言和C++语言的关系：</p>
<p>C++语言是在C语言的基础上，添加了面向对象、模板等现代程序设计语言的特性而发展起来的。两者无论是从语法规则上，还是从运算符的数量和使用上，都非常相似，所以我们常常将这两门语言统称为“C&#x2F;C++”。</p>
<ol>
<li><p>C++是C语言的加强，是一种更好的C语言。</p>
</li>
<li><p>C++是以C语言为基础的，并且完全兼容C语言的特性。</p>
</li>
</ol>
<p>C语言和C++语言的学习是可以相互促进。学好C语言，可以为我们将来进一步地学习C++语言打好基础，而C++语言的学习，也会促进我们对于C语言的理解，从而更好地运用C语言。</p>
<h3 id="1-1、c-的起源"><a href="#1-1、c-的起源" class="headerlink" title="1.1、c++的起源"></a>1.1、c++的起源</h3><p>与c语言一样，c++也是在贝尔实验室诞生的，Bjarne Stroustrup(本贾尼·斯特劳斯特卢普)在20世纪80年代在这里开发了这种语言。</p>
<p><img src="https://pic.imgdb.cn/item/630eba8f16f2c2beb16d9591.jpg"></p>
<p>Stroustrup关心的是让c++更有用，而不是实施特定的编程原理或风格。在确定语言特性方面，真正的编程比纯粹的原理更重要。Stroustrup之所以在c的基础上创建c++,是因为c语言简洁、适合系统编程、使用广泛且与UNIX操作系统联系紧密。用他自己的话来说，“C++主要是为了我的朋友和我不必再使用汇编语言、C语言或者其他现代高级语言来编程而设计的。它的主要功能是可以更方便得编写出好程序，让每个程序员更加快乐”。</p>
<h3 id="1-2、可移植性和标准"><a href="#1-2、可移植性和标准" class="headerlink" title="1.2、可移植性和标准"></a>1.2、可移植性和标准</h3><p>假设为运行windows 2000的老式奔腾pc编写了一个很好用的c++程序，而管理员决定使用不同操作系统(比如说Mac OS 或 Linux)和处理器的计算机替换它。该程序是否可在新平台运行呢？当然，但是必须使用为新平台设计的c++编译器重新编译。但是是否需要修改写好的代码？如果不需要修改代码的情况下，重新编译程序后，程序依然运行良好，该程序是可移植的。</p>
<p>​程序是否可移植性有两个问题需要解决。第一是硬件，针对特定硬件编程的程序是不可移植的。第二，语言的实现，windows xp c++ 和 Redhat Linux 或 Mac OS X对c++的实现不一定相同。虽然我们希望c++版本与其他版本兼容，但是如果没有一个公开的标准，很难做到。因此，美国国家标准局(American National Standards Institute,ANSI)在1990年设立一个委员会专门负责制定c++标准(ANSI制定了c语言的标准)。国际标准化组织(International Organization for Standardization，ISO)很快通过自己的委员会加入到这个行列，创建了联合组织ANSI&#x2F;ISO,制定c++标准。</p>
<p>​经过多年的努力，制定出了一个国际标准ISO&#x2F;IEC 14882:1998 ，并于1998年获得了ISO、IEC(International  Electrotechnical Committee,国际电工技术委员会)和ANSI的批准。这个标准就是我们经常所说的c++98。它不仅描述了已有的c++特性，还对语言进行了扩展，添加了异常、运行阶段类型识别(RTTI)、模板和标准模板库(STL).</p>
<p>​2003年，发布了c++标准第二版(IOS&#x2F;IEC 14882:2003),这一版本对第一版修订了一些错误，但并没有改变语言特性，因此c++98表示c++98&#x2F;c++2003.</p>
<p>​c++不断发展。IOS标准委员会于2011年8月批准了新标准ISO&#x2F;IEC 14882:2011,该标准被称为c++11,与c++98一样c++11也新增了许多特性。</p>
<p>​ISO c++标准还吸收了ANSI c语言标准，c++尽量做到是c的超集。意味着在理想情况下，任何有效的c程序都应该是有效的c++程序。</p>
<p>​ANSI不仅定义了c语言，还 定义了一个ANSI c必须实现的标准c库。c++也在使用这个库，另外ANSI&#x2F;ISO c++标准还提供了一个c++标准类库。</p>
<h2 id="2、C-初识"><a href="#2、C-初识" class="headerlink" title="2、C++初识"></a>2、C++初识</h2><h3 id="2-1、c-hello-world"><a href="#2-1、c-hello-world" class="headerlink" title="2.1、c++ hello world"></a>2.1、c++ hello world</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hellow world&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ul>
<li><p>#include<iostream>; 预编译指令，引入头文件iostream.</p>
</li>
<li><p>using namespace std; 使用标准命名空间</p>
</li>
<li><p>cout &lt;&lt; “hello world”&lt;&lt; endl; 和printf功能一样，输出字符串”hello wrold”</p>
</li>
</ul>
<p>问题1：c++头文件为什么没有.h？</p>
<p>在c语言中头文件使用扩展名.h,将其作为一种通过名称标识文件类型的简单方式。但是c++得用法改变了，c++头文件没有扩展名。但是有些c语言的头文件被转换为c++的头文件，这些文件被重新命名，丢掉了扩展名.h(使之成为c++风格头文件)，并在文件名称前面加上前缀c(表明来自c语言)。例如c++版本的math.h为cmath。由于C使用不同的扩展名来表示不同文件类型，因此用一些特殊的扩展名(如hpp或hxx)表示c++的头文件也是可以的，ANSI&#x2F;IOS标准委员会也认为是可以的，但是关键问题是用哪个比较好，最后一致同意不适用任何扩展名。</p>
<p><img src="https://pic.imgdb.cn/item/630ebad016f2c2beb16db3d7.jpg"></p>
<p>问题2：using namespace std 是什么?</p>
<p>namespace是指标识符的各种可见范围。命名空间用关键字namespace 来定义。命名空间是C++的一种机制，用来把单个标识符下的大量有逻辑联系的程序实体组合到一起。此标识符作为此组群的名字。</p>
<p>问题3：cout 、endl 是什么？</p>
<p>cout是c++中的标准输出流，endl是输出换行并刷新缓冲区。</p>
<h3 id="2-2、程序设计方法"><a href="#2-2、程序设计方法" class="headerlink" title="2.2、程序设计方法"></a>2.2、程序设计方法</h3><p>1）面向过程</p>
<p>面向过程是一种以过程为中心的编程思想。通过分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。面向过程编程思想的核心：功能分解，自顶向下，逐层细化（程序&#x3D;数据结构+算法）。面向过程编程语言存在的主要缺点是不符合人的思维习惯，而是要用计算机的思维方式去处理问题，而且面向过程编程语言重用性低，维护困难。</p>
<p>2）面向对象编程（Object-Oriented Programming）</p>
<p>​面向对象编程简称 OOP 技术，是开发计算机应用程序的一种新方法、新思想。过去的面向过程编程常常会导致所有的代码都包含在几个模块中，使程序难以阅读和维护。在做一些修改时常常牵一动百，使以后的开发和维护难以为继。而使用 OOP 技术，常常要使用许多代码模块，每个模块都只提供特定的功能，它们是彼此独立的，这样就增大了代码重用的几率，更加有利于软件的开发、维护和升级。在面向对象中，算法与数据结构被看做是一个整体，称作对象，现实世界中任何类的对象都具有一定的属性和操作，也总能用数据结构与算法两者合一地来描述，所以可以用下面的等式来定义对象和程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">对象 = 算法 + 数据结构</span><br><span class="line">程序 = 对象 + 对象 + ……</span><br></pre></td></tr></table></figure>

<p>从上面的等式可以看出，程序就是许多对象在计算机中相继表现自己，而对象则是一个个程序实体。 面向对象编程思想的核心：应对变化，提高复用。</p>
<h3 id="2-3、程序设计方法的发展历程"><a href="#2-3、程序设计方法的发展历程" class="headerlink" title="2.3、程序设计方法的发展历程"></a>2.3、程序设计方法的发展历程</h3><p>面向过程的结构化程序设计方法</p>
<ul>
<li><p>设计思路：</p>
<ul>
<li>自顶向下、逐步求精。采用模块分解与功能抽象，自顶向下、分而治之。</li>
</ul>
</li>
<li><p>程序结构：</p>
<ul>
<li><p>按功能划分为若干个基本模块，形成一个树状结构。</p>
</li>
<li><p>各模块间的关系尽可能简单，功能上相对独立；每一模块内部均是由顺序、选择和循环三种基本结构组成。</p>
</li>
<li><p>其模块化实现的具体方法是使用子程序。</p>
</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>有效地将一个较复杂的程序系统设计任务分解成许多易于控制和处理的子任务，便于开发和维护。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p>可重用性差、数据安全性差、难以开发大型软件和图形界面的应用软件</p>
</li>
<li><p>把数据和处理数据的过程分离为相互独立的实体。</p>
</li>
<li><p>当数据结构改变时，所有相关的处理过程都要进行相应的修改。</p>
</li>
<li><p>每一种相对于老问题的新方法都要带来额外的开销。</p>
</li>
<li><p>图形用户界面的应用程序，很难用过程来描述和实现，开发和维护也都很困难。</p>
</li>
</ul>
</li>
</ul>
<p>面向对象的方法</p>
<ul>
<li><p>将数据及对数据的操作方法封装在一起，作为一个相互依存、不可分离的整体——对象。</p>
</li>
<li><p>对同类型对象抽象出其共性，形成类。</p>
</li>
<li><p>类通过一个简单的外部接口，与外界发生关系。</p>
</li>
<li><p>对象与对象之间通过消息进行通信。</p>
</li>
</ul>
<p> 面向对象的基本概念</p>
<p> <em><strong>对象</strong></em></p>
<ul>
<li><p>一般意义上的对象：</p>
<ul>
<li><p>是现实世界中一个实际存在的事物。</p>
</li>
<li><p>可以是有形的（比如一辆汽车），也可以是无形的（比如一项计划）。</p>
</li>
<li><p>是构成世界的一个独立单位，具有</p>
</li>
</ul>
</li>
<li><p>静态特征：可以用某种数据来描述</p>
</li>
<li><p>动态特征：对象所表现的行为或具有的功能</p>
</li>
<li><p>面向对象方法中的对象：</p>
<ul>
<li><p>是系统中用来描述客观事物的一个实体，它是用来构成系统的一个基本单位。对象由一组属性和一组行为构成。</p>
</li>
<li><p>属性：用来描述对象静态特征的数据项。</p>
</li>
<li><p>行为：用来描述对象动态特征的操作序列。</p>
</li>
</ul>
</li>
</ul>
<p><em><strong>类</strong></em></p>
<ul>
<li><p>分类——人类通常的思维方法</p>
</li>
<li><p>分类所依据的原则——抽象</p>
<ul>
<li><p>忽略事物的非本质特征，只注意那些与当前目标有关的本质特征，从而找出事物的共性，把具有共同性质的事物划分为一类，得出一个抽象的概念。</p>
</li>
<li><p>例如，石头、树木、汽车、房屋等都是人们在长期的生产和生活实践中抽象出的概念。</p>
</li>
</ul>
</li>
<li><p>面向对象方法中的”类”</p>
<ul>
<li><p>具有相同属性和服务的一组对象的集合</p>
</li>
<li><p>为属于该类的全部对象提供了抽象的描述，包括属性和行为两个主要部分。</p>
</li>
<li><p>类与对象的关系：<br>犹如模具与铸件之间的关系，一个属于某类的对象称为该类的一个实例。</p>
</li>
</ul>
</li>
</ul>
<p><em><strong>封装</strong></em></p>
<p>也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p>
<ul>
<li><p>把对象的属性和服务结合成一个独立的系统单元。</p>
</li>
<li><p>尽可能隐蔽对象的内部细节。对外形成一个边界（或者说一道屏障），只保留有限的对外接口使之与外部发生联系。</p>
</li>
<li><p>继承对于软件复用有着重要意义，是面向对象技术能够提高软件开发效率的重要原因之一。</p>
<p>定义：特殊类的对象拥有其一般类的全部属性与服务，称作特殊类对一般类的继承。</p>
<p>例如：将轮船作为一个一般类，客轮便是一个特殊类。</p>
</li>
</ul>
<p><em><strong>多态</strong></em></p>
<p>多态是指在一般类中定义的属性或行为，被特殊类继承之后，可以具有不同的数据类型或表现出不同的行为。这使得同一个属性或行为在一般类及其各个特殊类中具有不同的语义。</p>
<p>面向对象的软件工程</p>
<ul>
<li><p>面向对象的软件工程是面向对象方法在软件工程领域的全面应用。它包括:</p>
<ul>
<li><p>面向对象的分析（OOA）</p>
</li>
<li><p>面向对象的设计（OOD）</p>
</li>
<li><p>面向对象的编程（OOP）</p>
</li>
<li><p>面向对象的测试（OOT）</p>
</li>
<li><p>面向对象的软件维护（OOSM）</p>
</li>
</ul>
</li>
</ul>
<hr>
<p> 总结：</p>
<p><strong>面向过程程序设计：数据结构 + 算法</strong></p>
<p>主要解决科学计算问题，用户需求简单而固定</p>
<p>特点：</p>
<ul>
<li><p>分析解决问题所需要的步骤</p>
</li>
<li><p>利用函数实现各个步骤</p>
</li>
<li><p>依次调用函数解决问题</p>
</li>
</ul>
<p>问题：软件可重用性差、软件可维护性差、构建的软件无法满足用户需求</p>
<p>面向对象程序设计：由现实世界建立软件模型</p>
<p>将现实世界中的事物直接映射到程序中，可直接满足用户需求</p>
<p>特点：</p>
<ul>
<li><p>直接分析用户需求中涉及的各个实体</p>
</li>
<li><p>在代码中描述现实世界中的实体</p>
</li>
<li><p>在代码中关联各个实体协同工作解决问题</p>
</li>
</ul>
<p>优势：</p>
<ul>
<li><p>构建的软件能够适应用户需求的不断变化</p>
</li>
<li><p>直接利用面向过程方法的优势而避开其劣势</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/08/26/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
