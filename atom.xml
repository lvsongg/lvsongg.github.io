<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lv blog</title>
  
  <subtitle>越努力，越幸运</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-09-06T08:32:34.682Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Lv Song</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>STL算法-常用算法介绍</title>
    <link href="http://example.com/2022/09/06/STL%E7%AE%97%E6%B3%95-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2022/09/06/STL%E7%AE%97%E6%B3%95-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-09-06T03:31:36.000Z</published>
    <updated>2022-09-06T08:32:34.682Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="STL容器-常用算法介绍"><a href="#STL容器-常用算法介绍" class="headerlink" title="STL容器-常用算法介绍"></a>STL容器-常用算法介绍</h1><h2 id="1、常用的查找算法"><a href="#1、常用的查找算法" class="headerlink" title="1、常用的查找算法"></a>1、常用的查找算法</h2><h3 id="1-1、adjacent-find"><a href="#1-1、adjacent-find" class="headerlink" title="1.1、adjacent_find()"></a>1.1、adjacent_find()</h3><p>在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的迭代器。否则返回past-the-end。<span id="more"></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vecInt;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(vecInt.<span class="built_in">begin</span>(), vecInt.<span class="built_in">end</span>());<span class="comment">//*it == 2</span></span><br></pre></td></tr></table></figure><h3 id="1-2、binary-search"><a href="#1-2、binary-search" class="headerlink" title="1.2、binary_search()"></a>1.2、binary_search()</h3><p>在有序序列中查找value,找到则返回true。注意：在无序序列中，不可使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; setInt;</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> bFind = <span class="built_in">binary_search</span>(setInt.<span class="built_in">begin</span>(),setInt.<span class="built_in">end</span>(),<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h3 id="1-3、count"><a href="#1-3、count" class="headerlink" title="1.3、count()"></a>1.3、count()</h3><p>利用等于操作符，把标志范围内的元素与输入值比较，返回相等的个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vecInt;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> iCount = <span class="built_in">count</span>(vecInt.<span class="built_in">begin</span>(),vecInt.<span class="built_in">end</span>(),<span class="number">2</span>);<span class="comment">//iCount==3</span></span><br></pre></td></tr></table></figure><h3 id="1-4、count-if"><a href="#1-4、count-if" class="headerlink" title="1.4、count_if()"></a>1.4、count_if()</h3><p>假设vector<int> vecIntA，vecIntA包含1,3,5,7,9元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先定义比较函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GreaterThree</span><span class="params">(<span class="type">int</span> iNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(iNum&gt;=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> iCount = <span class="built_in">count_if</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), GreaterThree);</span><br><span class="line"><span class="comment">//此时iCount == 4</span></span><br></pre></td></tr></table></figure><h3 id="1-5、find"><a href="#1-5、find" class="headerlink" title="1.5、find()"></a>1.5、find()</h3><ul><li><strong>find</strong>: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的迭代器。</li><li><strong>equal_range</strong>: 返回一对iterator，第一个表示lower_bound,第二个表示upper_bound。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vecInt;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(vecInt.<span class="built_in">begin</span>(), vecInt.<span class="built_in">end</span>(), <span class="number">5</span>);<span class="comment">//*it == 5</span></span><br></pre></td></tr></table></figure><h3 id="1-6、find-if"><a href="#1-6、find-if" class="headerlink" title="1.6、find_if()"></a>1.6、find_if()</h3><ul><li><strong>find_if</strong>: 使用输入的函数代替等于操作符执行find。返回被找到的元素的迭代器。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设vector&lt;<span class="type">int</span>&gt; vecIntA，vecIntA包含<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">9</span>元素 </span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::it = <span class="built_in">find_if</span>(vecInt.<span class="built_in">begin</span>(),vecInt.<span class="built_in">end</span>(),GreaterThree);</span><br><span class="line"><span class="comment">//此时 *it==3, *(it+1)==5, *(it+2)==3, *(it+3)==9</span></span><br></pre></td></tr></table></figure><h2 id="2、-常用的排序算法"><a href="#2、-常用的排序算法" class="headerlink" title="2、 常用的排序算法"></a>2、 常用的排序算法</h2><p>以下是排序和通用算法：提供元素排序策略</p><h3 id="2-1、merge"><a href="#2-1、merge" class="headerlink" title="2.1、merge()"></a>2.1、merge()</h3><ul><li><strong>merge</strong>: 合并两个有序序列，存放到另一个序列。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：vecIntA,vecIntB,vecIntC是用vector&lt;<span class="type">int</span>&gt;声明的容器，vecIntA已包含<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>元素，vecIntB已包含<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>元素</span><br><span class="line">vecIntC.<span class="built_in">resize</span>(<span class="number">9</span>);  <span class="comment">//扩大容量</span></span><br><span class="line"><span class="built_in">merge</span>(vecIntA.<span class="built_in">begin</span>(),vecIntA.<span class="built_in">end</span>(),vecIntB.<span class="built_in">begin</span>(),vecIntB.<span class="built_in">end</span>(),vecIntC.<span class="built_in">begin</span>());</span><br><span class="line"><span class="comment">//此时vecIntC就存放了按顺序的1,2,3,4,5,6,7,8,9九个元素</span></span><br></pre></td></tr></table></figure><h3 id="2-2、sort"><a href="#2-2、sort" class="headerlink" title="2.2、sort()"></a>2.2、sort()</h3><ul><li><strong>sort</strong>: 以默认升序的方式重新排列指定范围内的元素。若要改排序规则，可以输入比较函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line">Class CStudent:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CStudent</span>(<span class="type">int</span> iID, string strName)</span><br><span class="line">    &#123;</span><br><span class="line">        m_iID=iID;  </span><br><span class="line">        m_strName=strName; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:            </span><br><span class="line">    <span class="type">int</span> m_iID;</span><br><span class="line">    string m_strName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学号比较函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Compare</span><span class="params">(<span class="type">const</span> CStudent &amp;stuA, <span class="type">const</span> CStudent &amp;stuB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (stuA.m_iID &lt; strB.m_iID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;CStudent&gt; vecStu;</span><br><span class="line">    vecStu.<span class="built_in">push_back</span>(<span class="built_in">CStudent</span>(<span class="number">2</span>,<span class="string">&quot;老二&quot;</span>));</span><br><span class="line">    vecStu.<span class="built_in">push_back</span>(<span class="built_in">CStudent</span>(<span class="number">1</span>,<span class="string">&quot;老大&quot;</span>));</span><br><span class="line">    vecStu.<span class="built_in">push_back</span>(<span class="built_in">CStudent</span>(<span class="number">3</span>,<span class="string">&quot;老三&quot;</span>));</span><br><span class="line">    vecStu.<span class="built_in">push_back</span>(<span class="built_in">CStudent</span>(<span class="number">4</span>,<span class="string">&quot;老四&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(vecStu.<span class="built_in">begin</span>(), vecStu.<span class="built_in">end</span>(), Compare);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  此时，vecStu容器包含了按顺序的&quot;老大对象&quot;,&quot;老二对象&quot;,&quot;老三对象&quot;,&quot;老四对象&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3、random-shuffle"><a href="#2-3、random-shuffle" class="headerlink" title="2.3、random_shuffle()"></a>2.3、random_shuffle()</h3><ul><li><strong>random_shuffle</strong>: 对指定范围内的元素随机调整次序。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));<span class="comment">//设置随机种子</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecInt;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;itcastitcast &quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">random_shuffle</span>(vecInt.<span class="built_in">begin</span>(), vecInt.<span class="built_in">end</span>());   <span class="comment">//随机排序，结果比如：9,7,1,5,3</span></span><br><span class="line"><span class="built_in">random_shuffle</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());    <span class="comment">//随机排序，结果比如：&quot; itstcasticat &quot;</span></span><br><span class="line"><span class="built_in">reverse</span>() </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecInt;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">reverse</span>(vecInt.<span class="built_in">begin</span>(), vecInt.<span class="built_in">end</span>());    <span class="comment">//&#123;9,7,5,3,1&#125;</span></span><br><span class="line"><span class="built_in">random_shuffle</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());    <span class="comment">//随机排序，结果比如：&quot; itstcasticat &quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-4、reverse"><a href="#2-4、reverse" class="headerlink" title="2.4、reverse()"></a>2.4、reverse()</h3><ul><li><strong>reverse</strong>: 对指定范围内的元素次序反转。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>() </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecInt;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">reverse</span>(vecInt.<span class="built_in">begin</span>(), vecInt.<span class="built_in">end</span>());    <span class="comment">//&#123;9,7,5,3,1&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3、常用的拷贝和替换算法"><a href="#3、常用的拷贝和替换算法" class="headerlink" title="3、常用的拷贝和替换算法"></a>3、常用的拷贝和替换算法</h2><h3 id="3-1、copy"><a href="#3-1、copy" class="headerlink" title="3.1、copy()"></a>3.1、copy()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecIntB;</span><br><span class="line">vecIntB.<span class="built_in">resize</span>(<span class="number">5</span>);<span class="comment">//扩大空间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), vecIntB.<span class="built_in">begin</span>());<span class="comment">//vecIntB: &#123;1,3,5,7,9&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-2、replace"><a href="#3-2、replace" class="headerlink" title="3.2、replace()"></a>3.2、replace()</h3><ul><li><strong>replace(beg,end,oldValue,newValue)</strong>: 将指定范围内的所有等于oldValue的元素替换成newValue。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">replace</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), <span class="number">3</span>, <span class="number">8</span>);<span class="comment">//&#123;1,8,5,8,9&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-3、replace-if"><a href="#3-3、replace-if" class="headerlink" title="3.3、replace_if()"></a>3.3、replace_if()</h3><ul><li><strong>replace_if</strong>: 将指定范围内所有操作结果为true的元素用新值替换。<br>用法举例：<br><code>replace_if(vecIntA.begin(),vecIntA.end(),GreaterThree,newVal)</code><br>其中 vecIntA是用vector<int>声明的容器<br>GreaterThree 函数的原型是 bool GreaterThree(int iNum)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把大于等于3的元素替换成8</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">replace_if</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), GreaterThree, <span class="number">8</span>);<span class="comment">// GreaterThree的定义在上面。</span></span><br></pre></td></tr></table></figure><h3 id="3-4、swap"><a href="#3-4、swap" class="headerlink" title="3.4、swap()"></a>3.4、swap()</h3><ul><li><strong>swap</strong>: 交换两个容器的元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecIntB;</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(vecIntA, vecIntB);     <span class="comment">//交换</span></span><br></pre></td></tr></table></figure><h2 id="4、常用的算术和生成算法"><a href="#4、常用的算术和生成算法" class="headerlink" title="4、常用的算术和生成算法"></a>4、常用的算术和生成算法</h2><h3 id="4-1、accumulate"><a href="#4-1、accumulate" class="headerlink" title="4.1、accumulate()"></a>4.1、accumulate()</h3><ul><li><strong>accumulate</strong>: 对指定范围内的元素求和，然后结果再加上一个由val指定的初始值。</li><li><code>#include&lt;numeric&gt;</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> iSum = <span class="built_in">accumulate</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), <span class="number">100</span>);<span class="comment">//iSum==125</span></span><br></pre></td></tr></table></figure><h3 id="4-2、fill"><a href="#4-2、fill" class="headerlink" title="4.2、fill()"></a>4.2、fill()</h3><ul><li><strong>fill</strong>: 将输入值赋给标志范围内的所有元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fill</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), <span class="number">8</span>);<span class="comment">//8, 8, 8, 8, 8</span></span><br></pre></td></tr></table></figure><h2 id="5、常用的集合算法"><a href="#5、常用的集合算法" class="headerlink" title="5、常用的集合算法"></a>5、常用的集合算法</h2><h3 id="5-1、set-union-set-intersection-set-difference"><a href="#5-1、set-union-set-intersection-set-difference" class="headerlink" title="5.1、set_union(), set_intersection(), set_difference()"></a>5.1、set_union(), set_intersection(), set_difference()</h3><ul><li><strong>set_union</strong>: 构造一个有序序列，包含两个有序序列的并集。</li><li><strong>set_intersection</strong>: 构造一个有序序列，包含两个有序序列的交集。</li><li><strong>set_difference</strong>: 构造一个有序序列，该序列保留第一个有序序列中存在而第二个有序序列中不存在的元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vecIntA;</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecIntB;</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">vecIntB.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecIntC;</span><br><span class="line">vecIntC.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line"><span class="built_in">set_union</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), vecIntB.<span class="built_in">begin</span>(), vecIntB.<span class="built_in">end</span>(), vecIntC.<span class="built_in">begin</span>());<span class="comment">//vecIntC : &#123;1,3,5,6,7,8,9,0,0,0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line"><span class="built_in">fill</span>(vecIntC.<span class="built_in">begin</span>(),vecIntC.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line"><span class="built_in">set_intersection</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), vecIntB.<span class="built_in">begin</span>(), vecIntB.<span class="built_in">end</span>(), vecIntC.<span class="built_in">begin</span>());<span class="comment">//vecIntC: &#123;1,3,5,0,0,0,0,0,0,0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//差集</span></span><br><span class="line"><span class="built_in">fill</span>(vecIntC.<span class="built_in">begin</span>(),vecIntC.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line"><span class="built_in">set_difference</span>(vecIntA.<span class="built_in">begin</span>(), vecIntA.<span class="built_in">end</span>(), vecIntB.<span class="built_in">begin</span>(), vecIntB.<span class="built_in">end</span>(), vecIntC.<span class="built_in">begin</span>());<span class="comment">//vecIntC: &#123;7,9,0,0,0,0,0,0,0,0&#125;</span></span><br></pre></td></tr></table></figure><h2 id="6、常用的遍历算法"><a href="#6、常用的遍历算法" class="headerlink" title="6、常用的遍历算法"></a>6、常用的遍历算法</h2><h3 id="6-1、for-each"><a href="#6-1、for-each" class="headerlink" title="6.1、for_each()"></a>6.1、for_each()</h3><ul><li><strong>for_each</strong>: 用指定函数依次对指定范围内所有元素进行迭代访问。该函数不得修改序列中的元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;iItem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; iItem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> iArray[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vecInt</span><span class="params">(iArray,iArray+<span class="keyword">sizeof</span>(iArray)/<span class="keyword">sizeof</span>(iArray[<span class="number">0</span>]))</span></span>;</span><br><span class="line">    for_each(vecInt.<span class="built_in">begin</span>(), vecInt.<span class="built_in">end</span>(), show);</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果打印出0 1 2 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2、transform"><a href="#6-2、transform" class="headerlink" title="6.2、transform()"></a>6.2、transform()</h3><ul><li><strong>transform</strong>: 与for_each类似，遍历所有元素，但可对容器的元素进行修改</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">increase</span> <span class="params">(<span class="type">int</span> i)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>;   </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vecIntA;</span><br><span class="line">    vecIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    vecIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    vecIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    vecIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">    vecIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">transform</span>(vecIntA.<span class="built_in">begin</span>(),vecIntA.<span class="built_in">end</span>(),vecIntA.<span class="built_in">begin</span>(),increase);<span class="comment">//vecIntA : &#123;2,4,6,8,10&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;STL容器-常用算法介绍&quot;&gt;&lt;a href=&quot;#STL容器-常用算法介绍&quot; class=&quot;headerlink&quot; title=&quot;STL容器-常用算法介绍&quot;&gt;&lt;/a&gt;STL容器-常用算法介绍&lt;/h1&gt;&lt;h2 id=&quot;1、常用的查找算法&quot;&gt;&lt;a href=&quot;#1、常用的查找算法&quot; class=&quot;headerlink&quot; title=&quot;1、常用的查找算法&quot;&gt;&lt;/a&gt;1、常用的查找算法&lt;/h2&gt;&lt;h3 id=&quot;1-1、adjacent-find&quot;&gt;&lt;a href=&quot;#1-1、adjacent-find&quot; class=&quot;headerlink&quot; title=&quot;1.1、adjacent_find()&quot;&gt;&lt;/a&gt;1.1、adjacent_find()&lt;/h3&gt;&lt;p&gt;在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的迭代器。否则返回past-the-end。</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="STL" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/STL/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>STL算法-算法中函数对象和谓词</title>
    <link href="http://example.com/2022/09/06/STL%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E4%B8%AD%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%B0%93%E8%AF%8D/"/>
    <id>http://example.com/2022/09/06/STL%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E4%B8%AD%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%B0%93%E8%AF%8D/</id>
    <published>2022-09-06T03:30:29.000Z</published>
    <updated>2022-09-06T09:27:52.837Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="STL容器-算法中函数对象和谓词"><a href="#STL容器-算法中函数对象和谓词" class="headerlink" title="STL容器-算法中函数对象和谓词"></a>STL容器-算法中函数对象和谓词</h1><h2 id="1、函数对象和谓词定义"><a href="#1、函数对象和谓词定义" class="headerlink" title="1、函数对象和谓词定义"></a>1、函数对象和谓词定义</h2><p><strong>函数对象：</strong><br>重载函数调用操作符的类，其对象常称为函数对象（function object），即它们是行为类似函数的对象。一个类对象，表现出一个函数的特征，就是通过“对象名+(参数列表)”的方式使用一个类对象，如果没有上下文，完全可以把它看作一个函数对待。<span id="more"></span><br>这是通过重载类的operator()来实现的。  </p><p>“在标准库中，函数对象被广泛地使用以获得弹性”，标准库中的很多算法都可以使用函数对象或者函数来作为自定的回调行为。</p><p><strong>谓词：</strong><br>一元函数对象：函数参数1个；<br>二元函数对象：函数参数2个；<br>一元谓词 函数参数1个，函数返回值是bool类型，可以作为一个判断式<br>二元谓词 函数参数2个，函数返回值是bool类型<br>谓词可以是一个仿函数，也可以是一个回调函数。</p><p>一元谓词函数举例如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1，判断给出的string对象的长度是否小于6</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GT6</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2,判断给出的int是否在3到8之间</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Compare</span><span class="params">( <span class="type">int</span> i )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( i &gt;= <span class="number">3</span> &amp;&amp; i &lt;= <span class="number">8</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二元谓词举例如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1，比较两个string对象，返回一个bool值，指出第一个string是否比第二个短</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isShorter</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、一元函数对象案例"><a href="#2、一元函数对象案例" class="headerlink" title="2、一元函数对象案例"></a>2、一元函数对象案例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1普通类 重载 函数调用操作符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FuncShowElemt</span><span class="params">(T &amp;t)</span>  <span class="comment">//普通函数 不能像 仿函数那样记录状态</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showChar</span><span class="params">(<span class="type">char</span> &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板 重载 函数调用操作符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShowElemt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ShowElemt</span>()</span><br><span class="line">&#123;</span><br><span class="line">n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n++;</span><br><span class="line">cout &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1 函数对象 基本使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">FuncShowElemt</span>&lt;<span class="type">int</span>&gt;(a); <span class="comment">//普通的函数调用</span></span><br><span class="line"></span><br><span class="line">ShowElemt&lt;<span class="type">int</span>&gt; showElemt; <span class="comment">//函数对象 </span></span><br><span class="line"><span class="built_in">showElemt</span>(a); <span class="comment">//函数对象调用 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、一元谓词案例"><a href="#3、一元谓词案例" class="headerlink" title="3、一元谓词案例"></a>3、一元谓词案例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1元谓词 例子</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Isdiv</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Isdiv</span>(<span class="type">const</span> T &amp;divisor)         <span class="comment">//</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;divisor = divisor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (t%divisor == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T divisor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">10</span>; i&lt;<span class="number">33</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="function">Isdiv&lt;<span class="type">int</span>&gt; <span class="title">mydiv</span><span class="params">(a)</span></span>;</span><br><span class="line"><span class="comment">// _InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)   //返回的是迭代器</span></span><br><span class="line">it = <span class="built_in">find_if</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">Isdiv</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>));</span><br><span class="line"><span class="keyword">if</span> (it != v2.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一个被4整除的数是：&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、二元函数对象案例"><a href="#4、二元函数对象案例" class="headerlink" title="4、二元函数对象案例"></a>4、二元函数对象案例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SumAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(T &amp;t1, T &amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printE</span><span class="params">(T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = t.<span class="built_in">begin</span>(); it!=t.<span class="built_in">end</span>(); it++ )</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it!=v.<span class="built_in">end</span>(); it++ )</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1, v2 ;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">v2.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v2.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v2.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">v3.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//transform(v1.begin(), v1.end(), v2.begin(),v3.begin(), SumAdd&lt;int&gt;());</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;class _InIt1,</span></span><br><span class="line"><span class="comment">class _InIt2,</span></span><br><span class="line"><span class="comment">class _OutIt,</span></span><br><span class="line"><span class="comment">class _Fn2&gt; inline</span></span><br><span class="line"><span class="comment">_OutIt transform(_InIt1 _First1, _InIt1 _Last1,</span></span><br><span class="line"><span class="comment">_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">transform</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(),v3.<span class="built_in">begin</span>(), <span class="built_in">SumAdd</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printE</span>(v3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、二元谓词案例"><a href="#5、二元谓词案例" class="headerlink" title="5、二元谓词案例"></a>5、二元谓词案例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">current</span><span class="params">(<span class="type">int</span> &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyCompare</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v[i] = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), current);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MyCompare );</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, v[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、预定义函数对象和函数适配器"><a href="#6、预定义函数对象和函数适配器" class="headerlink" title="6、预定义函数对象和函数适配器"></a>6、预定义函数对象和函数适配器</h2><ol><li>预定义函数对象基本概念：标准模板库STL提前定义了很多预定义函数对象，#include <functional> 必须包含。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1使用预定义函数对象：</span></span><br><span class="line"><span class="comment">//类模板plus&lt;&gt; 的实现了： 不同类型的数据进行加法运算</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">plus&lt;<span class="type">int</span>&gt; intAdd;</span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> z = <span class="built_in">intAdd</span>(x, y); <span class="comment">//等价于 x + y </span></span><br><span class="line">cout &lt;&lt; z &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">plus&lt;string&gt; stringAdd;</span><br><span class="line">string myc = <span class="built_in">stringAdd</span>(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">cout &lt;&lt; myc &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; v1;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="string">&quot;zzzz&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//缺省情况下，sort()用底层元素类型的小于操作符以升序排列容器的元素。</span></span><br><span class="line"><span class="comment">//为了降序，可以传递预定义的类模板greater,它调用底层元素类型的大于操作符：</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sort()函数排序&quot;</span> &lt;&lt; endl;;</span><br><span class="line"><span class="built_in">sort</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;string&gt;() ); <span class="comment">//从大到小</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;string&gt;::iterator it=v1.<span class="built_in">begin</span>(); it!=v1.<span class="built_in">end</span>(); it++ )</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>算术函数对象<br>预定义的函数对象支持加、减、乘、除、求余和取反。调用的操作符是与type相关联的实例</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加法：plus&lt;Types&gt;</span></span><br><span class="line">plus&lt;string&gt; stringAdd;</span><br><span class="line">sres = <span class="built_in">stringAdd</span>(sva1,sva2);</span><br><span class="line"><span class="comment">//减法：minus&lt;Types&gt;</span></span><br><span class="line"><span class="comment">//乘法：multiplies&lt;Types&gt;</span></span><br><span class="line"><span class="comment">//除法divides&lt;Tpye&gt;</span></span><br><span class="line"><span class="comment">//求余：modulus&lt;Tpye&gt;</span></span><br><span class="line"><span class="comment">//取反：negate&lt;Type&gt;</span></span><br><span class="line">negate&lt;<span class="type">int</span>&gt; intNegate;</span><br><span class="line">ires = <span class="built_in">intNegate</span>(ires);</span><br><span class="line">Ires= <span class="built_in">UnaryFunc</span>(<span class="built_in">negate</span>&lt;<span class="type">int</span>&gt;(),Ival1);</span><br></pre></td></tr></table></figure><ol start="3"><li>关系函数对象</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等于equal_to&lt;Tpye&gt;</span></span><br><span class="line">equal_to&lt;string&gt; stringEqual;</span><br><span class="line">sres = <span class="built_in">stringEqual</span>(sval1,sval2);</span><br><span class="line"><span class="comment">//不等于    not_equal_to&lt;Type&gt;</span></span><br><span class="line"><span class="comment">//大于      greater&lt;Type&gt;</span></span><br><span class="line"><span class="comment">//大于等于  greater_equal&lt;Type&gt;</span></span><br><span class="line"><span class="comment">//小于      less&lt;Type&gt;</span></span><br><span class="line"><span class="comment">//小于等于  less_equal&lt;Type&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;string&gt; v1;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="string">&quot;zzzz&quot;</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">string s1 = <span class="string">&quot;ccc&quot;</span>;</span><br><span class="line"><span class="comment">//int num = count_if(v1.begin(),v1.end(), equal_to&lt;string&gt;(),s1);</span></span><br><span class="line"><span class="type">int</span> num = <span class="built_in">count_if</span>(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>(),<span class="built_in">bind2nd</span>(<span class="built_in">equal_to</span>&lt;string&gt;(), s1));</span><br><span class="line">cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ol start="4"><li>逻辑函数对象</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逻辑与 logical_and&lt;Type&gt;</span></span><br><span class="line">logical_and&lt;<span class="type">int</span>&gt; indAnd;</span><br><span class="line">ires = <span class="built_in">intAnd</span>(ival1,ival2);</span><br><span class="line">dres = <span class="built_in">BinaryFunc</span>( <span class="built_in">logical_and</span>&lt;<span class="type">double</span>&gt;(),dval1,dval2);</span><br><span class="line"><span class="comment">//逻辑或logical_or&lt;Type&gt;</span></span><br><span class="line"><span class="comment">//逻辑非logical_not&lt;Type&gt;</span></span><br><span class="line">logical_not&lt;<span class="type">int</span>&gt; IntNot;</span><br><span class="line">Ires = <span class="built_in">IntNot</span>(ival1);</span><br><span class="line">Dres = <span class="built_in">UnaryFunc</span>( logical_not&lt;<span class="type">double</span>&gt;,dval1);</span><br></pre></td></tr></table></figure><h2 id="7、函数适配器"><a href="#7、函数适配器" class="headerlink" title="7、函数适配器"></a>7、函数适配器</h2><h3 id="7-1、函数适配器的理论知识"><a href="#7-1、函数适配器的理论知识" class="headerlink" title="7.1、函数适配器的理论知识"></a>7.1、函数适配器的理论知识</h3><blockquote><p>STL中已经定义了大量的函数对象，但是有时候需要对函数返回值进行进一步的简单计算，或者填上多余的参数，不能直接带入算法。函数适配器实现了这一功能，将一种函数对象转化为另一种符合要求的函数对象。函数适配器可以分为4大类：绑定适配器（bind adaptor）、组合适配器（composite adaptor）、指针函数适配器（pointer function adaptor）和成员函数适配器（member function adaptor）。</p></blockquote><p>STL中所有的函数适配器由下表列出：</p><p><img src="https://pic.imgdb.cn/item/6317128c16f2c2beb1be5f6a.png"></p><blockquote><p>直接构造STL中的函数适配器通常会导致冗长的类型声明。为简化函数适配器的构造，STL还提供了函数适配器辅助函数（如下图），借助于泛型自动推断技术，无序显式的类型声明便可实现函数适配器的构造。</p></blockquote><p><img src="https://pic.imgdb.cn/item/6317129b16f2c2beb1be6efd.png"></p><h3 id="7-2、常用函数函数适配器"><a href="#7-2、常用函数函数适配器" class="headerlink" title="7.2、常用函数函数适配器"></a>7.2、常用函数函数适配器</h3><p>标准库提供一组函数适配器，用来特殊化或者扩展一元和二元函数对象。常用适配器是：</p><ol><li><strong>绑定器（binder）</strong>: binder通过把二元函数对象的一个实参绑定到一个特殊的值上，将其转换成一元函数对象。C＋＋标准库提供两种预定义的binder适配器：bind1st和bind2nd，前者把值绑定到二元函数对象的第一个实参上，后者绑定在第二个实参上。</li><li><strong>取反器（negator）</strong>: negator是一个将函数对象的值翻转的函数适配器。标准库提供两个预定义的ngeator适配器：not1翻转一元预定义函数对象的真值,而not2翻转二元谓词函数的真值。</li></ol><p>常用函数适配器列表如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind1st</span>(op, value)</span><br><span class="line"><span class="built_in">bind2nd</span>(op, value)</span><br><span class="line"><span class="built_in">not1</span>(op)</span><br><span class="line"><span class="built_in">not2</span>(op)</span><br><span class="line"><span class="built_in">mem_fun_ref</span>(op)</span><br><span class="line"><span class="built_in">mem_fun</span>(op)</span><br><span class="line"><span class="built_in">ptr_fun</span>(op)</span><br></pre></td></tr></table></figure><h3 id="7-3、常用函数适配器案例"><a href="#7-3、常用函数适配器案例" class="headerlink" title="7.3、常用函数适配器案例"></a>7.3、常用函数适配器案例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IsGreat</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">IsGreat</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">m_num = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> &amp;num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num &gt; m_num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v1.<span class="built_in">begin</span>(); it!=v1.<span class="built_in">end</span>(); it ++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num1 = <span class="built_in">count</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num1:&quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过谓词求大于2的个数</span></span><br><span class="line"><span class="type">int</span> num2 = <span class="built_in">count_if</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">IsGreat</span>(<span class="number">2</span>)); </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num2:&quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过预定义函数对象求大于2的个数   greater&lt;int&gt;() 有2个参数 </span></span><br><span class="line"><span class="comment">//param &gt; 2</span></span><br><span class="line"><span class="type">int</span> num3 = <span class="built_in">count_if</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">2</span> ) );</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num3:&quot;</span> &lt;&lt; num3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取模 能被2整除的数 求奇数</span></span><br><span class="line"><span class="type">int</span> num4 = <span class="built_in">count_if</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(modulus &lt;<span class="type">int</span>&gt;(), <span class="number">2</span> ) ); </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;奇数num4:&quot;</span> &lt;&lt; num4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num5 = <span class="built_in">count_if</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">not1</span>( <span class="built_in">bind2nd</span>(modulus &lt;<span class="type">int</span>&gt;(), <span class="number">2</span> ) ) ); </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;偶数num5:&quot;</span> &lt;&lt; num5 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、STL的容器算法迭代器的设计理念"><a href="#8、STL的容器算法迭代器的设计理念" class="headerlink" title="8、STL的容器算法迭代器的设计理念"></a>8、STL的容器算法迭代器的设计理念</h2><ol><li>STL的容器通过类模板技术，实现数据类型和容器模型的分离。</li><li>STL的迭代器技术实现了遍历容器的统一方法；也为STL的算法提供了统一性</li><li>STL的函数对象实现了自定义数据类型的算法运算。（算法和）</li><li>具体例子：transform算法的输入，通过迭代器first和last指向的元算作为输入；通过result作为输出；通过函数对象来做自定义数据类型的运算。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;STL容器-算法中函数对象和谓词&quot;&gt;&lt;a href=&quot;#STL容器-算法中函数对象和谓词&quot; class=&quot;headerlink&quot; title=&quot;STL容器-算法中函数对象和谓词&quot;&gt;&lt;/a&gt;STL容器-算法中函数对象和谓词&lt;/h1&gt;&lt;h2 id=&quot;1、函数对象和谓词定义&quot;&gt;&lt;a href=&quot;#1、函数对象和谓词定义&quot; class=&quot;headerlink&quot; title=&quot;1、函数对象和谓词定义&quot;&gt;&lt;/a&gt;1、函数对象和谓词定义&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;函数对象：&lt;/strong&gt;&lt;br&gt;重载函数调用操作符的类，其对象常称为函数对象（function object），即它们是行为类似函数的对象。一个类对象，表现出一个函数的特征，就是通过“对象名+(参数列表)”的方式使用一个类对象，如果没有上下文，完全可以把它看作一个函数对待。</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="STL" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/STL/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>STL算法-算法基础</title>
    <link href="http://example.com/2022/09/06/STL%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/09/06/STL%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2022-09-06T03:29:41.000Z</published>
    <updated>2022-09-06T06:06:19.915Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="STL容器-算法基础"><a href="#STL容器-算法基础" class="headerlink" title="STL容器-算法基础"></a>STL容器-算法基础</h1><h2 id="1、算法概述"><a href="#1、算法概述" class="headerlink" title="1、算法概述"></a>1、算法概述</h2><ul><li>算法部分主要由头文件<code>&lt;algorithm&gt;，&lt;numeric&gt;和&lt;functional&gt;</code>组成。</li><li><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、反转、排序、合并等等。<span id="more"></span></li><li><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。</li><li><code>&lt;functional&gt;</code>中则定义了一些模板类，用以声明函数对象。</li><li>STL提供了大量实现算法的模版函数，只要我们熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要的功能，从而大大地提升效率。</li><li><code>#include &lt;algorithm&gt;</code></li><li><code>#include &lt;numeric&gt;</code></li><li><code>#include &lt;functional&gt;</code></li></ul><h2 id="2、STL中算法分类"><a href="#2、STL中算法分类" class="headerlink" title="2、STL中算法分类"></a>2、STL中算法分类</h2><ul><li>操作对象 <ul><li>直接改变容器的内容</li><li>将原容器的内容复制一份,修改其副本,然后传回该副本</li></ul></li><li>功能: <ul><li>非可变序列算法 指不直接修改其所操作的容器内容的算法<ul><li>计数算法 count、count_if</li><li>搜索算法 search、find、find_if、find_first_of、…</li><li>比较算法 equal、mismatch、lexicographical_compare</li></ul></li><li>可变序列算法 指可以修改它们所操作的容器内容的算法<ul><li>删除算法 remove、remove_if、remove_copy、…</li><li>修改算法 for_each、transform</li><li>排序算法 sort、stable_sort、partial_sort、</li></ul></li><li>排序算法 包括对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作</li><li>数值算法 对容器内容进行数值计算</li></ul></li></ul><h2 id="3、查找算法-13个-：判断容器中是否包含某个值"><a href="#3、查找算法-13个-：判断容器中是否包含某个值" class="headerlink" title="3、查找算法(13个)：判断容器中是否包含某个值"></a>3、查找算法(13个)：判断容器中是否包含某个值</h2><p><img src="https://pic.imgdb.cn/item/6316e17916f2c2beb1844e5f.jpg"></p><h2 id="4、堆算法-4个"><a href="#4、堆算法-4个" class="headerlink" title="4、堆算法(4个)"></a>4、堆算法(4个)</h2><p><img src="https://pic.imgdb.cn/item/6316e19b16f2c2beb184719d.jpg"></p><h2 id="5、关系算法-8个"><a href="#5、关系算法-8个" class="headerlink" title="5、关系算法(8个)"></a>5、关系算法(8个)</h2><p><img src="https://pic.imgdb.cn/item/6316e1c616f2c2beb184aa79.jpg"></p><h2 id="6、集合算法-4个"><a href="#6、集合算法-4个" class="headerlink" title="6、集合算法(4个)"></a>6、集合算法(4个)</h2><p><img src="https://pic.imgdb.cn/item/6316e1e816f2c2beb184e011.jpg"></p><h2 id="7、列组合算法-2个"><a href="#7、列组合算法-2个" class="headerlink" title="7、列组合算法(2个)"></a>7、列组合算法(2个)</h2><p>提供计算给定集合按一定顺序的所有可能排列组合<br><img src="https://pic.imgdb.cn/item/6316e27a16f2c2beb18581a5.jpg"></p><h2 id="8、排序和通用算法-14个-：提供元素排序策略"><a href="#8、排序和通用算法-14个-：提供元素排序策略" class="headerlink" title="8、排序和通用算法(14个)：提供元素排序策略"></a>8、排序和通用算法(14个)：提供元素排序策略</h2><p><img src="https://pic.imgdb.cn/item/6316e2b216f2c2beb185b68e.jpg"></p><h2 id="9、删除和替换算法-15个"><a href="#9、删除和替换算法-15个" class="headerlink" title="9、删除和替换算法(15个)"></a>9、删除和替换算法(15个)</h2><p><img src="https://pic.imgdb.cn/item/6316e2e616f2c2beb185ef9d.jpg"></p><h2 id="10、生成和变异算法-6个"><a href="#10、生成和变异算法-6个" class="headerlink" title="10、生成和变异算法(6个)"></a>10、生成和变异算法(6个)</h2><p><img src="https://pic.imgdb.cn/item/6316e30716f2c2beb1861190.jpg"></p><h2 id="11、算数算法-4个"><a href="#11、算数算法-4个" class="headerlink" title="11、算数算法(4个)"></a>11、算数算法(4个)</h2><p><img src="https://pic.imgdb.cn/item/6316e33216f2c2beb18643d7.jpg"></p><h2 id="12、常用算法汇总"><a href="#12、常用算法汇总" class="headerlink" title="12、常用算法汇总"></a>12、常用算法汇总</h2><ul><li>常用的查找算法：<br>adjacent_find()（ adjacent 是邻近的意思）,binary_search(),count(),<br>count_if(),equal_range(),find(),find_if()。</li><li>常用的排序算法：<br>merge(),sort(),random_shuffle()（shuffle是洗牌的意思） ,reverse()。</li><li>常用的拷贝和替换算法：<br>copy(), replace(),<br>replace_if(),swap()</li><li>常用的算术和生成算法：<br>accumulate()（ accumulate 是求和的意思）,fill(),。</li><li>常用的集合算法：<br>set_union(),set_intersection(),<br>set_difference()。</li><li>常用的遍历算法：<br>for_each(), transform()（ transform 是变换的意思）</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;STL容器-算法基础&quot;&gt;&lt;a href=&quot;#STL容器-算法基础&quot; class=&quot;headerlink&quot; title=&quot;STL容器-算法基础&quot;&gt;&lt;/a&gt;STL容器-算法基础&lt;/h1&gt;&lt;h2 id=&quot;1、算法概述&quot;&gt;&lt;a href=&quot;#1、算法概述&quot; class=&quot;headerlink&quot; title=&quot;1、算法概述&quot;&gt;&lt;/a&gt;1、算法概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;算法部分主要由头文件&lt;code&gt;&amp;lt;algorithm&amp;gt;，&amp;lt;numeric&amp;gt;和&amp;lt;functional&amp;gt;&lt;/code&gt;组成。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;algorithm&amp;gt;&lt;/code&gt;是所有STL头文件中最大的一个，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、反转、排序、合并等等。</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="STL" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/STL/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>STL容器-容器共性机制研究</title>
    <link href="http://example.com/2022/09/06/STL%E5%AE%B9%E5%99%A8-%E5%AE%B9%E5%99%A8%E5%85%B1%E6%80%A7%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6/"/>
    <id>http://example.com/2022/09/06/STL%E5%AE%B9%E5%99%A8-%E5%AE%B9%E5%99%A8%E5%85%B1%E6%80%A7%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6/</id>
    <published>2022-09-06T03:09:53.000Z</published>
    <updated>2022-09-06T03:25:52.255Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="STL容器-容器共性机制研究"><a href="#STL容器-容器共性机制研究" class="headerlink" title="STL容器-容器共性机制研究"></a>STL容器-容器共性机制研究</h1><h2 id="1、容器的共通能力"><a href="#1、容器的共通能力" class="headerlink" title="1、容器的共通能力"></a>1、容器的共通能力</h2><p>C++模板是容器的概念。</p><p>理论提高：所有容器提供的都是值（value）语意，而非引用（reference）语意。容器执行插入元素的操作时，内部实施拷贝动作。所以STL容器内存储的元素必须能够被拷贝（必须提供拷贝构造函数）。<span id="more"></span></p><ul><li>除了queue与stack外，每个容器都提供可返回迭代器的函数，运用返回的迭代器就可以访问元素。</li><li>通常STL不会丢出异常。要求使用者确保传入正确的参数。</li><li>每个容器都提供了一个默认构造函数跟一个默认拷贝构造函数。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如已有容器vecIntA。 </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vecIntB</span><span class="params">(vecIntA)</span></span>;  <span class="comment">//调用拷贝构造函数，复制vecIntA到vecIntB中。</span></span><br></pre></td></tr></table></figure></li><li>与大小相关的操作方法(c代表容器)：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">size</span>();   <span class="comment">//返回容器中元素的个数</span></span><br><span class="line">c.<span class="built_in">empty</span>();   <span class="comment">//判断容器是否为空</span></span><br></pre></td></tr></table></figure></li><li>比较操作(c1,c2代表容器)：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c1 == c2     <span class="comment">//判断c1是否等于c2</span></span><br><span class="line">c1 != c2     <span class="comment">//判断c1是否不等于c2</span></span><br><span class="line">c1 = c2      <span class="comment">//把c2的所有元素指派给c1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2、各个容器的使用时机"><a href="#2、各个容器的使用时机" class="headerlink" title="2、各个容器的使用时机"></a>2、各个容器的使用时机</h2><table><thead><tr><th></th><th>vector</th><th>deque</th><th>list</th><th>set</th><th>multiset</th><th>map</th><th>multimap</th></tr></thead><tbody><tr><td>典型内存结构</td><td>单端数组</td><td>双端数组</td><td>双向链表</td><td>二叉树</td><td>二叉树</td><td>二叉树</td><td>二叉树</td></tr><tr><td>可随机存取</td><td>是</td><td>是</td><td>否</td><td>否</td><td>否</td><td>对key而言是</td><td>否</td></tr><tr><td>元素搜寻速度</td><td>慢</td><td>慢</td><td>非常慢</td><td>快</td><td>快</td><td>对key而言快</td><td>对key而言快</td></tr><tr><td>快速安插移除</td><td>尾端</td><td>头尾两端</td><td>任何位置</td><td>-</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><ul><li><strong>deque的使用场景</strong>：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。</li><li><strong>vector与deque的比较</strong>：<ul><li>vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置却是不固定的。</li><li>如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。</li><li>deque支持头部的快速插入与快速移除，这是deque的优点。</li></ul></li><li><strong>list的使用场景</strong>：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。</li><li><strong>set的使用场景</strong>：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。 </li><li><strong>map的使用场景</strong>：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;STL容器-容器共性机制研究&quot;&gt;&lt;a href=&quot;#STL容器-容器共性机制研究&quot; class=&quot;headerlink&quot; title=&quot;STL容器-容器共性机制研究&quot;&gt;&lt;/a&gt;STL容器-容器共性机制研究&lt;/h1&gt;&lt;h2 id=&quot;1、容器的共通能力&quot;&gt;&lt;a href=&quot;#1、容器的共通能力&quot; class=&quot;headerlink&quot; title=&quot;1、容器的共通能力&quot;&gt;&lt;/a&gt;1、容器的共通能力&lt;/h2&gt;&lt;p&gt;C++模板是容器的概念。&lt;/p&gt;
&lt;p&gt;理论提高：所有容器提供的都是值（value）语意，而非引用（reference）语意。容器执行插入元素的操作时，内部实施拷贝动作。所以STL容器内存储的元素必须能够被拷贝（必须提供拷贝构造函数）。</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="STL" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/STL/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>STL容器-Map和multimap</title>
    <link href="http://example.com/2022/09/05/STL%E5%AE%B9%E5%99%A8-Map%E5%92%8Cmultimap/"/>
    <id>http://example.com/2022/09/05/STL%E5%AE%B9%E5%99%A8-Map%E5%92%8Cmultimap/</id>
    <published>2022-09-05T03:21:31.000Z</published>
    <updated>2022-09-06T03:37:00.403Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="STL容器-Map和multimap"><a href="#STL容器-Map和multimap" class="headerlink" title="STL容器-Map和multimap"></a>STL容器-Map和multimap</h1><h2 id="1、map-x2F-multimap的简介"><a href="#1、map-x2F-multimap的简介" class="headerlink" title="1、map&#x2F;multimap的简介"></a>1、map&#x2F;multimap的简介</h2><ul><li>map是标准的关联式容器，一个map是一个键值对序列，即(key,value)对。它提供基于key的快速检索能力。<span id="more"></span></li><li>map中key值是唯一的。集合中的元素按一定的顺序排列。元素插入过程是按排序规则插入，所以不能指定插入位置。</li><li><strong>map的具体实现采用红黑树变体的平衡二叉树的数据结构</strong>。在插入操作和删除操作上比vector快。</li><li>map可以直接存取key所对应的value，支持[]操作符，如map[key]&#x3D;value。</li><li>multimap与map的区别：map支持唯一键值，每个键只能出现一次；而multimap中相同键可以出现多次。multimap不支持[]操作符。</li><li><code>#include &lt;map&gt;</code></li></ul><h2 id="2、map-x2F-multimap对象的默认构造"><a href="#2、map-x2F-multimap对象的默认构造" class="headerlink" title="2、map&#x2F;multimap对象的默认构造"></a>2、map&#x2F;multimap对象的默认构造</h2><p>map&#x2F;multimap采用模板类实现，对象的默认构造形式：<br><code>map&lt;T1,T2&gt; mapTT; </code><br><code>multimap&lt;T1,T2&gt;  multimapTT;  </code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如：</span><br><span class="line">map&lt;int, char&gt; mapA;</span><br><span class="line">map&lt;string,float&gt; mapB;</span><br><span class="line">//其中T1,T2还可以用各种指针类型或自定义类型</span><br></pre></td></tr></table></figure><h2 id="3、map的插入与迭代器"><a href="#3、map的插入与迭代器" class="headerlink" title="3、map的插入与迭代器"></a>3、map的插入与迭代器</h2><ul><li><p><strong>map.insert(…);</strong>    &#x2F;&#x2F;往容器插入元素，返回pair&lt;iterator,bool&gt;</p></li><li><p><strong>在map中插入元素的三种方式：</strong><br>假设  map&lt;int, string&gt; mapStu;</p><ul><li>通过pair的方式插入对象<br>  <code>mapStu.insert(  pair&lt;int,string&gt;(3,&quot;小张&quot;)  );</code></li><li>通过pair的方式插入对象<br>  <code>mapStu.inset(make_pair(-1, “校长-1”));</code></li><li>通过value_type的方式插入对象<br>  <code>mapStu.insert(  map&lt;int,string&gt;::value_type(1,&quot;小李&quot;)  );</code></li><li>通过数组的方式插入值<br>  <code>mapStu[3] = “小刘&quot;;</code><br>  <code>mapStu[5] = “小王&quot;；</code></li></ul></li><li><p>前三种方法，采用的是insert()方法，该方法返回值为pair&lt;iterator,bool&gt; </p></li><li><p>第四种方法非常直观，但存在一个性能的问题。插入3时，先在mapStu中查找主键为3的项，若没发现，则将一个键为3，值为初始化值的对组插入到mapStu中，然后再将值修改成“小刘”。若发现已存在3这个键，则修改这个键对应的value。</p></li><li><p>string strName &#x3D; mapStu[2];   &#x2F;&#x2F;取操作或插入操作</p></li><li><p>只有当mapStu存在2这个键时才是正确的取操作，否则会自动插入一个实例，键为2，值为初始化值。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设  map&lt;int, string&gt; mapA;</span></span><br><span class="line">pair&lt; map&lt;<span class="type">int</span>,string&gt;::iterator, <span class="type">bool</span> &gt; pairResult = mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));       <span class="comment">//插入方式一</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> iFirstFirst = (pairResult.first)-&gt;first; <span class="comment">//iFirst == 3;</span></span><br><span class="line">string strFirstSecond = (pairResult.first)-&gt;second; <span class="comment">//strFirstSecond为&quot;小张&quot;</span></span><br><span class="line"><span class="type">bool</span> bSecond = pairResult.second; <span class="comment">//bSecond == true;</span></span><br><span class="line"></span><br><span class="line">mapA.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>,string&gt;::<span class="built_in">value_type</span>(<span class="number">1</span>,<span class="string">&quot;小李&quot;</span>)); <span class="comment">//插入方式二</span></span><br><span class="line"></span><br><span class="line">mapA[<span class="number">3</span>] = <span class="string">&quot;小刘&quot;</span>;    <span class="comment">//修改value</span></span><br><span class="line">mapA[<span class="number">5</span>] = <span class="string">&quot;小王&quot;</span>;    <span class="comment">//插入方式三</span></span><br><span class="line"></span><br><span class="line">string str1 = mapA[<span class="number">2</span>];<span class="comment">//执行插入 string() 操作，返回的str1的字符串内容为空。</span></span><br><span class="line">string str2 = mapA[<span class="number">3</span>];<span class="comment">//取得value，str2为&quot;小刘&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>,string&gt;::iterator it=mapA.<span class="built_in">begin</span>(); it!=mapA.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">    pair&lt;<span class="type">int</span>, string&gt; pr = *it;</span><br><span class="line">    <span class="type">int</span> iKey = pr.first;</span><br><span class="line">    string strValue = pr.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//map.rbegin()与map.rend()  略。</span></span><br></pre></td></tr></table></figure><ul><li><strong>map&lt;T1,T2,less<T1> &gt;  mapA;</strong>    &#x2F;&#x2F;该容器是按键的升序方式排列元素。未指定函数对象，默认采用less<T1>函数对象。</li><li><strong>map&lt;T1,T2,greater<T1>&gt; mapB;</strong>   &#x2F;&#x2F;该容器是按键的降序方式排列元素。</li><li>less<T1>与greater<T1> 可以替换成其它的函数对象functor。</li><li>可编写自定义函数对象以进行自定义类型的比较，使用方法与set构造时所用的函数对象一样。</li><li><strong>map.begin();</strong>  &#x2F;&#x2F;返回容器中第一个数据的迭代器。</li><li><strong>map.end();</strong>    &#x2F;&#x2F;返回容器中最后一个数据之后的迭代器。</li><li><strong>map.rbegin();</strong> &#x2F;&#x2F;返回容器中倒数第一个元素的迭代器。</li><li><strong>map.rend();</strong>   &#x2F;&#x2F;返回容器中倒数最后一个元素的后面的迭代器。</li></ul><h2 id="4、map对象的拷贝构造与赋值"><a href="#4、map对象的拷贝构造与赋值" class="headerlink" title="4、map对象的拷贝构造与赋值"></a>4、map对象的拷贝构造与赋值</h2><ul><li><strong>map(const map &amp;mp);</strong>        &#x2F;&#x2F;拷贝构造函数</li><li><strong>map&amp; operator&#x3D;(const map &amp;mp);</strong>&#x2F;&#x2F;重载等号操作符</li><li><strong>map.swap(mp);</strong>        &#x2F;&#x2F;交换两个集合容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例如:</span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; mapA;</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;小杨&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;小赵&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="function">map&lt;<span class="type">int</span> ,string&gt; <span class="title">mapB</span><span class="params">(mapA)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; mapC;</span><br><span class="line">mapC = mapA;<span class="comment">//赋值</span></span><br><span class="line"></span><br><span class="line">mapC[<span class="number">3</span>] = <span class="string">&quot;老张&quot;</span>;</span><br><span class="line">mapC.<span class="built_in">swap</span>(mapA);            <span class="comment">//交换</span></span><br></pre></td></tr></table></figure><h2 id="5、map的大小"><a href="#5、map的大小" class="headerlink" title="5、map的大小"></a>5、map的大小</h2><ul><li><strong>map.size();</strong>&#x2F;&#x2F;返回容器中元素的数目</li><li><strong>map.empty();</strong>  &#x2F;&#x2F;判断容器是否为空</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; mapA;</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;小杨&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;小赵&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mapA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iSize = mapA.<span class="built_in">size</span>();<span class="comment">//iSize == 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、map的删除"><a href="#6、map的删除" class="headerlink" title="6、map的删除"></a>6、map的删除</h2><ul><li><strong>map.clear();</strong>&#x2F;&#x2F;删除所有元素</li><li><strong>map.erase(pos);</strong>&#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><strong>map.erase(beg,end);</strong>    &#x2F;&#x2F;删除区间[beg,end)的所有元素，返回下一个元素的迭代器。</li><li><strong>map.erase(keyElem);</strong>    &#x2F;&#x2F;删除容器中key为keyElem的对组。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; mapA;</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;小杨&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;小赵&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除区间内的元素</span></span><br><span class="line">map&lt;<span class="type">int</span>,string&gt;::iterator itBegin=mapA.<span class="built_in">begin</span>();</span><br><span class="line">++ itBegin;</span><br><span class="line">++ itBegin;</span><br><span class="line">map&lt;<span class="type">int</span>,string&gt;::iterator itEnd=mapA.<span class="built_in">end</span>();</span><br><span class="line">mapA.<span class="built_in">erase</span>(itBegin,itEnd);<span class="comment">//此时容器mapA包含按顺序的&#123;1,&quot;小杨&quot;&#125;&#123;3,&quot;小张&quot;&#125;两个元素。</span></span><br><span class="line"></span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">7</span>,<span class="string">&quot;小赵&quot;</span>));</span><br><span class="line">mapA.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除容器中第一个元素</span></span><br><span class="line">mapA.<span class="built_in">erase</span>(mapA.<span class="built_in">begin</span>());    <span class="comment">//此时容器mapA包含了按顺序的&#123;3,&quot;小张&quot;&#125;&#123;5,&quot;小王&quot;&#125;&#123;7,&quot;小赵&quot;&#125;三个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除容器中key为5的元素</span></span><br><span class="line">mapA.<span class="built_in">erase</span>(<span class="number">5</span>);    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除mapA的所有元素</span></span><br><span class="line">mapA.<span class="built_in">clear</span>();            <span class="comment">//容器为空</span></span><br></pre></td></tr></table></figure><h2 id="7、map的查找"><a href="#7、map的查找" class="headerlink" title="7、map的查找"></a>7、map的查找</h2><ul><li><strong>map.find(key);</strong>        &#x2F;&#x2F;查找键key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回map.end();</li><li><strong>map.count(keyElem);</strong>   &#x2F;&#x2F;返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,string&gt;::iterator it=mapStu.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span>(it == mapStu.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//找到了</span></span><br><span class="line">    pair&lt;<span class="type">int</span>, string&gt; pairStu = *it;</span><br><span class="line">    <span class="type">int</span> iID = pairStu.first;    <span class="comment">//或 int iID = it-&gt;first;</span></span><br><span class="line">    string strName = pairStu.second;<span class="comment">//或 string strName = it-&gt;second;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>map.lower_bound(keyElem);</strong>   &#x2F;&#x2F;返回第一个key&gt;&#x3D;keyElem元素的迭代器。</li><li><strong>map.upper_bound(keyElem);</strong>  &#x2F;&#x2F;返回第一个key&gt;keyElem元素的迭代器。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如：  mapStu是用map&lt;int,string&gt;声明的容器，已包含&#123;1,&quot;小李&quot;&#125;&#123;3,&quot;小张&quot;&#125;&#123;5,&quot;小王&quot;&#125;&#123;7,&quot;小赵&quot;&#125;&#123;9,&quot;小陈&quot;&#125;元素。</span></span><br><span class="line">map&lt;<span class="type">int</span>,string&gt;::iterator it;</span><br><span class="line">it = mapStu.<span class="built_in">lower_bound</span>(<span class="number">5</span>);  <span class="comment">//it-&gt;first==5    it-&gt;second==&quot;小王&quot;</span></span><br><span class="line">it = mapStu.<span class="built_in">upper_bound</span>(<span class="number">5</span>);  <span class="comment">//it-&gt;first==7    it-&gt;second==&quot;小赵&quot;</span></span><br><span class="line">it = mapStu.<span class="built_in">lower_bound</span>(<span class="number">6</span>);  <span class="comment">//it-&gt;first==7    it-&gt;second==&quot;小赵&quot;</span></span><br><span class="line">it = mapStu.<span class="built_in">upper_bound</span>(<span class="number">6</span>);  <span class="comment">//it-&gt;first==7    it-&gt;second==&quot;小赵&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>map.equal_range(keyElem);</strong> &#x2F;&#x2F;返回容器中key与keyElem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。</li></ul><p>以上函数返回两个迭代器，而这两个迭代器被封装在pair中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如 map&lt;<span class="type">int</span>,string&gt; mapStu;</span><br><span class="line">...  <span class="comment">//往mapStu容器插入元素&#123;1,&quot;小李&quot;&#125;&#123;3,&quot;小张&quot;&#125;&#123;5,&quot;小王&quot;&#125;&#123;7,&quot;小赵&quot;&#125;&#123;9,&quot;小陈&quot;&#125;</span></span><br><span class="line">pair&lt; map&lt;<span class="type">int</span>,string&gt;::iterator , map&lt;<span class="type">int</span>,string&gt;::iterator &gt; pairIt = mapStu.<span class="built_in">equal_range</span>(<span class="number">5</span>);</span><br><span class="line">map&lt;<span class="type">int</span>, string&gt;::iterator itBeg = pairIt.first;</span><br><span class="line">map&lt;<span class="type">int</span>, string&gt;::iterator itEnd = pairIt.second;</span><br><span class="line"><span class="comment">//此时 itBeg-&gt;first==5  ,  itEnd-&gt;first == 7,</span></span><br><span class="line">itBeg-&gt;second==<span class="string">&quot;小王&quot;</span>, itEnd-&gt;second==<span class="string">&quot;小赵&quot;</span></span><br></pre></td></tr></table></figure><h2 id="8、Multimap-案例"><a href="#8、Multimap-案例" class="headerlink" title="8、Multimap 案例:"></a>8、Multimap 案例:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1个key值可以对应多个valude  =分组 </span></span><br><span class="line"><span class="comment">//公司有销售部 sale （员工2名）、技术研发部 development （1人）、财务部 Financial （2人） </span></span><br><span class="line"><span class="comment">//人员信息有：姓名，年龄，电话、工资等组成</span></span><br><span class="line"><span class="comment">//通过 multimap进行 信息的插入、保存、显示</span></span><br><span class="line"><span class="comment">//分部门显示员工信息 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//略。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;STL容器-Map和multimap&quot;&gt;&lt;a href=&quot;#STL容器-Map和multimap&quot; class=&quot;headerlink&quot; title=&quot;STL容器-Map和multimap&quot;&gt;&lt;/a&gt;STL容器-Map和multimap&lt;/h1&gt;&lt;h2 id=&quot;1、map-x2F-multimap的简介&quot;&gt;&lt;a href=&quot;#1、map-x2F-multimap的简介&quot; class=&quot;headerlink&quot; title=&quot;1、map&amp;#x2F;multimap的简介&quot;&gt;&lt;/a&gt;1、map&amp;#x2F;multimap的简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;map是标准的关联式容器，一个map是一个键值对序列，即(key,value)对。它提供基于key的快速检索能力。</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="STL" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/STL/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>STL容器-Set和multiset</title>
    <link href="http://example.com/2022/09/05/STL%E5%AE%B9%E5%99%A8-Set%E5%92%8Cmultiset/"/>
    <id>http://example.com/2022/09/05/STL%E5%AE%B9%E5%99%A8-Set%E5%92%8Cmultiset/</id>
    <published>2022-09-05T03:19:54.000Z</published>
    <updated>2022-09-06T03:36:30.545Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="STL容器-Set和multiset"><a href="#STL容器-Set和multiset" class="headerlink" title="STL容器-Set和multiset"></a>STL容器-Set和multiset</h1><h2 id="1、set-x2F-multiset的简介"><a href="#1、set-x2F-multiset的简介" class="headerlink" title="1、set&#x2F;multiset的简介"></a>1、set&#x2F;multiset的简介</h2><ul><li>set是一个<strong>集合</strong>容器，其中所包含的元素是唯一的，<strong>集合中的元素按一定的顺序排列</strong>。元素插入过程是按排序规则插入，所以不能指定插入位置。</li><li>set采用红黑树变体的数据结构实现，红黑树属于平衡二叉树。在插入操作和删除操作上比vector快。<span id="more"></span></li><li>set不可以直接存取元素。（不可以使用at.(pos)与[]操作符）。</li><li>multiset与set的区别：set支持唯一键值，每个元素值只能出现一次；而multiset中同一值可以出现多次。</li><li>不可以直接修改set或multiset容器中的元素值，因为该类容器是自动排序的。如果希望修改一个元素值，必须先删除原有的元素，再插入新的元素。</li><li><code>#include &lt;set&gt;  </code></li></ul><h2 id="2、set-x2F-multiset对象的默认构造"><a href="#2、set-x2F-multiset对象的默认构造" class="headerlink" title="2、set&#x2F;multiset对象的默认构造"></a>2、set&#x2F;multiset对象的默认构造</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; setInt;            <span class="comment">//一个存放int的set容器。</span></span><br><span class="line">set&lt;<span class="type">float</span>&gt; setFloat;        <span class="comment">//一个存放float的set容器。</span></span><br><span class="line">set&lt;string&gt; setString;      <span class="comment">//一个存放string的set容器。</span></span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; mulsetInt;    <span class="comment">//一个存放int的multi set容器。</span></span><br><span class="line">multi set&lt;<span class="type">float</span>&gt; multisetFloat;     <span class="comment">//一个存放float的multi set容器。</span></span><br><span class="line">multi set&lt;string&gt; multisetString;   <span class="comment">//一个存放string的multi set容器。</span></span><br></pre></td></tr></table></figure><h2 id="3、set的插入与迭代器"><a href="#3、set的插入与迭代器" class="headerlink" title="3、set的插入与迭代器"></a>3、set的插入与迭代器</h2><ul><li><strong>set.insert(elem);</strong>     &#x2F;&#x2F;在容器中插入元素。</li><li><strong>set.begin();</strong>          &#x2F;&#x2F;返回容器中第一个数据的迭代器。</li><li><strong>set.end();</strong>            &#x2F;&#x2F;返回容器中最后一个数据之后的迭代器。</li><li><strong>set.rbegin();</strong>         &#x2F;&#x2F;返回容器中倒数第一个元素的迭代器。</li><li><strong>set.rend();</strong>           &#x2F;&#x2F;返回容器中倒数最后一个元素的后面的迭代器。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; setInt;</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">3</span>); setInt.<span class="built_in">insert</span>(<span class="number">1</span>);setInt.<span class="built_in">insert</span>(<span class="number">5</span>);setInt.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it=setInt.<span class="built_in">begin</span>(); it!=setInt.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iItem = *it;</span><br><span class="line">    cout &lt;&lt; iItem;    <span class="comment">//或直接使用cout &lt;&lt; *it</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样子便顺序输出  1 2 3 5。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set.rbegin()与set.rend()。略。</span></span><br></pre></td></tr></table></figure><h2 id="4、Set集合的元素排序"><a href="#4、Set集合的元素排序" class="headerlink" title="4、Set集合的元素排序"></a>4、Set集合的元素排序</h2><ul><li><strong>set&lt;int,less<int> &gt; setIntA;</strong>     &#x2F;&#x2F;该容器是按升序方式排列元素。</li><li><strong>set&lt;int,greater<int>&gt; setIntB;</strong>   &#x2F;&#x2F;该容器是按降序方式排列元素。</li><li>set<int> 相当于 set&lt;int,less<int>&gt;。</li><li>less<int>与greater<int>中的int可以改成其它类型，该类型主要要跟set容纳的数据类型一致。<ul><li>疑问1：less&lt;&gt;与greater&lt;&gt;是什么？</li><li>疑问2：如果set&lt;&gt;不包含int类型，而是包含自定义类型，set容器如何排序？<ul><li>要解决如上两个问题，需要了解容器的函数对象，也叫伪函数，英文名叫functor。</li><li>下面将讲解什么是functor，functor的用法。</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用stl提供的函数对象</span></span><br><span class="line">set&lt;<span class="type">int</span>,greater&lt;<span class="type">int</span>&gt;&gt; setIntB;   </span><br><span class="line">setIntB.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setIntB.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setIntB.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setIntB.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//此时容器setIntB就包含了按顺序的5,3,2,1元素</span></span><br></pre></td></tr></table></figure><h2 id="5、函数对象functor的用法"><a href="#5、函数对象functor的用法" class="headerlink" title="5、函数对象functor的用法"></a>5、函数对象functor的用法</h2><ul><li>尽管函数指针被广泛用于实现函数回调，但C++还提供了一个重要的实现回调函数的方法，那就是函数对象。</li><li>functor，翻译成函数对象，伪函数，算符，是重载了“()”操作符的普通类对象。从语法上讲，它与普通函数行为类似。</li><li>greater&lt;&gt;与less&lt;&gt;就是函数对象。</li><li>下面举出greater<int>的简易实现原理。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">greater</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; iLeft, <span class="type">const</span> <span class="type">int</span>&amp; iRight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (iLeft&gt;iRight);    <span class="comment">//如果是实现less&lt;int&gt;的话，这边是写return (iLeft&lt;iRight);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//容器就是调用函数对象的operator()方法去比较两个值的大小。</span></span><br></pre></td></tr></table></figure></li></ul><p>题目：学生包含学号，姓名属性，现要求任意插入几个学生对象到set容器中，使得容器中的学生按学号的升序排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解：</span></span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CStudent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CStudent</span>(<span class="type">int</span> iID, string strName)</span><br><span class="line">&#123;</span><br><span class="line">m_iID = iID;</span><br><span class="line">m_strName = strName;</span><br><span class="line">&#125;</span><br><span class="line">     <span class="type">int</span> m_iID;    <span class="comment">//学号</span></span><br><span class="line">     string m_strName; <span class="comment">//姓名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为保持主题鲜明，本类不写拷贝构造函数，不类也不需要写拷贝构造函数。但大家仍要有考虑拷贝构造函数的习惯。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StuFunctor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span>  <span class="params">(<span class="type">const</span> CStudent &amp;stu1, <span class="type">const</span> CStudent &amp;stu2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (stu1.m_iID &lt; stu2.m_iID);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;CStudent, StuFunctor&gt; setStu;</span><br><span class="line">    setStu.<span class="built_in">insert</span>(<span class="built_in">CStudent</span>(<span class="number">3</span>,<span class="string">&quot;小张&quot;</span>));</span><br><span class="line">    setStu.<span class="built_in">insert</span>(<span class="built_in">CStudent</span>(<span class="number">1</span>,<span class="string">&quot;小李&quot;</span>));</span><br><span class="line">    setStu.<span class="built_in">insert</span>(<span class="built_in">CStudent</span>(<span class="number">5</span>,<span class="string">&quot;小王&quot;</span>));</span><br><span class="line">    setStu.<span class="built_in">insert</span>(<span class="built_in">CStudent</span>(<span class="number">2</span>,<span class="string">&quot;小刘&quot;</span>));</span><br><span class="line">    <span class="comment">//此时容器setStu包含了四个学生对象，分别是按姓名顺序的“小李”，“小刘”，“小张”，“小王” </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、set对象的拷贝构造与赋值"><a href="#6、set对象的拷贝构造与赋值" class="headerlink" title="6、set对象的拷贝构造与赋值"></a>6、set对象的拷贝构造与赋值</h2><ul><li><strong>set(const set &amp;st);</strong>        &#x2F;&#x2F;拷贝构造函数</li><li><strong>set&amp; operator&#x3D;(const set &amp;st);</strong>&#x2F;&#x2F;重载等号操作符</li><li><strong>set.swap(st);</strong>     &#x2F;&#x2F;交换两个集合容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; setIntA;</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">setIntB</span><span class="params">(setIntA)</span></span>;  <span class="comment">//1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; setIntC;</span><br><span class="line">setIntC = setIntA;    <span class="comment">//1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line">setIntC.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line">setIntC.<span class="built_in">swap</span>(setIntA);    <span class="comment">//交换</span></span><br></pre></td></tr></table></figure><h2 id="7、set的大小"><a href="#7、set的大小" class="headerlink" title="7、set的大小"></a>7、set的大小</h2><ul><li><strong>set.size();</strong>&#x2F;&#x2F;返回容器中元素的数目</li><li><strong>set.empty();</strong>  &#x2F;&#x2F;判断容器是否为空</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; setIntA;</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setIntA.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!setIntA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iSize = setIntA.<span class="built_in">size</span>();<span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、set的删除"><a href="#8、set的删除" class="headerlink" title="8、set的删除"></a>8、set的删除</h2><ul><li><strong>set.clear();</strong>&#x2F;&#x2F;清除所有元素</li><li><strong>set.erase(pos);</strong>&#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><strong>set.erase(beg,end);</strong>   &#x2F;&#x2F;删除区间[beg,end)的所有元素，返回下一个元素的迭代器。</li><li><strong>set.erase(elem);</strong>      &#x2F;&#x2F;删除容器中值为elem的元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除区间内的元素</span></span><br><span class="line">setInt是用set&lt;<span class="type">int</span>&gt;声明的容器，现已包含按顺序的<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>元素。</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator itBegin = setInt.<span class="built_in">begin</span>();</span><br><span class="line">++ itBegin;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator itEnd = setInt.<span class="built_in">begin</span>();</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">setInt.<span class="built_in">erase</span>(itBegin, itEnd);</span><br><span class="line"><span class="comment">//此时容器setInt包含按顺序的1,6,9,11四个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除容器中第一个元素</span></span><br><span class="line">setInt.<span class="built_in">erase</span>(setInt.<span class="built_in">begin</span>());<span class="comment">//6,9,11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除容器中值为9的元素</span></span><br><span class="line">set.<span class="built_in">erase</span>(<span class="number">9</span>);    </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除setInt的所有元素</span></span><br><span class="line">setInt.<span class="built_in">clear</span>();            <span class="comment">//容器为空</span></span><br></pre></td></tr></table></figure><h2 id="9、set的查找"><a href="#9、set的查找" class="headerlink" title="9、set的查找"></a>9、set的查找</h2><ul><li><strong>set.find(elem);</strong>    &#x2F;&#x2F;查找elem元素，返回指向elem元素的迭代器。</li><li><strong>set.count(elem);</strong>   &#x2F;&#x2F;返回容器中值为elem的元素个数。对set来说，要么是0，要么是1。对multiset来说，值可能大于1。</li><li><strong>set.lower_bound(elem);</strong>  &#x2F;&#x2F;返回第一个&gt;&#x3D;elem元素的迭代器。</li><li><strong>set.upper_bound(elem);</strong>  &#x2F;&#x2F; 返回第一个&gt;elem元素的迭代器。</li><li><strong>set.equal_range(elem);</strong>  &#x2F;&#x2F;返回容器中与elem相等的上下限的两个迭代器。上限是闭区间，下限是开区间，如[beg,end)。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; setInt;</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">setInt.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator itA = setInt.<span class="built_in">find</span>(<span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> iA = *itA;            <span class="comment">//iA == 5</span></span><br><span class="line"><span class="type">int</span> iCount = setInt.<span class="built_in">count</span>(<span class="number">5</span>);<span class="comment">//iCount == 1</span></span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator itB = setInt.<span class="built_in">lower_bound</span>(<span class="number">5</span>);</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator itC = setInt.<span class="built_in">upper_bound</span>(<span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> iB = *itB;                <span class="comment">//iB == 5</span></span><br><span class="line"><span class="type">int</span> iC = *itC;                  <span class="comment">//iC == 7</span></span><br><span class="line"></span><br><span class="line">pair&lt; set&lt;<span class="type">int</span>&gt;::iterator, set&lt;<span class="type">int</span>&gt;::iterator &gt; pairIt = setInt.<span class="built_in">equal_range</span>(<span class="number">5</span>);  <span class="comment">//pair是什么？</span></span><br></pre></td></tr></table></figure><p>以上函数返回两个迭代器，而这两个迭代器被封装在pair中。<br>以下讲解pair的含义与使用方法。</p><h2 id="10、pair的使用"><a href="#10、pair的使用" class="headerlink" title="10、pair的使用"></a>10、pair的使用</h2><ul><li>pair译为对组，可以将两个值视为一个单元。</li><li>pair&lt;T1,T2&gt;存放的两个值的类型，可以不一样，如T1为int，T2为float。T1,T2也可以是自定义类型。</li><li><strong>pair.first是pair里面的第一个值，是T1类型。</strong></li><li><strong>pair.second是pair里面的第二个值，是T2类型。</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; setInt;</span><br><span class="line">...  <span class="comment">//往setInt容器插入元素1,3,5,7,9</span></span><br><span class="line">pair&lt; set&lt;<span class="type">int</span>&gt;::iterator , set&lt;<span class="type">int</span>&gt;::iterator &gt; pairIt = setInt.<span class="built_in">equal_range</span>(<span class="number">5</span>);</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator itBeg = pairIt.first;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator itEnd = pairIt.second;</span><br><span class="line"><span class="comment">//此时 *itBeg==5  而  *itEnd == 7</span></span><br></pre></td></tr></table></figure><h2 id="11、小结"><a href="#11、小结" class="headerlink" title="11、小结"></a>11、小结</h2><ol><li>容器set&#x2F;multiset的使用方法；<br>红黑树的变体，查找效率高，插入不能指定位置，插入时自动排序。</li><li>functor的使用方法；<br>类似于函数的功能，可用来自定义一些规则，如元素比较规则。</li><li>pair的使用方法。<br>对组，一个整体的单元，存放两个类型(T1,T2，T1可与T2一样)的两个元素。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例:</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>,&amp;x);</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; h;    <span class="comment">//建立一个multiset类型，变量名是h，h序列里面存的是int类型,初始h为空</span></span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">    h.<span class="built_in">insert</span>(x);    <span class="comment">//将x插入h中</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>,&amp;x);</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">pair&lt; multiset&lt;<span class="type">int</span>&gt;::iterator , multiset&lt;<span class="type">int</span>&gt;::iterator &gt; pairIt = h.<span class="built_in">equal_range</span>(<span class="number">22</span>);</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt;::iterator itBeg = pairIt.first;</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt;::iterator itEnd = pairIt.second;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nBeg = *itBeg;</span><br><span class="line"><span class="type">int</span> nEnd = *itEnd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!h.<span class="built_in">empty</span>())&#123;      <span class="comment">// 序列非空h.empty()==true时表示h已经空了</span></span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt;::iterator c = h.<span class="built_in">begin</span>();  <span class="comment">//c指向h序列中第一个元素的地址，第一个元素是最小的元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld &quot;</span>,*c);  <span class="comment">//将地址c存的数据输出</span></span><br><span class="line">    h.<span class="built_in">erase</span>(c);         <span class="comment">//从h序列中将c指向的元素删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;STL容器-Set和multiset&quot;&gt;&lt;a href=&quot;#STL容器-Set和multiset&quot; class=&quot;headerlink&quot; title=&quot;STL容器-Set和multiset&quot;&gt;&lt;/a&gt;STL容器-Set和multiset&lt;/h1&gt;&lt;h2 id=&quot;1、set-x2F-multiset的简介&quot;&gt;&lt;a href=&quot;#1、set-x2F-multiset的简介&quot; class=&quot;headerlink&quot; title=&quot;1、set&amp;#x2F;multiset的简介&quot;&gt;&lt;/a&gt;1、set&amp;#x2F;multiset的简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;set是一个&lt;strong&gt;集合&lt;/strong&gt;容器，其中所包含的元素是唯一的，&lt;strong&gt;集合中的元素按一定的顺序排列&lt;/strong&gt;。元素插入过程是按排序规则插入，所以不能指定插入位置。&lt;/li&gt;
&lt;li&gt;set采用红黑树变体的数据结构实现，红黑树属于平衡二叉树。在插入操作和删除操作上比vector快。</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="STL" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/STL/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>STL容器-List</title>
    <link href="http://example.com/2022/09/05/STL%E5%AE%B9%E5%99%A8-List/"/>
    <id>http://example.com/2022/09/05/STL%E5%AE%B9%E5%99%A8-List/</id>
    <published>2022-09-05T02:38:07.000Z</published>
    <updated>2022-09-06T03:37:08.266Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="STL容器-List"><a href="#STL容器-List" class="headerlink" title="STL容器-List"></a>STL容器-List</h1><h2 id="1、List容器简介"><a href="#1、List容器简介" class="headerlink" title="1、List容器简介"></a>1、List容器简介</h2><ul><li>list是一个双向链表容器，可高效地进行插入删除元素。</li><li>list不可以随机存取元素，所以不支持at.(pos)函数与[]操作符。It++(ok) it+5(err)</li><li><code>#include &lt;list&gt; </code><span id="more"></span></li></ul><h2 id="2、list对象的默认构造"><a href="#2、list对象的默认构造" class="headerlink" title="2、list对象的默认构造"></a>2、list对象的默认构造</h2><p>list采用采用模板类实现,对象的默认构造形式：**<code>list&lt;T&gt; lstT;</code>**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lstInt;           <span class="comment">//定义一个存放int的list容器。</span></span><br><span class="line">list&lt;<span class="type">float</span>&gt; lstFloat;       <span class="comment">//定义一个存放float的list容器。</span></span><br><span class="line">list&lt;string&gt; lstString;     <span class="comment">//定义一个存放string的list容器。</span></span><br><span class="line">...    </span><br><span class="line"><span class="comment">//尖括号内还可以设置指针类型或自定义类型。</span></span><br></pre></td></tr></table></figure><h2 id="3、list头尾的添加移除操作"><a href="#3、list头尾的添加移除操作" class="headerlink" title="3、list头尾的添加移除操作"></a>3、list头尾的添加移除操作</h2><ul><li><strong>list.push_back(elem);</strong>   &#x2F;&#x2F;在容器尾部加入一个元素</li><li><strong>list.pop_back();</strong>         &#x2F;&#x2F;删除容器中最后一个元素</li><li><strong>list.push_front(elem);</strong>   &#x2F;&#x2F;在容器开头插入一个元素</li><li><strong>list.pop_front();</strong>        &#x2F;&#x2F;从容器开头移除第一个元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lstInt;</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">lstInt.<span class="built_in">pop_front</span>();</span><br><span class="line">lstInt.<span class="built_in">pop_front</span>();</span><br><span class="line">lstInt.<span class="built_in">push_front</span>(<span class="number">11</span>);</span><br><span class="line">lstInt.<span class="built_in">push_front</span>(<span class="number">13</span>);</span><br><span class="line">lstInt.<span class="built_in">pop_back</span>();</span><br><span class="line">lstInt.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">// lstInt    &#123;13,11,5&#125;</span></span><br></pre></td></tr></table></figure><h2 id="4、list的数据存取"><a href="#4、list的数据存取" class="headerlink" title="4、list的数据存取"></a>4、list的数据存取</h2><ul><li><strong>list.front();</strong>   &#x2F;&#x2F;返回第一个元素。</li><li><strong>list.back();</strong>    &#x2F;&#x2F;返回最后一个元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lstInt;</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> iFront = lstInt.<span class="built_in">front</span>();<span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> iBack = lstInt.<span class="built_in">back</span>();<span class="comment">//9</span></span><br><span class="line">lstInt.<span class="built_in">front</span>() = <span class="number">11</span>;<span class="comment">//11</span></span><br><span class="line">lstInt.<span class="built_in">back</span>() = <span class="number">19</span>;    <span class="comment">//19</span></span><br></pre></td></tr></table></figure><h2 id="5、list与迭代器"><a href="#5、list与迭代器" class="headerlink" title="5、list与迭代器"></a>5、list与迭代器</h2><ul><li><strong>list.begin();</strong>     &#x2F;&#x2F;返回容器中第一个元素的迭代器。</li><li><strong>list.end();</strong>       &#x2F;&#x2F;返回容器中最后一个元素之后的迭代器。</li><li><strong>list.rbegin();</strong>    &#x2F;&#x2F;返回容器中倒数第一个元素的迭代器。</li><li><strong>list.rend();</strong>      &#x2F;&#x2F;返回容器中倒数最后一个元素的后面的迭代器。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lstInt;</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::iterator it=lstInt.<span class="built_in">begin</span>(); it!=lstInt.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::reverse_iterator rit=lstInt.<span class="built_in">rbegin</span>(); rit!=lstInt.<span class="built_in">rend</span>(); ++rit)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *rit;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、list对象的带参数构造"><a href="#6、list对象的带参数构造" class="headerlink" title="6、list对象的带参数构造"></a>6、list对象的带参数构造</h2><ul><li><strong>list(beg,end);</strong>    &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。</li><li><strong>list(n,elem);</strong>     &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li><li><strong>list(const list &amp;lst);</strong>  &#x2F;&#x2F;拷贝构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lstIntA;</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lstIntB</span><span class="params">(lstIntA.begin(),lstIntA.end())</span></span>;   <span class="comment">//1 3 5 7 9</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lstIntC</span><span class="params">(<span class="number">5</span>,<span class="number">8</span>)</span></span>;    <span class="comment">//8 8 8 8 8 </span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lstIntD</span><span class="params">(lstIntA)</span></span>;    <span class="comment">//1 3 5 7 9</span></span><br></pre></td></tr></table></figure><h2 id="7、list的赋值"><a href="#7、list的赋值" class="headerlink" title="7、list的赋值"></a>7、list的赋值</h2><ul><li><strong>list.assign(beg,end);</strong>     &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</li><li><strong>list.assign(n,elem);</strong>      &#x2F;&#x2F;将n个elem拷贝赋值给本身。</li><li><strong>list&amp; operator&#x3D;(const list &amp;lst);</strong>&#x2F;&#x2F;重载等号操作符</li><li><strong>list.swap(lst);</strong>           &#x2F;&#x2F; 将lst与本身的元素互换。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lstIntA,lstIntB,lstIntC,lstIntD;</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">lstIntB.<span class="built_in">assign</span>(lstIntA.<span class="built_in">begin</span>(),lstIntA.<span class="built_in">end</span>());<span class="comment">//1 3 5 7 9</span></span><br><span class="line">lstIntC.<span class="built_in">assign</span>(<span class="number">5</span>,<span class="number">8</span>);<span class="comment">//8 8 8 8 8</span></span><br><span class="line">lstIntD = lstIntA;    <span class="comment">//1 3 5 7 9</span></span><br><span class="line">lstIntC.<span class="built_in">swap</span>(lstIntD);    <span class="comment">//互换</span></span><br></pre></td></tr></table></figure><h2 id="8、list的大小"><a href="#8、list的大小" class="headerlink" title="8、list的大小"></a>8、list的大小</h2><ul><li><strong>list.size();</strong>   &#x2F;&#x2F;返回容器中元素的个数</li><li><strong>list.empty();</strong>   &#x2F;&#x2F;判断容器是否为空</li><li><strong>list.resize(num);</strong>   &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li><li><strong>list.resize(num, elem);</strong>  &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lstIntA;</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!lstIntA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iSize = lstIntA.<span class="built_in">size</span>();<span class="comment">//3</span></span><br><span class="line">    lstIntA.<span class="built_in">resize</span>(<span class="number">5</span>);    <span class="comment">//1 3 5 0 0</span></span><br><span class="line">    lstIntA.<span class="built_in">resize</span>(<span class="number">7</span>,<span class="number">1</span>);<span class="comment">//1 3 5 0 0 1 1</span></span><br><span class="line">    lstIntA.<span class="built_in">resize</span>(<span class="number">2</span>);    <span class="comment">//1 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、list的插入"><a href="#8、list的插入" class="headerlink" title="8、list的插入"></a>8、list的插入</h2><ul><li><strong>list.insert(pos,elem);</strong>     &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。</li><li><strong>list.insert(pos,n,elem);</strong>   &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</li><li><strong>list.insert(pos,beg,end);</strong>  &#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lstA;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lstB;</span><br><span class="line"></span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">lstB.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">lstB.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">lstB.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">lstB.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">lstA.<span class="built_in">insert</span>(lstA.<span class="built_in">begin</span>(), <span class="number">11</span>);<span class="comment">//&#123;11, 1, 3, 5, 7, 9&#125;</span></span><br><span class="line">lstA.<span class="built_in">insert</span>(++lstA.<span class="built_in">begin</span>(),<span class="number">2</span>,<span class="number">33</span>);<span class="comment">//&#123;11,33,33,1,3,5,7,9&#125;</span></span><br><span class="line">lstA.<span class="built_in">insert</span>(lstA.<span class="built_in">begin</span>() , lstB.<span class="built_in">begin</span>() , lstB.<span class="built_in">end</span>() );<span class="comment">//&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125;</span></span><br></pre></td></tr></table></figure><h2 id="9、list的删除"><a href="#9、list的删除" class="headerlink" title="9、list的删除"></a>9、list的删除</h2><ul><li><strong>list.clear();</strong>    &#x2F;&#x2F;移除容器的所有数据</li><li><strong>list.erase(beg,end);</strong>  &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li><li><strong>list.erase(pos);</strong>      &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li><li><strong>list.remove(elem);</strong>    &#x2F;&#x2F;删除容器中所有与elem值匹配的元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除区间内的元素</span></span><br><span class="line"><span class="comment">//lstInt是用list&lt;int&gt;声明的容器，现已包含按顺序的1,3,5,6,9元素。</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator itBegin=lstInt.<span class="built_in">begin</span>();</span><br><span class="line">++ itBegin;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator itEnd=lstInt.<span class="built_in">begin</span>();</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">++ itEnd;</span><br><span class="line">lstInt.<span class="built_in">erase</span>(itBegin,itEnd);</span><br><span class="line"><span class="comment">//此时容器lstInt包含按顺序的1,6,9三个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//假设 lstInt 包含1,3,2,3,3,3,4,3,5,3，删除容器中等于3的元素的方法一</span></span><br><span class="line"><span class="keyword">for</span>(list&lt;<span class="type">int</span>&gt;::iterator it=lstInt.<span class="built_in">being</span>(); it!=lstInt.<span class="built_in">end</span>(); )    <span class="comment">//小括号里不需写  ++it</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(*it == <span class="number">3</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        it  =  lstInt.<span class="built_in">erase</span>(it);       <span class="comment">//以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。</span></span><br><span class="line">        <span class="comment">//此时，不执行  ++it；  </span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       ++it;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除容器中等于3的元素的方法二</span></span><br><span class="line">lstInt.<span class="built_in">remove</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除lstInt的所有元素</span></span><br><span class="line">lstInt.<span class="built_in">clear</span>();<span class="comment">//容器为空</span></span><br></pre></td></tr></table></figure><h2 id="10、list的反序排列"><a href="#10、list的反序排列" class="headerlink" title="10、list的反序排列"></a>10、list的反序排列</h2><ul><li><strong>lst.reverse();</strong>     &#x2F;&#x2F;反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lstA;</span><br><span class="line"></span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">lstA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">lstA.<span class="built_in">reverse</span>();<span class="comment">//9 7 5 3 1</span></span><br></pre></td></tr></table></figure><h2 id="11、小结"><a href="#11、小结" class="headerlink" title="11、小结"></a>11、小结</h2><ol><li>容器deque的使用方法<br> 适合在头尾添加移除元素。使用方法与vector类似。</li><li>容器queue,stack的使用方法<br> 适合队列，堆栈的操作方式。</li><li>容器list的使用方法<br> 适合在任意位置快速插入移除元素</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;STL容器-List&quot;&gt;&lt;a href=&quot;#STL容器-List&quot; class=&quot;headerlink&quot; title=&quot;STL容器-List&quot;&gt;&lt;/a&gt;STL容器-List&lt;/h1&gt;&lt;h2 id=&quot;1、List容器简介&quot;&gt;&lt;a href=&quot;#1、List容器简介&quot; class=&quot;headerlink&quot; title=&quot;1、List容器简介&quot;&gt;&lt;/a&gt;1、List容器简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;list是一个双向链表容器，可高效地进行插入删除元素。&lt;/li&gt;
&lt;li&gt;list不可以随机存取元素，所以不支持at.(pos)函数与[]操作符。It++(ok) it+5(err)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#include &amp;lt;list&amp;gt; &lt;/code&gt;</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="STL" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/STL/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>STL容器-Queue</title>
    <link href="http://example.com/2022/09/05/STL%E5%AE%B9%E5%99%A8-Queue/"/>
    <id>http://example.com/2022/09/05/STL%E5%AE%B9%E5%99%A8-Queue/</id>
    <published>2022-09-05T02:27:45.000Z</published>
    <updated>2022-09-06T03:36:51.892Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="STL容器-Queue"><a href="#STL容器-Queue" class="headerlink" title="STL容器-Queue"></a>STL容器-Queue</h1><h2 id="1、Queue容器简介"><a href="#1、Queue容器简介" class="headerlink" title="1、Queue容器简介"></a>1、Queue容器简介</h2><ul><li>queue是队列容器，是一种“先进先出”的容器。</li><li>queue是简单地装饰deque容器而成为另外的一种容器。</li><li><code>#include &lt;queue&gt;</code>  <span id="more"></span></li></ul><h2 id="2、queue对象的默认构造"><a href="#2、queue对象的默认构造" class="headerlink" title="2、queue对象的默认构造"></a>2、queue对象的默认构造</h2><p>queue采用模板类实现，queue对象的默认构造形式：**<code>queue&lt;T&gt; queT;</code>**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; queInt;            <span class="comment">//一个存放int的queue容器。</span></span><br><span class="line">queue&lt;<span class="type">float</span>&gt; queFloat;        <span class="comment">//一个存放float的queue容器。</span></span><br><span class="line">queue&lt;string&gt; queString;      <span class="comment">//一个存放string的queue容器。</span></span><br><span class="line">...    </span><br><span class="line"><span class="comment">//尖括号内还可以设置指针类型或自定义类型。</span></span><br></pre></td></tr></table></figure><h2 id="3、queue的push-与pop-方法"><a href="#3、queue的push-与pop-方法" class="headerlink" title="3、queue的push()与pop()方法"></a>3、queue的push()与pop()方法</h2><ul><li><strong>queue.push(elem);</strong>   &#x2F;&#x2F;往队尾添加元素</li><li><strong>queue.pop();</strong>        &#x2F;&#x2F;从队头移除第一个元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; queInt;</span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">queInt.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line">queInt.<span class="built_in">pop</span>();</span><br><span class="line">queInt.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//此时queInt存放的元素是5,7,9</span></span><br></pre></td></tr></table></figure><h2 id="4、queue对象的拷贝构造与赋值"><a href="#4、queue对象的拷贝构造与赋值" class="headerlink" title="4、queue对象的拷贝构造与赋值"></a>4、queue对象的拷贝构造与赋值</h2><ul><li><strong>queue(const queue &amp;que);</strong>        &#x2F;&#x2F;拷贝构造函数</li><li><strong>queue&amp; operator&#x3D;(const queue &amp;que);</strong>&#x2F;&#x2F;重载等号操作符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; queIntA;</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">queue&lt;<span class="type">int</span>&gt; <span class="title">queIntB</span><span class="params">(queIntA)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; queIntC;</span><br><span class="line">queIntC = queIntA;<span class="comment">//赋值</span></span><br></pre></td></tr></table></figure><h2 id="5、queue的数据存取"><a href="#5、queue的数据存取" class="headerlink" title="5、queue的数据存取"></a>5、queue的数据存取</h2><ul><li><strong>queue.back();</strong>    &#x2F;&#x2F;返回最后一个元素</li><li><strong>queue.front();</strong>   &#x2F;&#x2F;返回第一个元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; queIntA;</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> iFront = queIntA.<span class="built_in">front</span>();<span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> iBack = queIntA.<span class="built_in">back</span>();<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">queIntA.<span class="built_in">front</span>() = <span class="number">11</span>;<span class="comment">//11</span></span><br><span class="line">queIntA.<span class="built_in">back</span>() = <span class="number">19</span>;<span class="comment">//19</span></span><br></pre></td></tr></table></figure><h2 id="6、queue的大小"><a href="#6、queue的大小" class="headerlink" title="6、queue的大小"></a>6、queue的大小</h2><ul><li><strong>queue.empty();</strong>    &#x2F;&#x2F;判断队列是否为空</li><li><strong>queue.size();</strong>     &#x2F;&#x2F;返回队列的大小</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; queIntA; </span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">1</span>);   </span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">3</span>);  </span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">queIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!queIntA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iSize = queIntA.<span class="built_in">size</span>();<span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、优先级队列priority-queue"><a href="#7、优先级队列priority-queue" class="headerlink" title="7、优先级队列priority_queue"></a>7、优先级队列priority_queue</h2><ul><li>最大值优先级队列、最小值优先级队列</li><li>优先级队列适配器 STL priority_queue</li><li>用来开发一些特殊的应用,请对stl的类库,多做扩展性学习<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>, deque&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">pq.<span class="built_in">empty</span>()</span><br><span class="line">pq.<span class="built_in">size</span>()</span><br><span class="line">pq.<span class="built_in">top</span>()</span><br><span class="line">pq.<span class="built_in">pop</span>()</span><br><span class="line">pq.<span class="built_in">push</span>(item)</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue&quot;</span> </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main81</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; p1; <span class="comment">//默认是 最大值优先级队列 </span></span><br><span class="line"><span class="comment">//priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; p1; //相当于这样写</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; p2; <span class="comment">//最小值优先级队列</span></span><br><span class="line"></span><br><span class="line">p1.<span class="built_in">push</span>(<span class="number">33</span>);</span><br><span class="line">p1.<span class="built_in">push</span>(<span class="number">11</span>);</span><br><span class="line">p1.<span class="built_in">push</span>(<span class="number">55</span>);</span><br><span class="line">p1.<span class="built_in">push</span>(<span class="number">22</span>);</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;队列大小&quot;</span> &lt;&lt; p1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;队头&quot;</span> &lt;&lt; p1.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p1.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p1.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">p1.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;测试 最小值优先级队列&quot;</span> &lt;&lt; endl;</span><br><span class="line">p2.<span class="built_in">push</span>(<span class="number">33</span>);</span><br><span class="line">p2.<span class="built_in">push</span>(<span class="number">11</span>);</span><br><span class="line">p2.<span class="built_in">push</span>(<span class="number">55</span>);</span><br><span class="line">p2.<span class="built_in">push</span>(<span class="number">22</span>);</span><br><span class="line"><span class="keyword">while</span> (p2.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p2.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">p2.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;STL容器-Queue&quot;&gt;&lt;a href=&quot;#STL容器-Queue&quot; class=&quot;headerlink&quot; title=&quot;STL容器-Queue&quot;&gt;&lt;/a&gt;STL容器-Queue&lt;/h1&gt;&lt;h2 id=&quot;1、Queue容器简介&quot;&gt;&lt;a href=&quot;#1、Queue容器简介&quot; class=&quot;headerlink&quot; title=&quot;1、Queue容器简介&quot;&gt;&lt;/a&gt;1、Queue容器简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;queue是队列容器，是一种“先进先出”的容器。&lt;/li&gt;
&lt;li&gt;queue是简单地装饰deque容器而成为另外的一种容器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#include &amp;lt;queue&amp;gt;&lt;/code&gt;</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="STL" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/STL/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>STL容器-Stack</title>
    <link href="http://example.com/2022/09/05/STL%E5%AE%B9%E5%99%A8-Stack/"/>
    <id>http://example.com/2022/09/05/STL%E5%AE%B9%E5%99%A8-Stack/</id>
    <published>2022-09-05T01:55:59.000Z</published>
    <updated>2022-09-06T03:35:54.706Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="STL容器-Stack"><a href="#STL容器-Stack" class="headerlink" title="STL容器-Stack"></a>STL容器-Stack</h1><h2 id="1、Stack容器简介"><a href="#1、Stack容器简介" class="headerlink" title="1、Stack容器简介"></a>1、Stack容器简介</h2><p>Stack简介</p><ul><li>stack是堆栈容器，是一种“先进后出”的容器。</li><li>stack是简单地装饰deque容器而成为另外的一种容器。</li><li><code>#include &lt;stack&gt;</code><span id="more"></span></li></ul><h2 id="2、stack对象的默认构造"><a href="#2、stack对象的默认构造" class="headerlink" title="2、stack对象的默认构造"></a>2、stack对象的默认构造</h2><p>stack采用模板类实现，stack对象的默认构造形式： <strong><code>stack &lt;T&gt; stkT;</code></strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stack &lt;<span class="type">int</span>&gt; stkInt;         <span class="comment">//一个存放int的stack容器。</span></span><br><span class="line">stack &lt;<span class="type">float</span>&gt; stkFloat;     <span class="comment">//一个存放float的stack容器。</span></span><br><span class="line">stack &lt;string&gt; stkString;   <span class="comment">//一个存放string的stack容器。</span></span><br><span class="line">...    </span><br><span class="line"><span class="comment">//尖括号内还可以设置指针类型或自定义类型。</span></span><br></pre></td></tr></table></figure><h2 id="3、stack的push-与pop-方法"><a href="#3、stack的push-与pop-方法" class="headerlink" title="3、stack的push()与pop()方法"></a>3、stack的push()与pop()方法</h2><ul><li><strong>stack.push(elem);</strong>   &#x2F;&#x2F;往栈头添加元素</li><li><strong>stack.pop();</strong>        &#x2F;&#x2F;从栈头移除第一个元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; stkInt;</span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">stkInt.<span class="built_in">pop</span>();</span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">stkInt.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line">stkInt.<span class="built_in">pop</span>();</span><br><span class="line">stkInt.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//此时stkInt存放的元素是1,5  </span></span><br></pre></td></tr></table></figure><h2 id="4、stack对象的拷贝构造与赋值"><a href="#4、stack对象的拷贝构造与赋值" class="headerlink" title="4、stack对象的拷贝构造与赋值"></a>4、stack对象的拷贝构造与赋值</h2><ul><li><strong>stack(const stack &amp;stk);</strong>        &#x2F;&#x2F;拷贝构造函数</li><li><strong>stack&amp; operator&#x3D;(const stack &amp;stk);</strong> &#x2F;&#x2F;重载等号操作符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; stkIntA;</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">stack&lt;<span class="type">int</span>&gt; <span class="title">stkIntB</span><span class="params">(stkIntA)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stkIntC;</span><br><span class="line">stkIntC = stkIntA;<span class="comment">//赋值</span></span><br></pre></td></tr></table></figure><h2 id="5、stack的数据存取"><a href="#5、stack的数据存取" class="headerlink" title="5、stack的数据存取"></a>5、stack的数据存取</h2><ul><li><strong>stack.top();</strong>  &#x2F;&#x2F;返回最后一个压入栈元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; stkIntA;</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> iTop = stkIntA.<span class="built_in">top</span>();<span class="comment">//9</span></span><br><span class="line">stkIntA.<span class="built_in">top</span>() = <span class="number">19</span>;<span class="comment">//19</span></span><br></pre></td></tr></table></figure><h2 id="6、stack的大小"><a href="#6、stack的大小" class="headerlink" title="6、stack的大小"></a>6、stack的大小</h2><ul><li><strong>stack.empty();</strong>       &#x2F;&#x2F;判断堆栈是否为空</li><li><strong>stack.size();</strong>    &#x2F;&#x2F;返回堆栈的大小</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; stkIntA;</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">stkIntA.<span class="built_in">push</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!stkIntA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iSize = stkIntA.<span class="built_in">size</span>();<span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;STL容器-Stack&quot;&gt;&lt;a href=&quot;#STL容器-Stack&quot; class=&quot;headerlink&quot; title=&quot;STL容器-Stack&quot;&gt;&lt;/a&gt;STL容器-Stack&lt;/h1&gt;&lt;h2 id=&quot;1、Stack容器简介&quot;&gt;&lt;a href=&quot;#1、Stack容器简介&quot; class=&quot;headerlink&quot; title=&quot;1、Stack容器简介&quot;&gt;&lt;/a&gt;1、Stack容器简介&lt;/h2&gt;&lt;p&gt;Stack简介&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stack是堆栈容器，是一种“先进后出”的容器。&lt;/li&gt;
&lt;li&gt;stack是简单地装饰deque容器而成为另外的一种容器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#include &amp;lt;stack&amp;gt;&lt;/code&gt;</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="STL" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/STL/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++标准库</title>
    <link href="http://example.com/2022/09/03/C-%E6%A0%87%E5%87%86%E5%BA%93/"/>
    <id>http://example.com/2022/09/03/C-%E6%A0%87%E5%87%86%E5%BA%93/</id>
    <published>2022-09-03T01:07:10.000Z</published>
    <updated>2022-09-03T03:09:36.611Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++标准库"></a>C++标准库</h1><p>C++强大的功能来源于其丰富的类库及库函数资源。C++标准库的内容总共在50个标准头文件中定义。在C++开发中，要尽可能地利用标准库完成。<span id="more"></span>这样做的直接好处包括：</p><ol><li>成本：已经作为标准提供，何苦再花费时间、人力重新开发呢；  </li><li>质量：标准库的都是经过严格测试的，正确性有保证；</li><li>效率：关于人的效率已经体现在成本中了，关于代码的执行效率要相信实现标准库的大牛们的水平；</li><li>良好的编程风格：采用行业中普遍的做法进行开发。</li></ol><p>在C++程序设计课程中，尤其是作为第一门程序设计课程，我们注重了语法、语言的机制等方面的内容。程序设计能力的培养有个过程，跨过基本的原 理性知识直接进入到工程中的普遍做法，由于跨度决定了其难度。再者，在掌握了基本原理的基础上，在认识标准库的问题上完全可以凭借实践，逐步地掌握。标准库的学习不需要认认真真地读书，需要的是在了解概貌的情况下，在实践中深入。<br>这个任务就是要知道C++程序设计课程中不讲的，但对程序设计又很重要的这部分内容。至少我们要能先回答出“有什么”的问题。</p><p>C++标准库的内容分为10类，分别是（建议在阅读中，将你已经用过或听说过的头文件划出来）：</p><p>C1. 标准库中与语言支持功能相关的头文件</p><table><thead><tr><th align="left">头文件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>&lt;cstddef&gt;</code></td><td align="left">定义宏NULL和offsetof，以及其他标准类型size_t和ptrdiff_t。与对应的标准C头文件的区别是，NULL是C++空指针常量的补充定义，宏offsetof接受结构或者联合类型参数，只要他们没有成员指针类型的非静态成员即可。</td></tr><tr><td align="left"><code>&lt;limits&gt;</code></td><td align="left">提供与基本数据类型相关的定义。例如，对于每个数值数据类型，它定义了可以表示出来的最大值和最小值以及二进制数字的位数。</td></tr><tr><td align="left"><code>&lt;climits&gt;</code></td><td align="left">提供与基本整数数据类型相关的C样式定义。这些信息的C++样式定义在<code>&lt;limits&gt;</code>中</td></tr><tr><td align="left"><code>&lt;cfloat&gt;</code></td><td align="left">提供与基本浮点型数据类型相关的C样式定义。这些信息的C++样式定义在<code>&lt;limits&gt;</code>中</td></tr><tr><td align="left"><code>&lt;cstdlib&gt;</code></td><td align="left">提供支持程序启动和终止的宏和函数。这个头文件还声明了许多其他杂项函数，例如搜索和排序函数，从字符串转换为数值等函数。它与对应的标准C头文件 stdlib.h不同，定义了abort(void)。abort()函数还有额外的功能，它不为静态或自动对象调用析构函数，也不调用传给 atexit()函数的函数。它还定义了exit()函数的额外功能，可以释放静态对象，以注册的逆序调用用atexit()注册的函数。清除并关闭所有 打开的C流，把控制权返回给主机环境。</td></tr><tr><td align="left"><code>&lt;new&gt;</code></td><td align="left">支持动态内存分配</td></tr><tr><td align="left"><code>&lt;typeinfo&gt;</code></td><td align="left">支持变量在运行期间的类型标识</td></tr><tr><td align="left"><code>&lt;exception&gt;</code></td><td align="left">支持异常处理，这是处理程序中可能发生的错误的一种方式</td></tr><tr><td align="left"><code>&lt;cstdarg&gt;</code></td><td align="left">支持接受数量可变的参数的函数。即在调用函数时，可以给函数传送数量不等的数据项。它定义了宏va_arg、va_end、va_start以及va_list类型</td></tr><tr><td align="left"><code>&lt;csetjmp&gt;</code></td><td align="left">为C样式的非本地跳跃提供函数。这些函数在C++中不常用</td></tr><tr><td align="left"><code>&lt;csignal&gt;</code></td><td align="left">为中断处理提供C样式支持</td></tr></tbody></table><p>C2. 支持流输入&#x2F;输出的头文件 </p><table><thead><tr><th align="left">头文件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>&lt;iostream&gt;</code></td><td align="left">支持标准流cin、cout、cerr和clog的输入和输出，它还支持多字节字符标准流wcin、wcout、wcerr和wclog。</td></tr><tr><td align="left"><code>&lt;iomanip&gt;</code></td><td align="left">提供操纵程序，允许改变流的状态，从而改变输出的格式。</td></tr><tr><td align="left"><code>&lt;ios&gt;</code></td><td align="left">定义iostream的基类</td></tr><tr><td align="left"><code>&lt;istream&gt;</code></td><td align="left">为管理输出流缓存区的输入定义模板类</td></tr><tr><td align="left"><code>&lt;ostream&gt;</code></td><td align="left">为管理输出流缓存区的输出定义模板类</td></tr><tr><td align="left"><code>&lt;sstream&gt;</code></td><td align="left">支持字符串的流输入输出</td></tr><tr><td align="left"><code>&lt;fstream&gt;</code></td><td align="left">支持文件的流输入输出</td></tr><tr><td align="left"><code>&lt;iosfwd&gt;</code></td><td align="left">为输入输出对象提供向前的声明</td></tr><tr><td align="left"><code>&lt;streambuf&gt;</code></td><td align="left">支持流输入和输出的缓存</td></tr><tr><td align="left"><code>&lt;cstdio&gt;</code></td><td align="left">为标准流提供C样式的输入和输出</td></tr><tr><td align="left"><code>&lt;cwchar&gt;</code></td><td align="left">支持多字节字符的C样式输入输出</td></tr></tbody></table><p>C3. 与诊断功能相关的头文件 </p><table><thead><tr><th align="left">头文件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>&lt;stdexcept&gt;</code></td><td align="left">定义标准异常。异常是处理错误的方式</td></tr><tr><td align="left"><code>&lt;cassert&gt;</code></td><td align="left">定义断言宏，用于检查运行期间的情形</td></tr><tr><td align="left"><code>&lt;cerrno&gt;</code></td><td align="left">支持C样式的错误信息</td></tr></tbody></table><p>C4. 定义工具函数的头文件 </p><table><thead><tr><th align="left">头文件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>&lt;utility&gt;</code></td><td align="left">定义重载的关系运算符，简化关系运算符的写入，它还定义了pair类型，该类型是一种模板类型，可以存储一对值。这些功能在库的其他地方使用</td></tr><tr><td align="left"><code>&lt;functional&gt;</code></td><td align="left">定义了许多函数对象类型和支持函数对象的功能，函数对象是支持operator()()函数调用运算符的任意对象</td></tr><tr><td align="left"><code>&lt;memory&gt;</code></td><td align="left">给容器、管理内存的函数和auto_ptr模板类定义标准内存分配器</td></tr><tr><td align="left"><code>&lt;ctime&gt;</code></td><td align="left">支持系统时钟函数</td></tr></tbody></table><p>C5. 支持字符串处理的头文件    </p><table><thead><tr><th align="left">头文件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>&lt;string&gt;</code></td><td align="left">为字符串类型提供支持和定义，包括单字节字符串(由char组成)的string和多字节字符串(由wchar_t组成)</td></tr><tr><td align="left"><code>&lt;cctype&gt;</code></td><td align="left">单字节字符类别</td></tr><tr><td align="left"><code>&lt;cwctype&gt;</code></td><td align="left">多字节字符类别</td></tr><tr><td align="left"><code>&lt;cstring&gt;</code></td><td align="left">为处理非空字节序列和内存块提供函数。这不同于对应的标准C库头文件，几个C样式字符串的一般C库函数被返回值为const和非const的函数对替代了</td></tr><tr><td align="left"><code>&lt;cwchar&gt;</code></td><td align="left">为处理、执行I&#x2F;O和转换多字节字符序列提供函数，这不同于对应的标准C库头文件，几个多字节C样式字符串操作的一般C库函数被返回值为const和非const的函数对替代了。</td></tr><tr><td align="left"><code>&lt;cstdlib&gt;</code></td><td align="left">为把单字节字符串转换为数值、在多字节字符和多字节字符串之间转换提供函数</td></tr></tbody></table><p>C6. 定义容器类的模板的头文件   </p><table><thead><tr><th align="left">头文件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>&lt;vector&gt;</code></td><td align="left">定义vector序列模板，这是一个大小可以重新设置的数组类型，比普通数组更安全、更灵活</td></tr><tr><td align="left"><code>&lt;list&gt;</code></td><td align="left">定义list序列模板，这是一个序列的链表，常常在任意位置插入和删除元素</td></tr><tr><td align="left"><code>&lt;deque&gt;</code></td><td align="left">定义deque序列模板，支持在开始和结尾的高效插入和删除操作</td></tr><tr><td align="left"><code>&lt;queue&gt;</code></td><td align="left">为队列(先进先出)数据结构定义序列适配器queue和priority_queue</td></tr><tr><td align="left"><code>&lt;stack&gt;</code></td><td align="left">为堆栈(后进先出)数据结构定义序列适配器stack</td></tr><tr><td align="left"><code>&lt;map&gt;</code></td><td align="left">map是一个关联容器类型，允许根据键值是唯一的，且按照升序存储。multimap类似于map，但键不是唯一的。</td></tr><tr><td align="left"><code>&lt;set&gt;</code></td><td align="left">set是一个关联容器类型，用于以升序方式存储唯一值。multiset类似于set，但是值不必是唯一的。</td></tr><tr><td align="left"><code>&lt;bitset&gt;</code></td><td align="left">为固定长度的位序列定义bitset模板，它可以看作固定长度的紧凑型bool数组</td></tr></tbody></table><p>C7. 支持迭代器的头文件   </p><table><thead><tr><th align="left">头文件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>&lt;iterator&gt;</code></td><td align="left">给迭代器提供定义和支持</td></tr></tbody></table><p>C8. 有关算法的头文件   </p><table><thead><tr><th align="left">头文件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>&lt;algorithm&gt;</code></td><td align="left">提供一组基于算法的函数，包括置换、排序、合并和搜索</td></tr><tr><td align="left"><code>&lt;cstdlib&gt;</code></td><td align="left">声明C标准库函数bsearch()和qsort()，进行搜索和排序</td></tr><tr><td align="left"><code>&lt;ciso646&gt;</code></td><td align="left">允许在代码中使用and代替&amp;&amp;</td></tr></tbody></table><p>C9. 有关数值操作的头文件   </p><table><thead><tr><th align="left">头文件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>&lt;complex&gt;</code></td><td align="left">支持复杂数值的定义和操作</td></tr><tr><td align="left"><code>&lt;valarray&gt;</code></td><td align="left">支持数值矢量的操作</td></tr><tr><td align="left"><code>&lt;numeric&gt;</code></td><td align="left">在数值序列上定义一组一般数学操作，例如accumulate和inner_product</td></tr><tr><td align="left"><code>&lt;cmath&gt;</code></td><td align="left">这是C数学库，其中还附加了重载函数，以支持C++约定</td></tr><tr><td align="left"><code>&lt;cstdlib&gt;</code></td><td align="left">提供的函数可以提取整数的绝对值，对整数进行取余数操作</td></tr></tbody></table><p>C10. 有关本地化的头文件   </p><table><thead><tr><th align="left">头文件</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>&lt;locale&gt;</code></td><td align="left">提供的本地化包括字符类别、排序序列以及货币和日期表示。</td></tr><tr><td align="left"><code>&lt;clocale&gt;</code></td><td align="left">对本地化提供C样式支持</td></tr></tbody></table><p>C++标准库的所有头文件都没有扩展名。C++标准库以<code>&lt;cname&gt;</code>形式的标准头文件提供。在<code>&lt;cname&gt;</code>形式标准的头文件中，与宏相关的名称在全局作用域中定义，其他名称在std命名空间中声明。在C++中还可以使用name.h 形式的标准C库头文件名。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;C-标准库&quot;&gt;&lt;a href=&quot;#C-标准库&quot; class=&quot;headerlink&quot; title=&quot;C++标准库&quot;&gt;&lt;/a&gt;C++标准库&lt;/h1&gt;&lt;p&gt;C++强大的功能来源于其丰富的类库及库函数资源。C++标准库的内容总共在50个标准头文件中定义。在C++开发中，要尽可能地利用标准库完成。</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C++" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>STL容器-Deque</title>
    <link href="http://example.com/2022/09/02/STL%E5%AE%B9%E5%99%A8-Deque/"/>
    <id>http://example.com/2022/09/02/STL%E5%AE%B9%E5%99%A8-Deque/</id>
    <published>2022-09-02T09:19:41.000Z</published>
    <updated>2022-09-06T03:37:16.277Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="STL容器-Deque"><a href="#STL容器-Deque" class="headerlink" title="STL容器-Deque"></a>STL容器-Deque</h1><h2 id="1、Deque容器简介"><a href="#1、Deque容器简介" class="headerlink" title="1、Deque容器简介"></a>1、Deque容器简介</h2><ul><li>deque是“double-ended queue”的缩写，和vector一样都是STL的容器，<strong>deque是双端数组</strong>，而vector是单端的。</li><li>deque在接口上和vector非常相似，在许多操作的地方可以直接替换。<span id="more"></span></li><li>deque可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法）。</li><li>deque头部和尾部添加或移除元素都非常快速。但是在中部安插元素或移除元素比较费时。</li><li><code>#include &lt;deque&gt;</code></li></ul><h2 id="2、deque对象的默认构造"><a href="#2、deque对象的默认构造" class="headerlink" title="2、deque对象的默认构造"></a>2、deque对象的默认构造</h2><p>deque采用模板类实现，deque对象的默认构造形式：**<code>deque&lt;T&gt; deqT</code>**;  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deque &lt;<span class="type">int</span>&gt; deqInt;           <span class="comment">//一个存放int的deque容器。</span></span><br><span class="line">deque &lt;<span class="type">float</span>&gt; deqFloat;       <span class="comment">//一个存放float的deque容器。</span></span><br><span class="line">deque &lt;string&gt; deqString;     <span class="comment">//一个存放string的deque容器。</span></span><br><span class="line">...   </span><br><span class="line"><span class="comment">//尖括号内还可以设置指针类型或自定义类型。 </span></span><br></pre></td></tr></table></figure><h2 id="3、deque末尾的添加移除操作"><a href="#3、deque末尾的添加移除操作" class="headerlink" title="3、deque末尾的添加移除操作"></a>3、deque末尾的添加移除操作</h2><p><strong>理论知识:</strong></p><ul><li><strong>deque.push_back(elem);</strong>&#x2F;&#x2F;在容器尾部添加一个数据</li><li><strong>deque.push_front(elem);</strong>&#x2F;&#x2F;在容器头部插入一个数据</li><li><strong>deque.pop_back();</strong>    &#x2F;&#x2F;删除容器最后一个数据</li><li><strong>deque.pop_front();</strong>&#x2F;&#x2F;删除容器第一个数据</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; deqInt;</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line">deqInt.<span class="built_in">pop_front</span>();</span><br><span class="line">deqInt.<span class="built_in">pop_front</span>();</span><br><span class="line">deqInt.<span class="built_in">push_front</span>(<span class="number">11</span>);</span><br><span class="line">deqInt.<span class="built_in">push_front</span>(<span class="number">13</span>);</span><br><span class="line">deqInt.<span class="built_in">pop_back</span>();</span><br><span class="line">deqInt.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">//deqInt  &#123; 13,11,5&#125;</span></span><br></pre></td></tr></table></figure><h2 id="4、deque的数据存取"><a href="#4、deque的数据存取" class="headerlink" title="4、deque的数据存取"></a>4、deque的数据存取</h2><p><strong>理论知识:</strong></p><ul><li><strong>deque.at(idx);</strong>  &#x2F;&#x2F;返回索引idx所指的数据，如果idx越界，抛出out_of_range。</li><li><strong>deque[idx];</strong>     &#x2F;&#x2F;返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。</li><li><strong>deque.front();</strong>  &#x2F;&#x2F;返回第一个数据。</li><li><strong>deque.back();</strong>   &#x2F;&#x2F;返回最后一个数据</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; deqInt;</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> iA = deqInt.<span class="built_in">at</span>(<span class="number">0</span>);<span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> iB = deqInt[<span class="number">1</span>];<span class="comment">//3</span></span><br><span class="line">deqInt.<span class="built_in">at</span>(<span class="number">0</span>) = <span class="number">99</span>;<span class="comment">//99</span></span><br><span class="line">deqInt[<span class="number">1</span>] = <span class="number">88</span>;    <span class="comment">//88</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> iFront = deqInt.<span class="built_in">front</span>();<span class="comment">//99</span></span><br><span class="line"><span class="type">int</span> iBack = deqInt.<span class="built_in">back</span>();    <span class="comment">//9</span></span><br><span class="line">deqInt.<span class="built_in">front</span>() = <span class="number">77</span>;<span class="comment">//77</span></span><br><span class="line">deqInt.<span class="built_in">back</span>() = <span class="number">66</span>;    <span class="comment">//66</span></span><br></pre></td></tr></table></figure><h2 id="5、deque与迭代器"><a href="#5、deque与迭代器" class="headerlink" title="5、deque与迭代器"></a>5、deque与迭代器</h2><p><strong>理论知识：</strong></p><ul><li><strong>deque.begin();</strong>  &#x2F;&#x2F;返回容器中第一个元素的迭代器。</li><li><strong>deque.end();</strong>    &#x2F;&#x2F;返回容器中最后一个元素之后的迭代器。</li><li><strong>deque.rbegin();</strong> &#x2F;&#x2F;返回容器中倒数第一个元素的迭代器。</li><li><strong>deque.rend();</strong>   &#x2F;&#x2F;返回容器中倒数最后一个元素之后的迭代器。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; deqInt;</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">deqInt.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::iterator it=deqInt.<span class="built_in">begin</span>(); it!=deqInt.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::reverse_iterator rit=deqInt.<span class="built_in">rbegin</span>(); rit!=deqInt.<span class="built_in">rend</span>(); ++rit)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *rit;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//9 7 5 3 1</span></span><br></pre></td></tr></table></figure><h2 id="6、deque对象的带参数构造"><a href="#6、deque对象的带参数构造" class="headerlink" title="6、deque对象的带参数构造"></a>6、deque对象的带参数构造</h2><p><strong>理论知识：</strong></p><ul><li><strong>deque(beg,end);</strong>    &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。</li><li><strong>deque(n,elem);</strong>     &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li><li><strong>deque(const deque  &amp;deq);</strong>  &#x2F;&#x2F;拷贝构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; deqIntA;</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">deqIntB</span><span class="params">(deqIntA.begin(),deqIntA.end())</span></span>;<span class="comment">//1 3 5 7 9</span></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">deqIntC</span><span class="params">(<span class="number">5</span>,<span class="number">8</span>)</span></span>;<span class="comment">//8 8 8 8 8</span></span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">deqIntD</span><span class="params">(deqIntA)</span></span>;<span class="comment">//1 3 5 7 9</span></span><br></pre></td></tr></table></figure><h2 id="7、deque的赋值"><a href="#7、deque的赋值" class="headerlink" title="7、deque的赋值"></a>7、deque的赋值</h2><p><strong>理论知识：</strong></p><ul><li><strong>deque.assign(beg,end);</strong>  &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</li><li><strong>deque.assign(n,elem);</strong>   &#x2F;&#x2F;将n个elem拷贝赋值给本身。</li><li><strong>deque&amp; operator&#x3D;(const deque &amp;deq);</strong>&#x2F;&#x2F;重载等号操作符 </li><li><strong>deque.swap(deq);</strong>        &#x2F;&#x2F; 将vec与本身的元素互换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; deqIntA,deqIntB,deqIntC,deqIntD;</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">deqIntB.<span class="built_in">assign</span>(deqIntA.<span class="built_in">begin</span>(),deqIntA.<span class="built_in">end</span>());<span class="comment">// 1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line">deqIntC.<span class="built_in">assign</span>(<span class="number">5</span>,<span class="number">8</span>);<span class="comment">//8 8 8 8 8</span></span><br><span class="line"></span><br><span class="line">deqIntD = deqIntA;<span class="comment">//1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line">deqIntC.<span class="built_in">swap</span>(deqIntD);<span class="comment">//互换</span></span><br></pre></td></tr></table></figure><h2 id="8、deque的大小"><a href="#8、deque的大小" class="headerlink" title="8、deque的大小"></a>8、deque的大小</h2><p><strong>理论知识：</strong></p><ul><li><strong>deque.size();</strong>        &#x2F;&#x2F;返回容器中元素的个数</li><li><strong>deque.empty();</strong>        &#x2F;&#x2F;判断容器是否为空</li><li><strong>deque.resize(num);</strong>    &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li><li><strong>deque.resize(num, elem);</strong>  &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; deqIntA;</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">deqIntA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> iSize = deqIntA.<span class="built_in">size</span>(); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!deqIntA.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    deqIntA.<span class="built_in">resize</span>(<span class="number">5</span>);<span class="comment">//1 3 5 0 0</span></span><br><span class="line">    deqIntA.<span class="built_in">resize</span>(<span class="number">7</span>,<span class="number">1</span>);<span class="comment">//1 3 5 0 0 1 1</span></span><br><span class="line">    deqIntA.<span class="built_in">resize</span>(<span class="number">2</span>);<span class="comment">//1 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、deque的插入"><a href="#9、deque的插入" class="headerlink" title="9、deque的插入"></a>9、deque的插入</h2><p><strong>理论知识：</strong></p><ul><li><strong>deque.insert(pos,elem);</strong>      &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。</li><li><strong>deque.insert(pos,n,elem);</strong>     &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</li><li><strong>deque.insert(pos,beg,end);</strong>   &#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; deqA;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; deqB;</span><br><span class="line"></span><br><span class="line">deqA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">deqA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">deqA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deqA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">deqA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">deqB.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">deqB.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">deqB.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">deqB.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">deqA.<span class="built_in">insert</span>(deqA.<span class="built_in">begin</span>(), <span class="number">11</span>);    <span class="comment">//&#123;11, 1, 3, 5, 7, 9&#125;</span></span><br><span class="line">deqA.<span class="built_in">insert</span>(deqA.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">2</span>,<span class="number">33</span>);<span class="comment">//&#123;11,33,33,1,3,5,7,9&#125;</span></span><br><span class="line">deqA.<span class="built_in">insert</span>(deqA.<span class="built_in">begin</span>() , deqB.<span class="built_in">begin</span>() , deqB.<span class="built_in">end</span>() );<span class="comment">//&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125;</span></span><br></pre></td></tr></table></figure><h2 id="10、deque的删除"><a href="#10、deque的删除" class="headerlink" title="10、deque的删除"></a>10、deque的删除</h2><p><strong>理论知识：</strong></p><ul><li><strong>deque.clear();</strong>     &#x2F;&#x2F;移除容器的所有数据</li><li><strong>deque.erase(beg,end);</strong>  &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li><li><strong>deque.erase(pos);</strong>      &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">删除区间内的元素</span><br><span class="line">deqInt是用deque&lt;<span class="type">int</span>&gt;声明的容器，现已包含按顺序的<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>元素。</span><br><span class="line">deque&lt;<span class="type">int</span>&gt;::iterator itBegin=deqInt.<span class="built_in">begin</span>()+<span class="number">1</span>;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt;::iterator itEnd=deqInt.<span class="built_in">begin</span>()+<span class="number">3</span>;</span><br><span class="line">deqInt.<span class="built_in">erase</span>(itBegin,itEnd);</span><br><span class="line"><span class="comment">//此时容器deqInt包含按顺序的1,6,9三个元素。</span></span><br><span class="line"></span><br><span class="line">假设 deqInt 包含<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>，删除容器中等于<span class="number">3</span>的元素</span><br><span class="line"><span class="keyword">for</span>(deque&lt;<span class="type">int</span>&gt;::iterator it=deqInt.<span class="built_in">being</span>(); it!=deqInt.<span class="built_in">end</span>(); )    <span class="comment">//小括号里不需写  ++it</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(*it == <span class="number">3</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        it  =  deqInt.<span class="built_in">erase</span>(it);       <span class="comment">//以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。</span></span><br><span class="line">        <span class="comment">//此时，不执行  ++it；  </span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       ++it;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除deqInt的所有元素</span></span><br><span class="line">deqInt.<span class="built_in">clear</span>();<span class="comment">//容器为空</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;STL容器-Deque&quot;&gt;&lt;a href=&quot;#STL容器-Deque&quot; class=&quot;headerlink&quot; title=&quot;STL容器-Deque&quot;&gt;&lt;/a&gt;STL容器-Deque&lt;/h1&gt;&lt;h2 id=&quot;1、Deque容器简介&quot;&gt;&lt;a href=&quot;#1、Deque容器简介&quot; class=&quot;headerlink&quot; title=&quot;1、Deque容器简介&quot;&gt;&lt;/a&gt;1、Deque容器简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;deque是“double-ended queue”的缩写，和vector一样都是STL的容器，&lt;strong&gt;deque是双端数组&lt;/strong&gt;，而vector是单端的。&lt;/li&gt;
&lt;li&gt;deque在接口上和vector非常相似，在许多操作的地方可以直接替换。</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="STL" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/STL/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>STL容器-Vector</title>
    <link href="http://example.com/2022/09/02/STL%E5%AE%B9%E5%99%A8-Vector/"/>
    <id>http://example.com/2022/09/02/STL%E5%AE%B9%E5%99%A8-Vector/</id>
    <published>2022-09-02T09:19:16.000Z</published>
    <updated>2022-09-06T03:36:23.021Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="STL容器-Vector"><a href="#STL容器-Vector" class="headerlink" title="STL容器-Vector"></a>STL容器-Vector</h1><h2 id="1、Vector容器简介"><a href="#1、Vector容器简介" class="headerlink" title="1、Vector容器简介"></a>1、Vector容器简介</h2><ul><li>vector是将元素置于一个动态数组中加以管理的容器。</li><li>vector可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法）。</li><li>vector尾部添加或移除元素非常快速。但是在中部或头部插入元素或移除元素比较费时。<span id="more"></span></li></ul><h2 id="2、Vector对象的默认构造"><a href="#2、Vector对象的默认构造" class="headerlink" title="2、Vector对象的默认构造"></a>2、Vector对象的默认构造</h2><p>vector采用模板类实现，vector对象的默认构造形式<br><strong>vector<T> vecT;</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vecInt;        <span class="comment">//一个存放int的vector容器。</span></span><br><span class="line">vector&lt;<span class="type">float</span>&gt; vecFloat;     <span class="comment">//一个存放float的vector容器。</span></span><br><span class="line">vector&lt;string&gt; vecString;   <span class="comment">//一个存放string的vector容器。</span></span><br><span class="line">...            <span class="comment">//尖括号内还可以设置指针类型或自定义类型。</span></span><br><span class="line"></span><br><span class="line">Class CA&#123;&#125;;</span><br><span class="line">vector&lt;CA*&gt; vecpCA;  <span class="comment">//用于存放CA对象的指针的vector容器。</span></span><br><span class="line">vector&lt;CA&gt; vecCA;     <span class="comment">//用于存放CA对象的vector容器。由于容器元素的存放是按值复制的方式进行的，所以此时CA必须提供CA的拷贝构造函数，以保证CA对象间拷贝正常。</span></span><br></pre></td></tr></table></figure><h2 id="3、vector对象的带参数构造"><a href="#3、vector对象的带参数构造" class="headerlink" title="3、vector对象的带参数构造"></a>3、vector对象的带参数构造</h2><p><strong>理论知识</strong></p><ul><li><strong>vector(beg,end);</strong>    &#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。</li><li><strong>vector(n,elem);</strong>     &#x2F;&#x2F;构造函数将n个elem拷贝给本身。</li><li><strong>vector(const vector &amp;vec);</strong>   &#x2F;&#x2F;拷贝构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  iArray[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt;  <span class="title">vecIntA</span><span class="params">(iArray,  iArray+<span class="number">5</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vecIntB</span> <span class="params">(vecIntA.begin(), vecIntA.end())</span></span>;   <span class="comment">//用构造函数初始化容器vecIntB </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vecIntB</span> <span class="params">(vecIntA.begin(), vecIntA.begin()+<span class="number">3</span>)</span></span>;  </span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vecIntC</span><span class="params">(<span class="number">3</span>, <span class="number">9</span>)</span></span>; <span class="comment">//此代码运行后，容器vecIntB就存放3个元素，每个元素的值是9。</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vecIntD</span><span class="params">(vecIntA)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="4、vector的赋值"><a href="#4、vector的赋值" class="headerlink" title="4、vector的赋值"></a>4、vector的赋值</h2><p><strong>理论知识</strong></p><ul><li><strong>vector.assign(beg,end);</strong>    &#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。</li><li><strong>vector.assign(n,elem);</strong>     &#x2F;&#x2F;将n个elem拷贝赋值给本身。</li><li><strong>vector&amp; operator&#x3D;(const vector  &amp;vec);</strong>&#x2F;&#x2F;重载等号操作符</li><li><strong>vector.swap(vec);</strong>  &#x2F;&#x2F; 将vec与本身的元素互换。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vecIntA, vecIntB, vecIntC, vecIntD;</span><br><span class="line"><span class="type">int</span>  iArray[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">vecIntA.<span class="built_in">assign</span>(iArray,iArray+<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">vecIntB.<span class="built_in">assign</span>(vecIntA.<span class="built_in">begin</span>(),  vecIntA.<span class="built_in">end</span>());    <span class="comment">//用其它容器的迭代器作参数。</span></span><br><span class="line"></span><br><span class="line">vecIntC.<span class="built_in">assign</span>(<span class="number">3</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecIntD;</span><br><span class="line">vecIntD = vecIntA;</span><br><span class="line"></span><br><span class="line">vecIntA.<span class="built_in">swap</span>(vecIntD);</span><br></pre></td></tr></table></figure><h2 id="5、vector的大小"><a href="#5、vector的大小" class="headerlink" title="5、vector的大小"></a>5、vector的大小</h2><p><strong>理论知识</strong></p><ul><li><strong>vector.size();</strong>   &#x2F;&#x2F;返回容器中元素的个数</li><li><strong>vector.empty();</strong>   &#x2F;&#x2F;判断容器是否为空</li><li><strong>vector.resize(num);</strong>   &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li><li><strong>vector.resize(num, elem);</strong>  &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vecInt是vector&lt;<span class="type">int</span>&gt;  声明的容器，现已包含<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>元素。</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> iSize = vecInt.<span class="built_in">size</span>();<span class="comment">//iSize == 3;</span></span><br><span class="line"><span class="type">bool</span> bEmpty = vecInt.<span class="built_in">empty</span>();<span class="comment">// bEmpty == false;</span></span><br><span class="line">vecInt.<span class="built_in">resize</span>(<span class="number">5</span>);   <span class="comment">//此时里面包含1,2,3,0,0元素。</span></span><br><span class="line">vecInt.<span class="built_in">resize</span>(<span class="number">8</span>,<span class="number">3</span>); <span class="comment">//此时里面包含1,2,3,0,0,3,3,3元素。</span></span><br><span class="line">vecInt.<span class="built_in">resize</span>(<span class="number">2</span>);   <span class="comment">//此时里面包含1,2元素。</span></span><br></pre></td></tr></table></figure><h2 id="6、vector末尾的添加移除操作"><a href="#6、vector末尾的添加移除操作" class="headerlink" title="6、vector末尾的添加移除操作"></a>6、vector末尾的添加移除操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vecInt;</span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">1</span>);  <span class="comment">//在容器尾部加入一个元素</span></span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">3</span>);  <span class="comment">//移除容器中最后一个元素</span></span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">5</span>);  </span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">7</span>); </span><br><span class="line">vecInt.<span class="built_in">push_back</span>(<span class="number">9</span>); </span><br><span class="line">vecInt.<span class="built_in">pop_back</span>();    </span><br><span class="line">vecInt.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">//&#123;5 ,7 ,9&#125;  </span></span><br></pre></td></tr></table></figure><h2 id="7、vector的数据存取"><a href="#7、vector的数据存取" class="headerlink" title="7、vector的数据存取"></a>7、vector的数据存取</h2><p><strong>理论知识</strong></p><ul><li><strong>vec.at(idx);</strong>  &#x2F;&#x2F;返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。</li><li><strong>vec[idx];</strong>  &#x2F;&#x2F;返回索引idx所指的数据，越界时，运行直接报错</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vector;    <span class="comment">//假设包含1 ,3 ,5 ,7 ,9</span></span><br><span class="line">vector.<span class="built_in">at</span>(<span class="number">2</span>) == vector[<span class="number">2</span>];<span class="comment">//5 true</span></span><br><span class="line">vector.<span class="built_in">at</span>(<span class="number">2</span>) = <span class="number">8</span>;  <span class="comment">//或 vector[2] = 8;</span></span><br><span class="line"><span class="comment">//vector 就包含 1, 3, 8, 7, 9值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> iF = vector.<span class="built_in">front</span>();<span class="comment">//iF==1</span></span><br><span class="line"><span class="type">int</span> iB = vector.<span class="built_in">back</span>();    <span class="comment">//iB==9</span></span><br><span class="line">vector.<span class="built_in">front</span>() = <span class="number">11</span>;    <span class="comment">//vector包含&#123;11,3,8,7,9&#125;</span></span><br><span class="line">vector.<span class="built_in">back</span>() = <span class="number">19</span>;        <span class="comment">//vector包含&#123;11,3,8,7,19&#125;</span></span><br></pre></td></tr></table></figure><h2 id="8、迭代器基本原理"><a href="#8、迭代器基本原理" class="headerlink" title="8、迭代器基本原理"></a>8、迭代器基本原理</h2><ul><li>迭代器是一个“可遍历STL容器内全部或部分元素”的对象。</li><li>迭代器指出容器中的一个特定位置。</li><li>迭代器就如同一个指针。</li><li>迭代器提供对一个容器中的对象的访问方法，并且可以定义了容器中对象的范围。</li><li>这里大概介绍一下迭代器的类别：<ul><li><strong>输入迭代器</strong>：也有叫法称之为“只读迭代器”，它从容器中读取元素，只能一次读入一个元素向前移动，只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列。</li><li><strong>输出迭代器</strong>：也有叫法称之为“只写迭代器”，它往容器中写入元素，只能一次写入一个元素向前移动，只支持一遍算法，同一个输出迭代器不能两遍遍历一个序列。</li><li><strong>正向迭代器</strong>：组合输入迭代器和输出迭代器的功能，还可以多次解析一个迭代器指定的位置，可以对一个值进行多次读&#x2F;写。</li><li><strong>双向迭代器</strong>：组合正向迭代器的功能，还可以通过–操作符向后移动位置。</li><li><strong>随机访问迭代器</strong>：组合双向迭代器的功能，还可以向前向后跳过任意个位置，可以直接访问容器中任何位置的元素。</li></ul></li><li>目前本系列教程所用到的容器，都支持双向迭代器或随机访问迭代器，下面将会详细介绍这两个类别的迭代器。</li></ul><h2 id="9、双向迭代器与随机访问迭代器"><a href="#9、双向迭代器与随机访问迭代器" class="headerlink" title="9、双向迭代器与随机访问迭代器"></a>9、双向迭代器与随机访问迭代器</h2><p><em>双向迭代器支持的操作：</em><br><code>it++,  ++it,    it--,   --it，*it， itA = itB， itA == itB，itA != itB</code><br>其中<strong>list,set,multiset,map,multimap</strong>支持双向迭代器。</p><p><em>随机访问迭代器支持的操作：</em><br>在双向迭代器的操作基础上添加 <code> it+=i， it-=i， it+i(或it=it+i)，it[i], itA&lt;itB,   itA&lt;=itB,  itA&gt;itB,  itA&gt;=itB</code> 的功能。<br>其中<strong>vector，deque</strong>支持随机访问迭代器。</p><h2 id="10、vector与迭代器的配合使用"><a href="#10、vector与迭代器的配合使用" class="headerlink" title="10、vector与迭代器的配合使用"></a>10、vector与迭代器的配合使用</h2><p><img src="https://pic.imgdb.cn/item/63131be316f2c2beb1dcde45.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;  vecInt;        <span class="comment">//假设包含1,3,5,7,9元素</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;<span class="comment">//声明容器vector&lt;int&gt;的迭代器。</span></span><br><span class="line">it = vecInt.<span class="built_in">begin</span>();        <span class="comment">// *it == 1</span></span><br><span class="line">++it;<span class="comment">//或者it++;  *it == 3  ，前++的效率比后++的效率高，前++返回引用，后++返回值。</span></span><br><span class="line">it += <span class="number">2</span>;<span class="comment">//*it == 7</span></span><br><span class="line">it = it+<span class="number">1</span>;<span class="comment">//*it == 9</span></span><br><span class="line">++it;<span class="comment">// it == vecInt.end();  此时不能再执行*it,会出错!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正向遍历：</span></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it=vecInt.<span class="built_in">begin</span>(); it!=vecInt.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iItem = *it; </span><br><span class="line">    cout &lt;&lt; iItem;    <span class="comment">//或直接使用  cout &lt;&lt; *it;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样子便打印出1 3 5 7 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//逆向遍历：</span></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::reverse_iterator rit=vecInt.<span class="built_in">rbegin</span>(); rit!=vecInt.<span class="built_in">rend</span>(); ++rit)    <span class="comment">//注意，小括号内仍是++rit</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> iItem  = *rit;</span><br><span class="line">    cout &lt;&lt; iItem;  <span class="comment">//或直接使用cout &lt;&lt; *rit;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时将打印出9,7,5,3,1</span></span><br><span class="line"><span class="comment">//注意，这里迭代器的声明采用vector&lt;int&gt;::reverse_iterator，而非vector&lt;int&gt;::iterator。</span></span><br></pre></td></tr></table></figure><p><strong>迭代器还有其它两种声明方法：</strong><br><code>vector&lt;int&gt;::const_iterator</code> 与 <code>vector&lt;int&gt;::const_reverse_iterator</code></p><p>以上两种分别是vector<int>::iterator 与vector<int>::reverse_iterator 的只读形式，使用这两种迭代器时，不会修改到容器中的值。<br>备注：不过容器中的insert和erase方法仅接受这四种类型中的iterator，其它三种不支持。<strong>《Effective STL》建议我们尽量使用iterator取代const_iterator、reverse_iterator和const_reverse_iterator。</strong></p><h2 id="11、vector的插入"><a href="#11、vector的插入" class="headerlink" title="11、vector的插入"></a>11、vector的插入</h2><p><strong>理论知识</strong></p><ul><li><strong>vector.insert(pos,elem);</strong>   &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。</li><li><strong>vector.insert(pos,n,elem);</strong>   &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。</li><li><strong>vector.insert(pos,beg,end);</strong>   &#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值</li></ul><p>简单案例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vecA;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecB;</span><br><span class="line"></span><br><span class="line">vecA.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">vecA.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">vecA.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">vecA.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">vecA.<span class="built_in">push_back</span>(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">vecB.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">vecB.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">vecB.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line">vecB.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">vecA.<span class="built_in">insert</span>(vecA.<span class="built_in">begin</span>(), <span class="number">11</span>);<span class="comment">//&#123;11, 1, 3, 5, 7, 9&#125;</span></span><br><span class="line">vecA.<span class="built_in">insert</span>(vecA.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">2</span>,<span class="number">33</span>);<span class="comment">//&#123;11,33,33,1,3,5,7,9&#125;</span></span><br><span class="line">vecA.<span class="built_in">insert</span>(vecA.<span class="built_in">begin</span>() , vecB.<span class="built_in">begin</span>() , vecB.<span class="built_in">end</span>() );<span class="comment">//&#123;2,4,6,8,11,33,33,1,3,5,7,9&#125;</span></span><br></pre></td></tr></table></figure><h2 id="12、vector的删除"><a href="#12、vector的删除" class="headerlink" title="12、vector的删除"></a>12、vector的删除</h2><p><strong>理论知识</strong></p><ul><li><strong>vector.clear();</strong>  &#x2F;&#x2F;移除容器的所有数据</li><li><strong>vec.erase(beg,end);</strong>  &#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。</li><li><strong>vec.erase(pos);</strong>    &#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。</li></ul><p>简单案例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除区间内的元素</span></span><br><span class="line">vecInt是用vector&lt;<span class="type">int</span>&gt;声明的容器，现已包含按顺序的<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>元素。</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator itBegin = vecInt.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator itEnd = vecInt.<span class="built_in">begin</span>() + <span class="number">2</span>;</span><br><span class="line">vecInt.<span class="built_in">erase</span>(itBegin, itEnd);</span><br><span class="line"><span class="comment">//此时容器vecInt包含按顺序的1,6,9三个元素。</span></span><br><span class="line"></span><br><span class="line">假设 vecInt 包含<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>，删除容器中等于<span class="number">3</span>的元素</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = vecInt.<span class="built_in">being</span>(); it! = vecInt.<span class="built_in">end</span>(); )    <span class="comment">//小括号里不需写  ++it</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(*it == <span class="number">3</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        it  =  vecInt.<span class="built_in">erase</span>(it);     <span class="comment">//以迭代器为参数，删除元素3，并把数据删除后的下一个元素位置返回给迭代器。</span></span><br><span class="line">        <span class="comment">//此时，不执行  ++it；  </span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">       ++it;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除vecInt的所有元素</span></span><br><span class="line">vecInt.<span class="built_in">clear</span>();<span class="comment">//容器为空</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;STL容器-Vector&quot;&gt;&lt;a href=&quot;#STL容器-Vector&quot; class=&quot;headerlink&quot; title=&quot;STL容器-Vector&quot;&gt;&lt;/a&gt;STL容器-Vector&lt;/h1&gt;&lt;h2 id=&quot;1、Vector容器简介&quot;&gt;&lt;a href=&quot;#1、Vector容器简介&quot; class=&quot;headerlink&quot; title=&quot;1、Vector容器简介&quot;&gt;&lt;/a&gt;1、Vector容器简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;vector是将元素置于一个动态数组中加以管理的容器。&lt;/li&gt;
&lt;li&gt;vector可以随机存取元素（支持索引值直接存取， 用[]操作符或at()方法）。&lt;/li&gt;
&lt;li&gt;vector尾部添加或移除元素非常快速。但是在中部或头部插入元素或移除元素比较费时。</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="STL" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/STL/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>STL容器-String</title>
    <link href="http://example.com/2022/09/02/STL%E5%AE%B9%E5%99%A8-String/"/>
    <id>http://example.com/2022/09/02/STL%E5%AE%B9%E5%99%A8-String/</id>
    <published>2022-09-02T09:18:53.000Z</published>
    <updated>2022-09-06T03:35:58.094Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="STL容器-String"><a href="#STL容器-String" class="headerlink" title="STL容器-String"></a>STL容器-String</h1><h2 id="1、String的概念"><a href="#1、String的概念" class="headerlink" title="1、String的概念"></a>1、String的概念</h2><p>string是STL的字符串类型，通常用来表示字符串。而在使用string之前，字符串通常是用char<em>表示的。string与char</em>都可以用来表示字符串，那么二者有什么区别呢？<span id="more"></span></p><p><strong>string和char*的比较：</strong></p><ul><li>string是一个类, char*是一个指向字符的指针。string封装了char<em>，管理这个字符串，是一个char</em>型的容器。</li><li>string不用考虑内存释放和越界。string管理char*所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。</li><li>string提供了一系列的字符串操作函数。查找find，拷贝copy，删除erase，替换replace，插入insert。</li></ul><h2 id="2、String的构造函数"><a href="#2、String的构造函数" class="headerlink" title="2、String的构造函数"></a>2、String的构造函数</h2><ul><li>默认构造函数：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>();   <span class="comment">//构造一个空的字符串string s1。</span></span><br></pre></td></tr></table></figure></li><li>拷贝构造函数：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string &amp;str);<span class="comment">//构造一个与str一样的string。如string s1(s2)。</span></span><br></pre></td></tr></table></figure></li><li>带参数的构造函数：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span> *s);    <span class="comment">//用字符串s初始化</span></span><br><span class="line"><span class="built_in">string</span>(<span class="type">int</span> n,<span class="type">char</span> c);    <span class="comment">//用n个字符c初始化</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="3、String的存取字符操作"><a href="#3、String的存取字符操作" class="headerlink" title="3、String的存取字符操作"></a>3、String的存取字符操作</h2><ul><li>string类的字符操作：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> &amp;<span class="keyword">operator</span>[] (<span class="type">int</span> n) <span class="type">const</span>;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> &amp;<span class="title">at</span><span class="params">(<span class="type">int</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="type">char</span> &amp;<span class="keyword">operator</span>[] (<span class="type">int</span> n);</span><br><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">at</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure></li><li>operator[]和at()均返回当前字符串中第n个字符，但二者是有区别的：<blockquote><p>主要区别在于at()在越界时会抛出异常，[]在刚好越界时会返回(char)0，再继续越界时，编译器直接出错。如果你的程序希望可以通过try,catch捕获异常，建议采用at()。</p></blockquote></li></ul><h2 id="4、从string取得const-char-的操作"><a href="#4、从string取得const-char-的操作" class="headerlink" title="4、从string取得const char*的操作"></a>4、从string取得const char*的操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">c_str</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">//返回一个以&#x27;\0&#x27;结尾的字符串的首地址</span></span><br></pre></td></tr></table></figure><h2 id="5、把string拷贝到char-指向的内存空间的操作"><a href="#5、把string拷贝到char-指向的内存空间的操作" class="headerlink" title="5、把string拷贝到char*指向的内存空间的操作"></a>5、把string拷贝到char*指向的内存空间的操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">copy</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> n, <span class="type">int</span> pos=<span class="number">0</span>)</span> <span class="type">const</span></span>;  </span><br></pre></td></tr></table></figure><p>把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目。注意要保证s所指向的空间足够大以容纳当前字符串，不然会越界。</p><h2 id="6、string的长度"><a href="#6、string的长度" class="headerlink" title="6、string的长度"></a>6、string的长度</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">//返回当前字符串的长度。长度不包括字符串结尾的&#x27;\0&#x27;。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">//当前字符串是否为空</span></span><br></pre></td></tr></table></figure><h2 id="7、string的赋值"><a href="#7、string的赋值" class="headerlink" title="7、string的赋值"></a>7、string的赋值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string &amp;<span class="keyword">operator</span>=(<span class="type">const</span> string &amp;s);     <span class="comment">//把字符串s赋给当前的字符串</span></span><br><span class="line"><span class="function">string &amp;<span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;          <span class="comment">//把字符串s赋给当前的字符串</span></span><br><span class="line"><span class="function">string &amp;<span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> n)</span></span>;   <span class="comment">//把字符串s的前n个字符赋给当前的字符串</span></span><br><span class="line"><span class="function">string &amp;<span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;        <span class="comment">//把字符串s赋给当前字符串</span></span><br><span class="line"><span class="function">string &amp;<span class="title">assign</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> c)</span></span>;           <span class="comment">//用n个字符c赋给当前字符串</span></span><br><span class="line"><span class="function">string &amp;<span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;s,<span class="type">int</span> start, <span class="type">int</span> n)</span></span>;    <span class="comment">//把字符串s中从start开始的n个字符赋给当前字符串</span></span><br></pre></td></tr></table></figure><h2 id="8、string字符串连接"><a href="#8、string字符串连接" class="headerlink" title="8、string字符串连接"></a>8、string字符串连接</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> string &amp;s);  <span class="comment">//把字符串s连接到当前字符串结尾</span></span><br><span class="line">string &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span> *s);    <span class="comment">//把字符串s连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;        <span class="comment">//把字符串s连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s,<span class="type">int</span> n)</span></span>;  <span class="comment">//把字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;      <span class="comment">//同operator+=()</span></span><br><span class="line"><span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s,<span class="type">int</span> pos, <span class="type">int</span> n)</span></span>;  <span class="comment">//把字符串s中从pos开始的n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span></span>;        <span class="comment">//在当前字符串结尾添加n个字符c</span></span><br></pre></td></tr></table></figure><h2 id="9、string的比较"><a href="#9、string的比较" class="headerlink" title="9、string的比较"></a>9、string的比较</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> string &amp;s)</span> <span class="type">const</span></span>;  <span class="comment">//与字符串s比较</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> <span class="type">const</span></span>;    <span class="comment">//与字符串s比较</span></span><br></pre></td></tr></table></figure><p>compare函数在&gt;时返回 1，&lt;时返回 -1，&#x3D;&#x3D;时返回 0。比较区分大小写，比较时参考字典顺序，排越前面的越小。大写的A比小写的a小。</p><h2 id="10、string的子串"><a href="#10、string的子串" class="headerlink" title="10、string的子串"></a>10、string的子串</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">substr</span><span class="params">(<span class="type">int</span> pos=<span class="number">0</span>, <span class="type">int</span> n=npos)</span> <span class="type">const</span></span>;    <span class="comment">//返回由pos开始的n个字符组成的子字符串</span></span><br></pre></td></tr></table></figure><h2 id="11、string的查找-和-替换"><a href="#11、string的查找-和-替换" class="headerlink" title="11、string的查找 和 替换"></a>11、string的查找 和 替换</h2><p><strong>查找</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> c,<span class="type">int</span> pos=<span class="number">0</span>)</span> <span class="type">const</span></span>;  <span class="comment">//从pos开始查找字符c在当前字符串的位置 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> pos=<span class="number">0</span>)</span> <span class="type">const</span></span>;   <span class="comment">//从pos开始查找字符串s在当前字符串的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> pos=<span class="number">0</span>)</span> <span class="type">const</span></span>; <span class="comment">//从pos开始查找字符串s在当前字符串中的位置</span></span><br><span class="line"><span class="comment">//find函数如果查找不到，就返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">char</span> c, <span class="type">int</span> pos=npos)</span> <span class="type">const</span></span>;      <span class="comment">//从pos开始从后向前查找字符c在当前字符串中的位置 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> pos=npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rfind</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> pos=npos)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">//rfind是反向查找的意思，如果查找不到，返回-1</span></span><br></pre></td></tr></table></figure><p><strong>替换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string &amp;<span class="title">replace</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">const</span> <span class="type">char</span> *s)</span></span>;    <span class="comment">//删除从pos开始的n个字符，然后在pos处插入串s</span></span><br><span class="line"><span class="function">string &amp;<span class="title">replace</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">const</span> string &amp;s)</span></span>;  <span class="comment">//删除从pos开始的n个字符，然后在pos处插入串s</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(string &amp;s2)</span></span>;    <span class="comment">//交换当前字符串与s2的值</span></span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串的查找和替换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s1 = <span class="string">&quot;wbm hello wbm 111 wbm 222 wbm 333&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> index = s1.<span class="built_in">find</span>(<span class="string">&quot;wbm&quot;</span>, <span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;index: &quot;</span> &lt;&lt; index; </span><br><span class="line"></span><br><span class="line"><span class="comment">//求itcast出现的次数</span></span><br><span class="line"><span class="type">size_t</span> offindex = s1.<span class="built_in">find</span>(<span class="string">&quot;wbm&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (offindex != string::npos)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;在下标index: &quot;</span> &lt;&lt; offindex &lt;&lt; <span class="string">&quot;找到wbm\n&quot;</span>;</span><br><span class="line">offindex = offindex + <span class="number">1</span>;</span><br><span class="line">offindex = s1.<span class="built_in">find</span>(<span class="string">&quot;wbm&quot;</span>, offindex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换 </span></span><br><span class="line">string s2 = <span class="string">&quot;wbm hello wbm 111 wbm 222 wbm 333&quot;</span>;</span><br><span class="line">s2.<span class="built_in">replace</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;wbm&quot;</span>);</span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求itcast出现的次数</span></span><br><span class="line">offindex = s2.<span class="built_in">find</span>(<span class="string">&quot;wbm&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (offindex != string::npos)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;在下标index: &quot;</span> &lt;&lt; offindex &lt;&lt; <span class="string">&quot;找到wbm\n&quot;</span>;</span><br><span class="line">s2.<span class="built_in">replace</span>(offindex, <span class="number">3</span>, <span class="string">&quot;WBM&quot;</span>);</span><br><span class="line">offindex = offindex + <span class="number">1</span>;</span><br><span class="line">offindex = s1.<span class="built_in">find</span>(<span class="string">&quot;wbm&quot;</span>, offindex);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;替换以后的s2：&quot;</span> &lt;&lt; s2 &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12、String的区间删除和插入"><a href="#12、String的区间删除和插入" class="headerlink" title="12、String的区间删除和插入"></a>12、String的区间删除和插入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string &amp;<span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">const</span> <span class="type">char</span> *s)</span></span>;</span><br><span class="line"><span class="function">string &amp;<span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">const</span> string &amp;s)</span></span>;</span><br><span class="line"><span class="comment">//前两个函数在pos位置插入字符串s</span></span><br><span class="line"><span class="function">string &amp;<span class="title">insert</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n, <span class="type">char</span> c)</span></span>;  <span class="comment">//在pos位置 插入n个字符c</span></span><br><span class="line"></span><br><span class="line"><span class="function">string &amp;<span class="title">erase</span><span class="params">(<span class="type">int</span> pos=<span class="number">0</span>, <span class="type">int</span> n=npos)</span></span>;    <span class="comment">//删除pos开始的n个字符，返回修改后的字符串</span></span><br></pre></td></tr></table></figure><h2 id="13、string算法相关"><a href="#13、string算法相关" class="headerlink" title="13、string算法相关"></a>13、string算法相关</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s2 = <span class="string">&quot;AAAbbb&quot;</span>;</span><br><span class="line"><span class="built_in">transform</span>(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>(), s2.<span class="built_in">begin</span>(), toupper);</span><br><span class="line">cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string s3 = <span class="string">&quot;AAAbbb&quot;</span>;</span><br><span class="line"><span class="built_in">transform</span>(s3.<span class="built_in">begin</span>(), s3.<span class="built_in">end</span>(), s3.<span class="built_in">begin</span>(), tolower);</span><br><span class="line">cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;STL容器-String&quot;&gt;&lt;a href=&quot;#STL容器-String&quot; class=&quot;headerlink&quot; title=&quot;STL容器-String&quot;&gt;&lt;/a&gt;STL容器-String&lt;/h1&gt;&lt;h2 id=&quot;1、String的概念&quot;&gt;&lt;a href=&quot;#1、String的概念&quot; class=&quot;headerlink&quot; title=&quot;1、String的概念&quot;&gt;&lt;/a&gt;1、String的概念&lt;/h2&gt;&lt;p&gt;string是STL的字符串类型，通常用来表示字符串。而在使用string之前，字符串通常是用char&lt;em&gt;表示的。string与char&lt;/em&gt;都可以用来表示字符串，那么二者有什么区别呢？</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="STL" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/STL/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>STL理论基础</title>
    <link href="http://example.com/2022/09/02/STL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/09/02/STL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2022-09-02T09:18:02.000Z</published>
    <updated>2022-09-03T01:05:56.344Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="STL-标准模板库-理论基础"><a href="#STL-标准模板库-理论基础" class="headerlink" title="STL(标准模板库)理论基础"></a>STL(标准模板库)理论基础</h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p>STL（Standard Template Library，标准模板库)是惠普实验室开发的一系列软件的统称。现然主要出现在C++中，但在被引入C++之前该技术就已经存在了很长的一段时间。<span id="more"></span><br>STL的从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。几乎所有的代码都采用了模板类和模板函数的方式，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。在C++标准中，STL被组织为下面的13个头文件：<code>&lt;algorithm&gt;、&lt;deque&gt;、&lt;functional&gt;、&lt;iterator&gt;、&lt;vector&gt;、&lt;list&gt;、&lt;map&gt;、&lt;memory&gt;、&lt;numeric&gt;、&lt;queue&gt;、&lt;set&gt;、&lt;stack&gt; 和&lt;utility&gt;</code>。</p><p><img src="https://pic.imgdb.cn/item/6312a32216f2c2beb1758e6b.jpg"></p><p><strong>STL详细的说六大组件</strong>  </p><ul><li>容器（Container）</li><li>算法（Algorithm）</li><li>迭代器（Iterator）</li><li>仿函数（Function object）</li><li>适配器（Adaptor）</li><li>空间配制器（allocator）</li></ul><p><strong>使用STL的好处</strong>  </p><ol><li>STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</li><li>STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。<br>例如，在STL的vector容器中，可以放入元素、基础数据类型变量、元素的地址；STL的sort()函数可以用来操作vector,list等容器。</li><li>程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。</li><li>STL具有高可重用性，高性能，高移植性，跨平台的优点。<br><strong>高可重用性</strong>：STL中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。<br><strong>高性能</strong>：如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。(红黑树是平横二叉树的一种)<br><strong>高移植性</strong>：如在项目A上用STL编写的模块，可以直接移植到项目B上。<br><strong>跨平台</strong>：如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接编译。</li><li>程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。</li><li>了解到STL的这些好处，我们知道STL无疑是最值得C++程序员骄傲的一部分。每一个C＋＋程序员都应该好好学习STL。只有能够熟练使用STL的程序员，才是好的C++程序员。</li><li>总之：招聘工作中，经常遇到C++程序员对STL不是非常了解。大多是有一个大致的映像，而对于在什么情况下应该使用哪个容器和算法都感到比较茫然。STL是C++程序员的一项不可或缺的基本技能，掌握它对提升C++编程大有裨益。</li></ol><h2 id="2、容器"><a href="#2、容器" class="headerlink" title="2、容器"></a>2、容器</h2><p>在实际的开发过程中，数据结构本身的重要性不会逊于操作于数据结构的算法的重要性，当程序中存在着对时间要求很高的部分时，数据结构的选择就显得更加重要。<br>经典的数据结构数量有限，但是我们常常重复着一些为了实现向量、链表等结构而编写的代码，这些代码都十分相似，只是为了适应不同数据的变化而在 细节上有所出入。STL容器就为我们提供了这样的方便，它允许我们重复利用已有的实现构造自己的特定类型下的数据结构，通过设置一些模板，STL容器对最常用的数据结构提供了支持，这些模板的参数允许我们指定容器中元素的数据类型，可以将我们许多重复而乏味的工作简化。<br>容器部分主要由头文 件<code>&lt;vector&gt;,&lt;list&gt;,&lt;deque&gt;,&lt;set&gt;,&lt;map&gt;,&lt;stack&gt; 和&lt;queue&gt;</code>组成。对于常用的一些容器和容器适配器（可以看作由其它容器实现的容器），可以通过下表总结一下它们和相应头文件的对应关系。</p><h3 id="2-1、容器的概念"><a href="#2-1、容器的概念" class="headerlink" title="2.1、容器的概念"></a>2.1、容器的概念</h3><p><em><strong>用来管理一组元素</strong></em></p><p><img src="https://pic.imgdb.cn/item/6312a56816f2c2beb1766a9c.jpg"></p><h3 id="2-2、容器的分类"><a href="#2-2、容器的分类" class="headerlink" title="2.2、容器的分类"></a>2.2、容器的分类</h3><ul><li><strong>序列式容器（Sequence containers）</strong><br>每个元素都有固定位置－－取决于插入时机和地点，和元素值无关。<br>vector、deque、list  </li><li><strong>关联式容器（Associated containers）</strong><br>元素位置取决于特定的排序准则，和插入顺序无关。<br>set、multiset、map、multimap</li></ul><table><thead><tr><th align="left">数据结构</th><th align="left">描述</th><th align="left">实现头文件</th></tr></thead><tbody><tr><td align="left">向量(vector)</td><td align="left">连续存储的元素</td><td align="left"><vector></td></tr><tr><td align="left">列表(list)</td><td align="left">由节点组成的双向链表，每个结点包含着一个元素</td><td align="left"><code>&lt;list&gt;</code></td></tr><tr><td align="left">双队列(deque)</td><td align="left">连续存储的指向不同元素的指针所组成的数组</td><td align="left"><code>&lt;deque&gt;</code></td></tr><tr><td align="left">集合(set)</td><td align="left">由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序</td><td align="left"><code>&lt;set&gt;</code></td></tr><tr><td align="left">多重集合(multiset)</td><td align="left">允许存在两个次序相等的元素的集合</td><td align="left"><code>&lt;set&gt;</code></td></tr><tr><td align="left">栈(stack)</td><td align="left">后进先出的值的排列</td><td align="left"><code>&lt;stack&gt;</code></td></tr><tr><td align="left">队列(queue)</td><td align="left">先进先出的执的排列</td><td align="left"><code>&lt;queue&gt;</code></td></tr><tr><td align="left">优先队列(priority_queue)</td><td align="left">元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列</td><td align="left"><code>&lt;queue&gt;</code></td></tr><tr><td align="left">映射(map)</td><td align="left">由{键，值}对组成的集合，以某种作用于键对上的谓词排列</td><td align="left"><code>&lt;map&gt;</code></td></tr><tr><td align="left">多重映射(multimap)</td><td align="left">允许键对有相等的次序的映射</td><td align="left"><code>&lt;map&gt;</code></td></tr></tbody></table><h2 id="3、迭代器"><a href="#3、迭代器" class="headerlink" title="3、迭代器"></a>3、迭代器</h2><p>迭代器从作用上来说是最基本的部分，可是理解起来比前两者都要费力一些。软件设计有一个基本原则，所有的问题都可以通过引进一个间接层来简化，这种简化在STL中就是用迭代器来完成的。概括来说，迭代器在STL中用来将算法和容器联系起来，起着一种黏和剂的作用。几乎STL提供的所有算法都是通过迭代器存取元素序列进行工作的，每一个容器都定义了其本身所专有的迭代器，用以存取容器中的元素。<br>迭代器部分主要由头文件<code>&lt;utility&gt;,&lt;iterator&gt;和&lt;memory&gt;</code>组 成。<code>&lt;utility&gt;</code>是一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，<iterator>中提供了迭代器 使用的许多方法，而对于<code>&lt;memory&gt;</code>的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生 的临时对象提供机制,<code>&lt;memory&gt;</code>中的主要部分是模板类allocator，它负责产生所有容器中的默认分配器。</p><h2 id="4、算法"><a href="#4、算法" class="headerlink" title="4、算法"></a>4、算法</h2><p>函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使 用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提 供了相当多的有用算法。它是在一个有效的框架中完成这些算法的——可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种 类中的其他类型。</p><p>STL提供了大约100个实现算法的模版函数，比如算法for_each将为指定序列中的每一个元素调用指定的函数，stable_sort以你所指定的规则对序列进行稳定性排序等等。这样一来，只要熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要的功能并大大地提升效率。</p><p>算法部分主要由头文件<code>&lt;algorithm&gt;，&lt;numeric&gt;和&lt;functional&gt;</code>组成。<code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。<code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。<code>&lt;functional&gt;</code>中则定义了一些模板类，用以声明函数对象。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;STL-标准模板库-理论基础&quot;&gt;&lt;a href=&quot;#STL-标准模板库-理论基础&quot; class=&quot;headerlink&quot; title=&quot;STL(标准模板库)理论基础&quot;&gt;&lt;/a&gt;STL(标准模板库)理论基础&lt;/h1&gt;&lt;h2 id=&quot;1、基本概念&quot;&gt;&lt;a href=&quot;#1、基本概念&quot; class=&quot;headerlink&quot; title=&quot;1、基本概念&quot;&gt;&lt;/a&gt;1、基本概念&lt;/h2&gt;&lt;p&gt;STL（Standard Template Library，标准模板库)是惠普实验室开发的一系列软件的统称。现然主要出现在C++中，但在被引入C++之前该技术就已经存在了很长的一段时间。</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="STL" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/STL/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++类型转换</title>
    <link href="http://example.com/2022/09/01/C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://example.com/2022/09/01/C-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2022-09-01T01:50:32.000Z</published>
    <updated>2022-09-01T03:36:46.844Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-类型转换"><a href="#C-类型转换" class="headerlink" title="C++类型转换"></a>C++类型转换</h1><p>类型转换(cast)是将一种数据类型转换成另一种数据类型。例如，如果将一个整型值赋给一个浮点类型的变量，编译器会暗地里将其转换成浮点类型。<span id="more"></span>转换是非常有用的，但是它也会带来一些问题，比如在转换指针时，我们很可能将其转换成一个比它更大的类型，但这可能会破坏其他的数据。<br>应该小心类型转换，因为转换也就相当于对编译器说：忘记类型检查，把它看做其他的类型。<br>一般情况下，尽量少的去使用类型转换，除非用来解决非常特殊的问题。</p><p><strong>无论什么原因，任何一个程序如果使用很多类型转换都值得怀疑。</strong></p><p>标准c++提供了一个显示的转换的语法，来替代旧的C风格的类型转换。</p><p>使用C风格的强制转换可以把想要的任何东西转换成我们需要的类型。那为什么还需要一个新的C++类型的强制转换呢？<br><strong>新类型的强制转换可以提供更好的控制强制转换过程，允许控制各种不同种类的强制转换。C++风格的强制转换其他的好处是，它们能更清晰的表明它们要干什么。程序员只要扫一眼这样的代码，就能立即知道一个强制转换的目的。</strong></p><h2 id="1、类型转换名称和语法"><a href="#1、类型转换名称和语法" class="headerlink" title="1、类型转换名称和语法"></a>1、类型转换名称和语法</h2><p>C风格的强制类型转换(Type Cast)很简单，不管什么类型的转换统统是：<br><strong>TYPE b &#x3D; (TYPE)a</strong></p><p>C++风格的类型转换提供了4种类型转换操作符来应对不同场合的应用。</p><table><thead><tr><th align="left">操作符</th><th align="left">定义</th></tr></thead><tbody><tr><td align="left">static_cast</td><td align="left">静态类型转换。如int转换成char</td></tr><tr><td align="left">reinterpreter_cast</td><td align="left">重新解释类型</td></tr><tr><td align="left">dynamic_cast</td><td align="left">命名上理解是动态类型转换。如子类和父类之间的多态类型转换</td></tr><tr><td align="left">const_cast</td><td align="left">字面上理解就是去const属性</td></tr></tbody></table><p>4种类型转换的格式：<br><strong>TYPE B &#x3D; static_cast<TYPE> (a)</strong></p><h2 id="2、类型转换一般性介绍"><a href="#2、类型转换一般性介绍" class="headerlink" title="2、类型转换一般性介绍"></a>2、类型转换一般性介绍</h2><ol><li>static_cast&lt;&gt;()静态类型转换，编译的时c++编译器会做类型检查；基本类型能转换但是不能转换指针类型</li><li>若不同类型之间，进行强制类型转换，用reinterpret_cast&lt;&gt;() 进行重新解释</li><li>一般性结论：<br>C语言中能隐式类型转换的，在c++中可用 static_cast&lt;&gt;()进行类型转换。因C++编译器在编译检查一般都能通过；C语言中不能隐式类型转换的，在c++中可以用 reinterpret_cast&lt;&gt;() 进行强行类型解释。总结：static_cast&lt;&gt;()和reinterpret_cast&lt;&gt;() 基本上把C语言中的强制类型转换给覆盖<br>reinterpret_cast&lt;&gt;()很难保证移植性。</li><li>dynamic_cast&lt;&gt;()，动态类型转换，安全的基类和子类之间转换；运行时类型检查</li><li>const_cast&lt;&gt;()，去除变量的只读属性</li></ol><p></p><h2 id="3、静态转换-static-cast"><a href="#3、静态转换-static-cast" class="headerlink" title="3、静态转换(static_cast)"></a>3、静态转换(static_cast)</h2><ul><li>用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。<ul><li>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；</li><li>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。</li></ul></li><li><strong>用于基本数据类型之间的转换</strong>，如把int转换成char，把char转换成int。这种转换的安全性也要开发人员来保证。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>: <span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础数据类型转换</span></span><br><span class="line"><span class="type">void</span> test01 &#123;</span><br><span class="line">    <span class="type">double</span> dPi = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1静态的类型转换: 在编译的时 进行基本类型的转换 能替代c风格的类型转换 可以进行一部分检查</span></span><br><span class="line"><span class="type">int</span> num1 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt; (dPi);  <span class="comment">//c++的新式的类型转换运算符  </span></span><br><span class="line"><span class="type">int</span> num2 = (<span class="type">int</span>)dPi;<span class="comment">//c语言的 旧式类型转换 </span></span><br><span class="line"><span class="type">int</span> num3 = dPi;<span class="comment">//隐式类型转换</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num1:&quot;</span> &lt;&lt; num1 &lt;&lt; <span class="string">&quot; num2:&quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot; num3:&quot;</span> &lt;&lt; num3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *p1 = (<span class="type">char</span>*)<span class="string">&quot;hello world&quot;</span> ;</span><br><span class="line"><span class="type">int</span> *p2 = <span class="literal">NULL</span>;</span><br><span class="line">p2 = (<span class="type">int</span> *)p1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 基本类型能转换 但是不能转换指针类型</span></span><br><span class="line"><span class="comment">//p2 = static_cast&lt;int *&gt; (p1); //“static_cast”: 无法从“char *”转换为“int *”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3 可以使用  reinterpret_cast 进行重新解释 </span></span><br><span class="line">p2 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span> *&gt; (p1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 &quot;</span> &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2 &quot;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4 一般性的结论：c语言中能隐式类型转换的在c++中可以用 static_cast&lt;&gt;() 进行类型转换  </span></span><br><span class="line">    <span class="comment">//C++编译器在编译检查一般都能通过</span></span><br><span class="line"><span class="comment">//c语言中不能隐式类型转换的,在c++中可以用 reinterpret_cast&lt;&gt;() 进行强行类型解释 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承关系指针相互转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 继承关系指针转换</span></span><br><span class="line">    Animal* animal01 = <span class="literal">NULL</span>;</span><br><span class="line">Dog* dog01 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 子类指针转成父类指针,安全</span></span><br><span class="line">Animal* animal02 = <span class="built_in">static_cast</span>&lt;Animal*&gt;(dog01);</span><br><span class="line"><span class="comment">// 父类指针转成子类指针，不安全</span></span><br><span class="line">Dog* dog02 = <span class="built_in">static_cast</span>&lt;Dog*&gt;(animal01);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承关系引用相互转化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal ani_ref;</span><br><span class="line">Dog dog_ref;</span><br><span class="line"><span class="comment">// 继承关系指针转换</span></span><br><span class="line">Animal&amp; animal01 = ani_ref;</span><br><span class="line">Dog&amp; dog01 = dog_ref;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类指针转成父类指针,安全</span></span><br><span class="line">Animal&amp; animal02 = <span class="built_in">static_cast</span>&lt;Animal&amp;&gt;(dog01);</span><br><span class="line"><span class="comment">// 父类指针转成子类指针，不安全</span></span><br><span class="line">Dog&amp; dog02 = <span class="built_in">static_cast</span>&lt;Dog&amp;&gt;(animal01);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无继承关系指针转化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal* animal01 = <span class="literal">NULL</span>;</span><br><span class="line">Other* other01 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换失败</span></span><br><span class="line"><span class="comment">//Animal* animal02 = static_cast&lt;Animal*&gt;(other01);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、动态转换-dynamic-cast"><a href="#4、动态转换-dynamic-cast" class="headerlink" title="4、动态转换(dynamic_cast)"></a>4、动态转换(dynamic_cast)</h2><ul><li>dynamic_cast主要用于类层次间的上行转换和下行转换；</li><li>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；</li><li>在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowName</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;I am a dog!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是其他类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通类型转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 不支持基础数据类型</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//double a = dynamic_cast&lt;double&gt;(a);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承关系指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">Animal* animal01 = <span class="literal">NULL</span>;</span><br><span class="line">Dog* dog01 = <span class="keyword">new</span> Dog;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类指针转换成父类指针 可以</span></span><br><span class="line">Animal* animal02 = <span class="built_in">dynamic_cast</span>&lt;Animal*&gt;(dog01);</span><br><span class="line">animal02-&gt;<span class="built_in">ShowName</span>();</span><br><span class="line"><span class="comment">// 父类指针转换成子类指针 不可以</span></span><br><span class="line">Dog* dog02 = <span class="built_in">dynamic_cast</span>&lt;Dog*&gt;(animal01);</span><br><span class="line">    <span class="keyword">if</span> (dog02 != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">dog02-&gt;<span class="built_in">ShowName</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;nullptr...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承关系引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">Dog dog_ref;</span><br><span class="line">Dog&amp; dog01 = dog_ref;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类引用转换成父类引用 可以</span></span><br><span class="line">Animal&amp; animal02 = <span class="built_in">dynamic_cast</span>&lt;Animal&amp;&gt;(dog01);</span><br><span class="line">animal02.<span class="built_in">ShowName</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无继承关系指针转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">Animal* animal01 = <span class="literal">NULL</span>;</span><br><span class="line">Other* other = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可以</span></span><br><span class="line"><span class="comment">//Animal* animal02 = dynamic_cast&lt;Animal*&gt;(other);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、常量转换-const-cast"><a href="#5、常量转换-const-cast" class="headerlink" title="5、常量转换(const_cast)"></a>5、常量转换(const_cast)</h2><p>该运算符用来修改类型的const属性。  </p><ul><li>常量指针被转化成非常量指针，并且仍然指向原来的对象；</li><li>常量引用被转换成非常量引用，并且仍然指向原来的对象；</li></ul><p><strong>注意:不能直接对非指针和非引用的变量使用const_cast操作符去直接移除它的const。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量指针转换成非常量指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span>* np = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(p);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* pp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* npp = <span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>*&gt;(pp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能对非指针或非引用进行转换</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;  </span><br><span class="line"><span class="comment">//int b = const_cast&lt;int&gt;(a); </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常量引用转换成非常量引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp; refNum = num;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; refNum2 = <span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>&amp;&gt;(refNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、重新解释转换-reinterpret-cast"><a href="#6、重新解释转换-reinterpret-cast" class="headerlink" title="6、重新解释转换(reinterpret_cast)"></a>6、重新解释转换(reinterpret_cast)</h2><p>这是最不安全的一种转换机制，最有可能出问题。</p><p>主要用于将一种数据类型从一种类型转换为另一种类型。它可以将一个指针转换成一个整数，也可以将一个整数转换成一个指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>: <span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal *base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把base转换成其他非动物相关的 err</span></span><br><span class="line"><span class="comment">//Other *other= static_cast&lt;Other *&gt; (base);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reinterpret_cast //可以强制类型转换</span></span><br><span class="line">Other *other2= <span class="built_in">reinterpret_cast</span>&lt;Other *&gt; (base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h2><p><em><strong>结论1：程序员要清除的知道: 要转的变量，类型转换前是什么类型，类型转换后是什么类型。转换后有什么后果。</strong></em></p><p><em><strong>结论2：一般情况下，不建议进行类型转换；避免进行类型转换。</strong></em></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;C-类型转换&quot;&gt;&lt;a href=&quot;#C-类型转换&quot; class=&quot;headerlink&quot; title=&quot;C++类型转换&quot;&gt;&lt;/a&gt;C++类型转换&lt;/h1&gt;&lt;p&gt;类型转换(cast)是将一种数据类型转换成另一种数据类型。例如，如果将一个整型值赋给一个浮点类型的变量，编译器会暗地里将其转换成浮点类型。</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C++" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++模板</title>
    <link href="http://example.com/2022/09/01/C-%E6%A8%A1%E6%9D%BF/"/>
    <id>http://example.com/2022/09/01/C-%E6%A8%A1%E6%9D%BF/</id>
    <published>2022-09-01T01:47:28.000Z</published>
    <updated>2022-09-02T01:25:37.334Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-函数模板和类模板"><a href="#C-函数模板和类模板" class="headerlink" title="C++函数模板和类模板"></a>C++函数模板和类模板</h1><h2 id="1、模板概论"><a href="#1、模板概论" class="headerlink" title="1、模板概论"></a>1、模板概论</h2><p>C++提供了函数模板(function template)。<strong>所谓函数模板，实际上是建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表。这个通用函数就称为函数模板。</strong><span id="more"></span>凡是函数体相同的函数都可以用这个模板来代替，不必定义多个函数，只需在模板中定义一次即可。在调用函数时系统会根据实参的类型来取代模板中的虚拟类型，从而实现了不同函数的功能。</p><p><img src="https://pic.imgdb.cn/item/63105f7416f2c2beb145d439.jpg"></p><p>1）C++提供两种模板机制：函数模板、类模板；<br>2）类属 —— 类型参数化，又称参数模板，使得程序（算法）可以从逻辑功能上抽象，把被处理的对象（数据）类型作为参数传递。  </p><p>总结：</p><ul><li>模板把函数或类要处理的数据类型参数化，表现为参数的多态性，称为类属。</li><li>模板用于表达逻辑结构相同，但具体数据元素类型不同的数据对象的通用行为。</li></ul><h2 id="2、函数模板"><a href="#2、函数模板" class="headerlink" title="2、函数模板"></a>2、函数模板</h2><h3 id="2-1、什么是函数模板"><a href="#2-1、什么是函数模板" class="headerlink" title="2.1、什么是函数模板"></a>2.1、什么是函数模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求：写n个函数，交换char类型、int类型、double类型变量的值。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void myswap(int &amp;a, int &amp;b)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">int t = a;</span></span><br><span class="line"><span class="comment">a = b;</span></span><br><span class="line"><span class="comment">b = t;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void myswap(char &amp;a, char &amp;b)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">char t = a;</span></span><br><span class="line"><span class="comment">a = b;</span></span><br><span class="line"><span class="comment">b = t;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//template 关键字告诉C++编译器 我要开始泛型了.你不要随便报错  </span></span><br><span class="line"><span class="comment">//数据类型T 参数化数据类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myswap</span><span class="params">(T &amp;a, T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T t;</span><br><span class="line">t = a;</span><br><span class="line">a = b;</span><br><span class="line">b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//char a = &#x27;c&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  x = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">myswap</span>(x, y);        <span class="comment">//自动数据类型 推导的方式 </span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> a = <span class="number">2.0</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="number">3.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">myswap</span>(a, b);        <span class="comment">//自动数据类型 推导的方式 </span></span><br><span class="line"><span class="built_in">myswap</span>&lt;<span class="type">float</span>&gt;(a, b); <span class="comment">//显示类型调用 </span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;hello...&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用模板是为了实现泛型，可以减轻编程的工作量，增强函数的重用性。</p><h3 id="2-2、函数模板语法"><a href="#2-2、函数模板语法" class="headerlink" title="2.2、函数模板语法"></a>2.2、函数模板语法</h3><p>函数模板定义形式：<br><strong>template &lt; 类型形式参数表 &gt;</strong>  </p><p>类型形式参数的形式为：<br><strong>typename T1 ,  typename T2 , …… , typename Tn  或  class T1 ,  class T2 , …… , class Tn</strong></p><p><img src="https://pic.imgdb.cn/item/6310615a16f2c2beb1476617.jpg"></p><p>函数模板调用： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">myswap</span>&lt;<span class="type">float</span>&gt;(a, b);<span class="comment">//显示类型调用</span></span><br><span class="line"><span class="built_in">myswap</span>(a, b);     <span class="comment">//自动数据类型推导 </span></span><br></pre></td></tr></table></figure><p>例如：使用函数模板实现对char和int类型数组进行排序？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortArray</span><span class="params">(T *a, T2 num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T tmp ;</span><br><span class="line"><span class="type">int</span> i, j ;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;num; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j=i+<span class="number">1</span>; j&lt;num; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt; a[j])</span><br><span class="line">&#123;</span><br><span class="line">tmp = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pirntArray</span><span class="params">(T *a, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;num; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> a[] = <span class="string">&quot;ddadeeettttt&quot;</span>;</span><br><span class="line">num = <span class="built_in">strlen</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;排序之前\n&quot;</span>);</span><br><span class="line"><span class="built_in">pirntArray</span>&lt;<span class="type">char</span>&gt;(a, num);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sortArray</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(a, num); <span class="comment">//显示类型调用 模板函数 &lt;&gt;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;排序之后\n&quot;</span>);</span><br><span class="line"><span class="built_in">pirntArray</span>&lt;<span class="type">char</span>&gt;(a, num);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;hello...&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3、函数模板和模板函数"><a href="#2-3、函数模板和模板函数" class="headerlink" title="2.3、函数模板和模板函数"></a>2.3、函数模板和模板函数</h3><p><img src="https://pic.imgdb.cn/item/631061c216f2c2beb147bfbb.jpg"></p><h3 id="2-4、函数模板和普通函数区别"><a href="#2-4、函数模板和普通函数区别" class="headerlink" title="2.4、函数模板和普通函数区别"></a>2.4、函数模板和普通函数区别</h3><ul><li>函数模板不允许自动类型转化</li><li>普通函数能够进行自动类型转换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">MyPlus</span><span class="params">(T a, T b)</span></span>&#123;</span><br><span class="line">T ret = a + b;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyPlus</span><span class="params">(<span class="type">int</span> a,<span class="type">char</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ret = a + b;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> b = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数模板，严格匹配类型</span></span><br><span class="line"><span class="built_in">MyPlus</span>(a, a);</span><br><span class="line"><span class="built_in">MyPlus</span>(b, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用普通函数</span></span><br><span class="line"><span class="built_in">MyPlus</span>(a, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用普通函数  普通函数可以隐式类型转换</span></span><br><span class="line"><span class="built_in">MyPlus</span>(b, a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//结论：</span></span><br><span class="line"><span class="comment">//函数模板不允许自动类型转换，必须严格匹配类型</span></span><br><span class="line"><span class="comment">//普通函数可以进行自动类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5、函数模板和普通函数在一起调用规则"><a href="#2-5、函数模板和普通函数在一起调用规则" class="headerlink" title="2.5、函数模板和普通函数在一起调用规则"></a>2.5、函数模板和普通函数在一起调用规则</h3><ul><li>函数模板可以像普通函数一样被重载</li><li>C++编译器优先考虑普通函数</li><li>如果函数模板可以产生一个更好的匹配，那么选择模板</li><li>可以通过空模板实参列表的语法限定编译器只通过模板匹配</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;int Max(int a, int b)&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Max</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;T Max(T a, T b)&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Max</span><span class="params">(T a, T b, T c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;T Max(T a, T b, T c)&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Max</span>(<span class="built_in">Max</span>(a, b), c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">Max</span>(a, b)&lt;&lt;endl;      <span class="comment">//当函数模板和普通函数都符合调用时,优先选择普通函数</span></span><br><span class="line">cout&lt;&lt;Max&lt;&gt;(a, b)&lt;&lt;endl;    <span class="comment">//若显示使用函数模板,则使用&lt;&gt; 类型列表</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">Max</span>(<span class="number">3.0</span>, <span class="number">4.0</span>)&lt;&lt;endl;  <span class="comment">//如果 函数模板产生更好的匹配 使用函数模板</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">Max</span>(<span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>)&lt;&lt;endl; <span class="comment">//重载</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">Max</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">100</span>)&lt;&lt;endl;  <span class="comment">//调用普通函数 可以隐式类型转换 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6、函数模板的局限性"><a href="#2-6、函数模板的局限性" class="headerlink" title="2.6、函数模板的局限性"></a>2.6、函数模板的局限性</h3><p>假设有如下模板函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; … &#125;</span><br></pre></td></tr></table></figure><p>如果代码实现时定义了赋值操作 a &#x3D; b，但是T为数组，这种假设就不成立了。同样，如果里面的语句为判断语句 if(a&gt;b),但T如果是结构体，该假设也不成立，另外如果是传入的数组，数组名为地址，因此它比较的是地址，而这也不是我们所希望的操作。</p><p>总之，编写的模板函数很可能无法处理某些类型，另一方面，有时候通用化是有意义的，但C++语法不允许这样做。<strong>为了解决这种问题，可以提供模板的重载，为这些特定的类型提供具体化的模板。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line">string mName;</span><br><span class="line"><span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通交换函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a,T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b; </span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三代具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">// 具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="type">void</span>  <span class="built_in">mySwap</span>&lt;Person&gt;(Person &amp;p1, Person &amp;p2)</span><br><span class="line">&#123;</span><br><span class="line">string nameTemp;</span><br><span class="line"><span class="type">int</span> ageTemp;</span><br><span class="line"></span><br><span class="line">nameTemp = p1.mName;</span><br><span class="line">p1.mName = p2.mName;</span><br><span class="line">p2.mName = nameTemp;</span><br><span class="line"></span><br><span class="line">ageTemp = p1.mAge;</span><br><span class="line">p1.mAge = p2.mAge;</span><br><span class="line">p2.mAge = ageTemp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">P1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">P2</span><span class="params">(<span class="string">&quot;Jerry&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;P1 Name = &quot;</span> &lt;&lt; P1.mName &lt;&lt; <span class="string">&quot; P1 Age = &quot;</span> &lt;&lt; P1.mAge &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;P2 Name = &quot;</span> &lt;&lt; P2.mName &lt;&lt; <span class="string">&quot; P2 Age = &quot;</span> &lt;&lt; P2.mAge &lt;&lt; endl;</span><br><span class="line"><span class="built_in">mySwap</span>(P1, P2);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;P1 Name = &quot;</span> &lt;&lt; P1.mName &lt;&lt; <span class="string">&quot; P1 Age = &quot;</span> &lt;&lt; P1.mAge &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;P2 Name = &quot;</span> &lt;&lt; P2.mName &lt;&lt; <span class="string">&quot; P2 Age = &quot;</span> &lt;&lt; P2.mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、类模板"><a href="#3、类模板" class="headerlink" title="3、类模板"></a>3、类模板</h2><h3 id="3-1、类模板基本概念"><a href="#3-1、类模板基本概念" class="headerlink" title="3.1、类模板基本概念"></a>3.1、类模板基本概念</h3><p>类模板与函数模板的定义和使用类似，我们已经进行了介绍。 有时，有两个或多个类，其功能是相同的，仅仅是数据类型不同，如下面语句声明了一个类：</p><p><img src="https://pic.imgdb.cn/item/6310786816f2c2beb159130c.jpg"></p><ul><li>类模板用于实现类所需数据的类型参数化 </li><li>类模板在表示如数组、表、图等数据结构显得特别重要，这些数据结构的表示和算法不受所包含的元素类型的影响</li></ul><h3 id="3-2、单个类模板语法"><a href="#3-2、单个类模板语法" class="headerlink" title="3.2、单个类模板语法"></a>3.2、单个类模板语法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的类型参数化 抽象的类</span></span><br><span class="line"><span class="comment">//单个类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(T t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;t = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T &amp;<span class="title">getT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T t;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//模板了中如果使用了构造函数,则遵守以前的类的构造函数的调用规则</span></span><br><span class="line"><span class="function">A&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>; </span><br><span class="line">a.<span class="built_in">getT</span>();</span><br><span class="line"><span class="built_in">printAA</span>(a);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3、继承中的类模板语法"><a href="#3-3、继承中的类模板语法" class="headerlink" title="3.3、继承中的类模板语法"></a>3.3、继承中的类模板语法</h3><p><img src="https://pic.imgdb.cn/item/631079c216f2c2beb15a0ded.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结论: 子类从模板类继承的时候,需要让编译器知道 父类的数据类型具体是什么(数据类型的本质:固定大小内存块的别名)A&lt;int&gt; </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&lt;<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">B</span>(<span class="type">int</span> i) : <span class="built_in">A</span>&lt;<span class="type">int</span>&gt;(i)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;A:&quot;</span>&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板与上继承</span></span><br><span class="line"><span class="comment">// 怎么样从基类继承  </span></span><br><span class="line"><span class="comment">// 若基类只有一个带参数的构造函数,子类是如何启动父类的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pintBB</span><span class="params">(B &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b.<span class="built_in">printB</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printAA</span><span class="params">(A&lt;<span class="type">int</span>&gt; &amp;a)</span>  <span class="comment">// 类模板做函数参数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//</span></span><br><span class="line">a.<span class="built_in">getT</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">A&lt;<span class="type">int</span>&gt;  <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">// 模板了中如果使用了构造函数,则遵守以前的类的构造函数的调用规则 </span></span><br><span class="line">a.<span class="built_in">getT</span>();</span><br><span class="line"><span class="built_in">printAA</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">b.<span class="built_in">printB</span>();</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;hello...&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4、类模板语法知识体系梳理"><a href="#3-4、类模板语法知识体系梳理" class="headerlink" title="3.4、类模板语法知识体系梳理"></a>3.4、类模板语法知识体系梳理</h3><h4 id="3-4-1、总结"><a href="#3-4-1、总结" class="headerlink" title="3.4.1、总结"></a>3.4.1、总结</h4><p>归纳后，可以这样声明和使用类模板：</p><ol><li>先写出一个实际的类。由于其语义明确，含义清楚，一般不会出错。</li><li>将此类中准备改变的类型名(如int要改变为float或char)改用一个自己指定的虚拟类型名(如上例中的numtype)。</li><li>在类声明前面加入一行，格式为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> 虚拟类型参数&gt;</span><br></pre></td></tr></table></figure>如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">numtype</span>&gt; <span class="comment">//注意本行末尾无分号</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Compare</span></span><br><span class="line">&#123;…&#125;; <span class="comment">// 类体</span></span><br></pre></td></tr></table></figure></li><li>用类模板定义对象时用以下形式：<br> <strong>类模板名&lt;实际类型名&gt; 对象名;</strong><br> <strong>类模板名&lt;实际类型名&gt; 对象名(实参表列);</strong><br>如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Compare&lt;<span class="type">int</span>&gt; cmp;  </span><br><span class="line"><span class="function">Compare&lt;<span class="type">int</span>&gt; <span class="title">cmp</span><span class="params">(<span class="number">3</span>,<span class="number">7</span>)</span></span>;</span><br></pre></td></tr></table></figure></li><li>如果在类模板外定义成员函数，应写成类模板形式：<br><strong>template &lt;class 虚拟类型参数&gt;</strong><br><strong>函数类型 类模板名&lt;虚拟类型参数&gt;::成员函数名(函数形参表列) {…}</strong></li></ol><p>关于类模板的几点说明：</p><ol><li>类模板的类型参数可以有一个或多个，每个类型前面都必须加class，如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">someclass</span>  </span><br><span class="line">&#123;…&#125;;  </span><br></pre></td></tr></table></figure>在定义对象时分别代入实际的类型名，如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someclass&lt;<span class="type">int</span>,<span class="type">double</span>&gt; obj;</span><br></pre></td></tr></table></figure></li><li>和使用类一样，使用类模板时要注意其作用域，只能在其有效作用域内用它定义对象。</li><li>模板可以有层次，一个类模板可以作为基类，派生出派生模板类。</li></ol><h3 id="3-5、类模板中的static关键字"><a href="#3-5、类模板中的static关键字" class="headerlink" title="3.5、类模板中的static关键字"></a>3.5、类模板中的static关键字</h3><ul><li>从类模板实例化的每个模板类有自己的类模板数据成员，该模板类的所有对象共享一个static数据成员</li><li>和非模板类的static数据成员一样，模板类的static数据成员也应该在文件范围定义和初始化</li><li>每个模板类有自己的类模板的static数据成员副本</li></ul><h2 id="4、小结"><a href="#4、小结" class="headerlink" title="4、小结"></a>4、小结</h2><ul><li>模板是C++类型参数化的多态工具。C++提供函数模板和类模板。</li><li>模板定义以模板说明开始。类属参数必须在模板定义中至少出现一次。</li><li>同一个类属参数可以用于多个模板。</li><li>类属参数可用于函数的参数类型、返回类型和声明函数中的变量。</li><li>模板由编译器根据实际数据类型实例化，生成可执行代码。实例化的函数。模板称为模板函数；实例化的类模板称为模板类。</li><li>函数模板可以用多种方式重载。</li><li>类模板可以在类层次中使用。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;C-函数模板和类模板&quot;&gt;&lt;a href=&quot;#C-函数模板和类模板&quot; class=&quot;headerlink&quot; title=&quot;C++函数模板和类模板&quot;&gt;&lt;/a&gt;C++函数模板和类模板&lt;/h1&gt;&lt;h2 id=&quot;1、模板概论&quot;&gt;&lt;a href=&quot;#1、模板概论&quot; class=&quot;headerlink&quot; title=&quot;1、模板概论&quot;&gt;&lt;/a&gt;1、模板概论&lt;/h2&gt;&lt;p&gt;C++提供了函数模板(function template)。&lt;strong&gt;所谓函数模板，实际上是建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表。这个通用函数就称为函数模板。&lt;/strong&gt;</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C++" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++输入输出-文件IO</title>
    <link href="http://example.com/2022/08/31/C-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-%E6%96%87%E4%BB%B6IO/"/>
    <id>http://example.com/2022/08/31/C-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-%E6%96%87%E4%BB%B6IO/</id>
    <published>2022-08-31T08:04:59.000Z</published>
    <updated>2022-08-31T09:24:11.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-输入输出–文件IO"><a href="#C-输入输出–文件IO" class="headerlink" title="C++输入输出–文件IO"></a>C++输入输出–文件IO</h1><h2 id="1、文件流类和文件流对象"><a href="#1、文件流类和文件流对象" class="headerlink" title="1、文件流类和文件流对象"></a>1、文件流类和文件流对象</h2><p>输入输出是以系统指定的标准设备（输入设备为键盘，输出设备为显示器）为对象的。在实际应用中，常以磁盘文件作为对象。即从磁盘文件读取数据，将数据输出到磁盘文件。<span id="more"></span></p><p>和文件有关系的输入输出类主要在fstream.h这个头文件中被定义，在这个头文件中主要被定义了三个类，由这三个类控制对文件的各种输入输出操 作，他们分别是ifstream、ofstream、fstream，其中fstream类是由iostream类派生而来，他们之间的继承关系见下图所示：</p><p><img src="https://pic.imgdb.cn/item/630f16a616f2c2beb1a3d351.jpg"></p><p>由于文件设备并不像显示器屏幕与键盘那样是标准默认设备，所以它在fstream.h头文件中是没有像cout那样预先定义的全局对象，所以我们必须自己定义一个该类的对象。</p><ul><li><p>ifstream类，它是从istream类派生的，用来支持从磁盘文件的输入。</p></li><li><p>ofstream类，它是从ostream类派生的，用来支持向磁盘文件的输出。</p></li><li><p>fstream类，它是从iostream类派生的，用来支持对磁盘文件的输入输出。</p></li></ul><h2 id="2、文件打开和关闭"><a href="#2、文件打开和关闭" class="headerlink" title="2、文件打开和关闭"></a>2、文件打开和关闭</h2><p>C++根据文件（file）内容的数据格式，可分为两类：</p><ul><li><p>文本文件：由字符序列组成，在文本文件中存取的最小信息单位为字符（character），也称ASCII码文件。</p></li><li><p>二进制文件：存取的最小信息单位为字节（Byte）。</p></li></ul><p>C++把每个文件都看成一个有序的字节流，每一个文件或者以文件结束符（end of file marker）结束，或者在特定的字节号处结束，如下图所示。</p><p><img src="https://pic.imgdb.cn/item/630f16c216f2c2beb1a3e3ba.jpg"></p><p>当打开一个文件时，该文件就和某个流关联起来了。对文件进行读写实际上受到一个文件定位指针（file position pointer）的控制。输入流的指针也称为读指针，每一次提取操作将从读指针当前所指位置开始，每次提取操作自动将读指针向文件尾移动。输出流指针也称写指针，每一次插入操作将从写指针当前位置开始，每次插入操作自动将写指针向文件尾移动。 </p><h3 id="2-1、文件打开"><a href="#2-1、文件打开" class="headerlink" title="2.1、文件打开"></a>2.1、文件打开</h3><p>打开文件是指在文件读写之前做必要的准备工作，包括：</p><ul><li><p>为文件流对象和指定的磁盘文件建立关联，以便使文件流流向指定的磁盘文件。</p></li><li><p>指定文件的工作方式，如，该文件是作为输入文件还是输出文件，是ASCII文件还是二进制文件等。</p></li></ul><p>以上工作可以通过两种不同的方法实现。</p><ol><li>调用文件流的成员函数open。如</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ofstream outfile;  <span class="comment">//定义ofstream类(输出文件流类)对象outfile</span></span><br><span class="line"></span><br><span class="line">outfile.<span class="built_in">open</span>(<span class="string">&quot;f1.dat&quot;</span>,ios::out);  <span class="comment">//使文件流与f1.dat文件建立关联</span></span><br></pre></td></tr></table></figure><p>第2行是调用输出文件流的成员函数open打开磁盘文件f1.dat，并指定它为输出文件， 文件流对象outfile将向磁盘文件f1.dat输出数据。ios::out是I&#x2F;O模式的一种，表示以输出方式打开一个文件。或者简单地说，此时f1.dat是一个输出文件，接收从内存输出的数据。</p><p>调用成员函数open的一般形式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件流对象.<span class="built_in">open</span>(磁盘文件名, 输入输出方式);</span><br></pre></td></tr></table></figure><p>磁盘文件名可以包括路径，如”c:\new\f1.dat”，如缺省路径，则默认为当前目录下的文件。</p><ol start="2"><li>在定义文件流对象时指定参数</li></ol><p>在声明文件流类时定义了带参数的构造函数，其中包含了打开磁盘文件的功能。因此，可以在定义文件流对象时指定参数，调用文件流类的构造函数来实现打开文件的功能。如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream <span class="title">outfile</span><span class="params">(<span class="string">&quot;f1.dat&quot;</span>,ios::out)</span></span>; 一般多用此形式，比较方便。作用与open函数相同。</span><br></pre></td></tr></table></figure><p>输入输出方式是在ios类中定义的，它们是枚举常量，有多种选择。</p><p>需要注意的是：</p><ol><li><p>每一个打开的文件都有一个文件指针，该指针的初始位置由I&#x2F;O方式指定，每次读写都从文件指针的当前位置开始。每读入一个字节，指针就后移一个字节。当文 件指针移到最后，就会遇到文件结束EOF（文件结束符也占一个字节，其值为-1)，此时流对象的成员函数eof的值为非0值(一般设为1)，表示文件结束 了。</p></li><li><p>可以用“位或”运算符“|”对输入输出方式进行组合，如表13.6中最后3行所示那样。还可以举出下面一些例子：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ios::in | ios:: noreplace  <span class="comment">//打开一个输入文件，若文件不存在则返回打开失败的信息</span></span><br><span class="line">ios::app | ios::nocreate  <span class="comment">//打开一个输出文件，在文件尾接着写数据，若文件不存在，则返回打开失败的信息</span></span><br><span class="line">ios::out l ios::noreplace  <span class="comment">//打开一个新文件作为输出文件，如果文件已存在则返回打开失败的信息</span></span><br><span class="line">ios::in l ios::out I ios::binary  <span class="comment">//打开一个二进制文件，可读可写</span></span><br></pre></td></tr></table></figure><p>但不能组合互相排斥的方式，如 ios::nocreate l ios::noreplace。</p><ol start="3"><li>如果打开操作失败，open函数的返回值为0(假)，如果是用调用构造函数的方式打开文件的，则流对象的值为0。可以据此测试打开是否成功。如</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span>(outfile.<span class="built_in">open</span>(<span class="string">&quot;f1.bat&quot;</span>, ios::app) ==<span class="number">0</span>)</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;open error&quot;</span>;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">  <span class="keyword">if</span>( !outfile.<span class="built_in">open</span>(<span class="string">&quot;f1.bat&quot;</span>, ios::app) )</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;open error&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="2-2、文件关闭"><a href="#2-2、文件关闭" class="headerlink" title="2.2、文件关闭"></a>2.2、文件关闭</h3><p>在对已打开的磁盘文件的读写操作完成后，应关闭该文件。关闭文件用成员函数close。如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outfile.<span class="built_in">close</span>( );  <span class="comment">//将输出文件流所关联的磁盘文件关闭</span></span><br></pre></td></tr></table></figure><p>关闭文件，实际上是解除该磁盘文件与文件流的关联，原来设置的工作方式也失效，这样，就不能再通过文件流对该文件进行输入或输出。此时可以将文件流与其他磁盘文件建立关联，通过文件流对新的文件进行输入或输出。如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outfile.<span class="built_in">open</span>(<span class="string">&quot;f2.dat&quot;</span>,ios::app|ios::nocreate);</span><br></pre></td></tr></table></figure><p>此时文件流outfile与f2.dat建立关联，并指定了f2.dat的工作方式。</p><p>关闭文件并没有取消文件流对象，该文件流对象又可与其他磁盘文件建立联系。文件流对象在程序结束时，或它的生命期结束时，由析构函数撤消。它同时释放内部分配的预留缓冲区。 </p><h3 id="2-3、文件操作的5个步骤"><a href="#2-3、文件操作的5个步骤" class="headerlink" title="2.3、文件操作的5个步骤"></a>2.3、文件操作的5个步骤</h3><p>可以总结出文件使用的5步骤：</p><p>①说明一个文件流对象，这又被称为内部文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifstream ifile；<span class="comment">//只输入用</span></span><br><span class="line">ofstream ofile；<span class="comment">//只输出用</span></span><br><span class="line">fstream iofile；<span class="comment">//既输入又输出用</span></span><br></pre></td></tr></table></figure><p>②使用文件流对象的成员函数打开一个磁盘文件。这样在文件流对象和磁盘文件名之间建立联系。文件流中说明了三个打开文件的成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ifstream::open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*,<span class="type">int</span>=ios::in,<span class="type">int</span>=filebuf::openprot)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ofstream::open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*,<span class="type">int</span>=ios::out,<span class="type">int</span>=filebuf::openprot)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fstream::open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*,<span class="type">int</span>,<span class="type">int</span>=filebuf::openprot)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数为要打开的磁盘文件名。第二个参数为打开方式，有输入（in），输出（out）等，打开方式在ios基类中定义为枚举类型。第三个参数为指定打开文件的保护方式，一般取默认。所以第二步可如下进行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iofile.<span class="built_in">open</span>(“myfile.txt”,ios::in|ios::out);</span><br></pre></td></tr></table></figure><p>上面三个文件流类都重载了一个带默认参数的构造函数，功能与open函数一样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifstream::ifstream(<span class="type">const</span> <span class="type">char</span>*,<span class="type">int</span>=ios::in,<span class="type">int</span>=filebuf::openprot);</span><br><span class="line">ofstream::<span class="built_in">ofstream</span>(<span class="type">const</span> <span class="type">char</span>*,<span class="type">int</span>=ios::out,<span class="type">int</span>=filebuf::openprot);</span><br><span class="line">fstream::<span class="built_in">fstream</span>(<span class="type">const</span> <span class="type">char</span>*,<span class="type">int</span>,<span class="type">int</span>=filebuf::operprot);</span><br></pre></td></tr></table></figure><p>所以①和②两步可合成： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">iofile</span><span class="params">(”myfile.txt”,ios::in|ios::out)</span></span>;</span><br></pre></td></tr></table></figure><p>③打开文件也应该判断是否成功，若成功，文件流对象值为非零值，不成功为0（NULL），文件流对象值物理上就是指它的地址。因此打开一个文件完整的程序为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fstream iofile（”myfile.txt”,ios::in|ios::out）;</span><br><span class="line"><span class="keyword">if</span>(!iofile)</span><br><span class="line">&#123; <span class="comment">//“！”为重载的运算符</span></span><br><span class="line">    cout&lt;&lt;”不能打开文件:”&lt;&lt;”myfile,txt”&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; <span class="comment">//失败退回操作系统</span></span><br></pre></td></tr></table></figure><p>④使用提取和插入运算符对文件进行读写操作，或使用成员函数进行读写</p><p>⑤关闭文件。三个文件流类各有一个关闭文件的成员函数 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ifstream::close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ofstream::close</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fstream::close</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>使用很方便，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iofile.<span class="built_in">close</span>(); </span><br></pre></td></tr></table></figure><h2 id="3、C-对ASCII文件的读写操作"><a href="#3、C-对ASCII文件的读写操作" class="headerlink" title="3、C++对ASCII文件的读写操作"></a>3、C++对ASCII文件的读写操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fstream&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> fileName[<span class="number">80</span>];</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">255</span>];</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入一个文件名: &quot;</span>;</span><br><span class="line">cin &gt;&gt; fileName;</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(fileName, ios::app)</span></span>;</span><br><span class="line">fout &lt;&lt; <span class="string">&quot;1111111111111111111\n&quot;</span>;</span><br><span class="line">fout &lt;&lt; <span class="string">&quot;22222222222222222\n&quot;</span>;</span><br><span class="line"><span class="comment">//cin.ignore(1,&#x27;\n&#x27;);</span></span><br><span class="line">cin.<span class="built_in">getline</span>(buffer,<span class="number">255</span>); <span class="comment">//从键盘输入</span></span><br><span class="line">fout &lt;&lt; buffer &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">fout.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(fileName)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here&#x27;s the the content of the file: \n&quot;</span>;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>(fin.<span class="built_in">get</span>(ch))</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n***End of file contents.***\n&quot;</span>;</span><br><span class="line">fin.<span class="built_in">close</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line">usingnamespace std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        ifstream myfile; </span><br><span class="line">        myfile.<span class="built_in">open</span>(<span class="string">&quot;c:\\test.txt&quot;</span>,ios::in,<span class="number">0</span>); </span><br><span class="line">        <span class="keyword">if</span>(!myfile) </span><br><span class="line">        &#123; </span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;文件读错误&quot;</span>; </span><br><span class="line">                <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); </span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">char</span> ch; </span><br><span class="line">        string content; </span><br><span class="line">        <span class="keyword">while</span>(myfile.<span class="built_in">get</span>(ch)) </span><br><span class="line">        &#123; </span><br><span class="line">                content+=ch; </span><br><span class="line">                cout.<span class="built_in">put</span>(ch);<span class="comment">//cout&lt;&lt;ch;这么写也是可以的 </span></span><br><span class="line">        &#125; </span><br><span class="line">        myfile.<span class="built_in">close</span>(); </span><br><span class="line">        cout&lt;&lt;content; </span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、C-对二进制文件的读写操作"><a href="#4、C-对二进制文件的读写操作" class="headerlink" title="4、C++对二进制文件的读写操作"></a>4、C++对二进制文件的读写操作</h2><p>用成员函数read和write读写二进制文件，对二进制文件的读写主要用istream类的成员函数read和write来实现。这两个成员函数的原型为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">(<span class="type">char</span> *buffer,<span class="type">int</span> len)</span></span>;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * buffer,<span class="type">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>字符指针buffer指向内存中一段存储空间。len是读写的字节数。调用的方式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a. <span class="built_in">write</span>(p1,<span class="number">50</span>);</span><br><span class="line">b. <span class="built_in">read</span>(p2,<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>上面第一行中的a是输出文件流对象，write函数将字符指针p1所给出的地址开始的50个字节的内容不加转换地写到磁盘文件中。在第二行中，b是输入文 件流对象，read 函数从b所关联的磁盘文件中，读入30个字节(或遇EOF结束），存放在字符指针p2所指的一段空间内。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建二进制数据文件，以及数据文件的读取。这两项操作设计为成员函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">inventory</span>&#123;</span><br><span class="line">string Description;</span><br><span class="line">string No;</span><br><span class="line"><span class="type">int</span> Quantity;</span><br><span class="line"><span class="type">double</span> Cost;</span><br><span class="line"><span class="type">double</span> Retail;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">inventory</span>(string=<span class="string">&quot;#&quot;</span>,string=<span class="string">&quot;0&quot;</span>,<span class="type">int</span> =<span class="number">0</span>,<span class="type">double</span> =<span class="number">0</span>,<span class="type">double</span> =<span class="number">0</span>);</span><br><span class="line"><span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream&amp;,inventory&amp;);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bdatatofile</span><span class="params">(ofstream&amp;dist)</span></span>;     <span class="comment">//文件流类作为形式参数必须是引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bdatafromfile</span><span class="params">(ifstream&amp;sour)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">inventory::<span class="built_in">inventory</span>(string des,string no,<span class="type">int</span> quan,<span class="type">double</span> cost,<span class="type">double</span> ret)&#123;</span><br><span class="line">Description=des;</span><br><span class="line">No=no;</span><br><span class="line">Quantity=quan;</span><br><span class="line">Cost=cost;</span><br><span class="line">Retail=ret;</span><br><span class="line">&#125;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream&amp;dist,inventory&amp;iv)&#123;</span><br><span class="line">dist&lt;&lt;left&lt;&lt;<span class="built_in">setw</span>(<span class="number">20</span>)&lt;&lt;iv.Description&lt;&lt;<span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;iv.No;</span><br><span class="line">dist&lt;&lt;right&lt;&lt;<span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;iv.Quantity&lt;&lt;<span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;iv.Cost&lt;&lt;<span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;iv.Retail&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inventory::Bdatatofile</span><span class="params">(ofstream&amp;dist)</span></span>&#123;</span><br><span class="line">dist.<span class="built_in">write</span>(Description.<span class="built_in">c_str</span>(),<span class="number">20</span>); <span class="comment">//由string类的c_str()函数转为char*</span></span><br><span class="line">dist.<span class="built_in">write</span>(No.<span class="built_in">c_str</span>(),<span class="number">10</span>);</span><br><span class="line">dist.<span class="built_in">write</span>((<span class="type">char</span>*)&amp;Quantity,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">dist.<span class="built_in">write</span>((<span class="type">char</span>*)&amp;Cost,<span class="built_in">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">dist.<span class="built_in">write</span>((<span class="type">char</span>*)&amp;Retail,<span class="built_in">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inventory::Bdatafromfile</span><span class="params">(ifstream&amp;sour)</span></span>&#123;</span><br><span class="line"><span class="type">char</span> k[<span class="number">20</span>];</span><br><span class="line">sour.<span class="built_in">read</span>(k,<span class="number">20</span>);</span><br><span class="line">Description=k;</span><br><span class="line">sour.<span class="built_in">read</span>(k,<span class="number">10</span>);</span><br><span class="line">No=k;</span><br><span class="line">sour.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;Quantity,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">sour.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;Cost,<span class="built_in">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">sour.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;Retail,<span class="built_in">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">&#125;<span class="comment">//由此可见读和写是完全对称的过程,次序决不能错</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">inventory <span class="title">car1</span><span class="params">(<span class="string">&quot;夏利2000&quot;</span>,<span class="string">&quot;805637928&quot;</span>,<span class="number">156</span>,<span class="number">80000</span>,<span class="number">105000</span>)</span>,car2</span>;</span><br><span class="line"><span class="function">inventory <span class="title">motor1</span><span class="params">(<span class="string">&quot;金城125&quot;</span>,<span class="string">&quot;93612575&quot;</span>,<span class="number">302</span>,<span class="number">10000</span>,<span class="number">13000</span>)</span>,motor2</span>;</span><br><span class="line"><span class="function">ofstream <span class="title">ddatafile</span><span class="params">(<span class="string">&quot;d:\\Ex9_10.data&quot;</span>,ios::out|ios::binary)</span></span>;</span><br><span class="line">car1.<span class="built_in">Bdatatofile</span>(ddatafile);</span><br><span class="line">motor1.<span class="built_in">Bdatatofile</span>(ddatafile);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;对象car1:&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;car1;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;对象motor1:&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;motor1;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;对象car2:&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;car2;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;对象motor2:&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;motor2;</span><br><span class="line">ddatafile.<span class="built_in">close</span>();</span><br><span class="line"><span class="function">ifstream <span class="title">sdatafile</span><span class="params">(<span class="string">&quot;d:\\Ex9_10.data&quot;</span>,ios::in|ios::binary)</span></span>;<span class="comment">//重新打开文件,从头读取数据</span></span><br><span class="line">car2.<span class="built_in">Bdatafromfile</span>(sdatafile);                         <span class="comment">//从文件读取数据拷贝到对象car2</span></span><br><span class="line"><span class="keyword">if</span>(sdatafile.<span class="built_in">eof</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;读文件成功&quot;</span>&lt;&lt;endl; </span><br><span class="line">cout&lt;&lt;<span class="string">&quot;对象car2:&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;car2;</span><br><span class="line">motor2.<span class="built_in">Bdatafromfile</span>(sdatafile);                 <span class="comment">//继续从文件读取数据拷贝到对象motor2</span></span><br><span class="line"><span class="keyword">if</span>(sdatafile.<span class="built_in">eof</span>()==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;读文件成功&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;对象motor2:&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;motor2;</span><br><span class="line">sdatafile.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 文件结束判断：读函数并不能知道文件是否结束，可用状态函数int ios::eof()来判断文件是否结束。必须指出系统是根据当前操作的实际情况设置状态位，如需根据状态位来判断下一步的操作，必须在一次操作后立即去调取状态位，以判断本次操作是否有效。 </p><p> 二进制文件优点：可以控制字节长度，读写数据时不会出现二义性，可靠性高。同时不知格式是无法读取的，保密性好。文件结束后，系统不会再读，但程序不会自动停下来，所以要判断文件中是否已没有数据。如写完数据后没有关闭文件，直接开始读，则必须把文件定位指针移到文件头。如关闭文件后重新打开，文件定位指针就在文件头。 </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;C-输入输出–文件IO&quot;&gt;&lt;a href=&quot;#C-输入输出–文件IO&quot; class=&quot;headerlink&quot; title=&quot;C++输入输出–文件IO&quot;&gt;&lt;/a&gt;C++输入输出–文件IO&lt;/h1&gt;&lt;h2 id=&quot;1、文件流类和文件流对象&quot;&gt;&lt;a href=&quot;#1、文件流类和文件流对象&quot; class=&quot;headerlink&quot; title=&quot;1、文件流类和文件流对象&quot;&gt;&lt;/a&gt;1、文件流类和文件流对象&lt;/h2&gt;&lt;p&gt;输入输出是以系统指定的标准设备（输入设备为键盘，输出设备为显示器）为对象的。在实际应用中，常以磁盘文件作为对象。即从磁盘文件读取数据，将数据输出到磁盘文件。</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C++" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++输入输出-标准IO流</title>
    <link href="http://example.com/2022/08/31/C-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-%E6%A0%87%E5%87%86IO%E6%B5%81/"/>
    <id>http://example.com/2022/08/31/C-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-%E6%A0%87%E5%87%86IO%E6%B5%81/</id>
    <published>2022-08-31T08:00:17.000Z</published>
    <updated>2022-08-31T09:24:09.185Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-输入输出–标准IO流"><a href="#C-输入输出–标准IO流" class="headerlink" title="C++输入输出–标准IO流"></a>C++输入输出–标准IO流</h1><h2 id="1、I-x2F-O流的概念和流类库的结构"><a href="#1、I-x2F-O流的概念和流类库的结构" class="headerlink" title="1、I&#x2F;O流的概念和流类库的结构"></a>1、I&#x2F;O流的概念和流类库的结构</h2><p>输入输出：程序的输入指的是从输入文件将数据传送给程序，程序的输出指的是从程序将数据传送给输出文件。<span id="more"></span></p><p>C++输入输出包含以下三个方面的内容：</p><ul><li><p>对系统指定的标准设备的输入和输出。即从键盘输入数据，输出到显示器屏幕。这种输入输出称为标准的输入输出，简称标准I&#x2F;O。</p></li><li><p>以外存磁盘文件为对象进行输入和输出，即从磁盘文件输入数据，数据输出到磁盘文件。以外存文件为对象的输入输出称为文件的输入输出，简称文件I&#x2F;O。</p></li><li><p>对内存中指定的空间进行输入和输出。通常指定一个字符数组作为存储空间(实际上可以利用该空间存储任何信息)。这种输入和输出称为字符串输入输出，简称串I&#x2F;O。</p></li></ul><p>C++的I&#x2F;O对C的发展–类型安全和可扩展性</p><ul><li><p>在C语言中，用printf和scanf进行输入输出，往往不能保证所输入输出的数据是可靠的安全的。在C++的输入输出中，编译系统对数据类型进行严格的检查，凡是类型不正确的数据都不可能通过编译。因此C++的I&#x2F;O操作是类型安全(type safe)的。C++的I&#x2F;O操作是可扩展的，不仅可以用来输入输出标准类型的数据，也可以用于用户自定义类型的数据。</p></li><li><p>C++通过I&#x2F;O类库来实现丰富的I&#x2F;O功能。这样使C++的输人输出明显地优于C 语言中的printf和scanf，但是也为之付出了代价，C++的I&#x2F;O系统变得比较复杂，要掌握许多细节。</p></li><li><p>C++编译系统提供了用于输入输出的iostream类库。iostream这个单词是由3个部 分组成的，即i-o-stream，意为输入输出流。在iostream类库中包含许多用于输入输出的 类。</p></li></ul><p><img src="https://pic.imgdb.cn/item/630f157b16f2c2beb1a30c98.jpg"></p><h3 id="1-1、I-x2F-O-库文件"><a href="#1-1、I-x2F-O-库文件" class="headerlink" title="1.1、I&#x2F;O 库文件"></a>1.1、I&#x2F;O 库文件</h3><p>ios是抽象基类，由它派生出istream类和ostream类，两个类名中第1个字母i和o分别代表输入(input)和输出(output)。 istream类支持输入操作，ostream类支持输出操作， iostream类支持输入输出操作。iostream类是从istream类和ostream类通过多重继承而派生的类。其继承层次见上图表示。</p><p>C++对文件的输入输出需要用ifstrcam和ofstream类，两个类名中第1个字母i和o分别代表输入和输出，第2个字母f代表文件 (file)。ifstream支持对文件的输入操作， ofstream支持对文件的输出操作。类ifstream继承了类istream，类ofstream继承了类ostream，类fstream继承了 类iostream。</p><p>下列的头文件在 C++ 编程中很重要。</p><table><thead><tr><th align="left">头文件</th><th align="left">函数和描述</th></tr></thead><tbody><tr><td align="left"><iostream></td><td align="left">该文件定义了 <strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td></tr><tr><td align="left"><iomanip></td><td align="left">该文件通过所谓的参数化的流操纵器（比如 <strong>setw</strong> 和 <strong>setprecision</strong>），来声明对执行标准化 I&#x2F;O 有用的服务。</td></tr><tr><td align="left"><fstream></td><td align="left">该文件为用户控制的文件处理声明服务。</td></tr></tbody></table><p><img src="https://pic.imgdb.cn/item/630f15a116f2c2beb1a32617.jpg"></p><p>在iostream头文件中重载运算符</p><p>“&lt;&lt;”和“&gt;&gt;”本来在C++中是被定义为左位移运算符和右位移运算符的，由于在iostream头文件中对它们进行了重载， 使它们能用作标准类型数据的输入和输出运算符。所以，在用它们的程序中必须用#include命令把iostream包含到程序中。</p><p>  #include <iostream></p><ol><li><blockquote><blockquote><p>a 表示将数据放入a对象中。</p></blockquote></blockquote></li><li><p>&lt;&lt;a 表示将a对象中存储的数据拿出。</p></li></ol><h2 id="2、标准I-x2F-O流"><a href="#2、标准I-x2F-O流" class="headerlink" title="2、标准I&#x2F;O流"></a>2、标准I&#x2F;O流</h2><p>标准I&#x2F;O对象：cin，cout，cerr，clog</p><ul><li><p>cout流对象</p><p>cont是console output的缩写，意为在控制台（终端显示器）的输出。强调几点。</p><ol><li>cout不是C++预定义的关键字，它是ostream流类的对象，在iostream中定义。 顾名思义，流是流动的数据，cout流是流向显示器的数据。cout流中的数据是用流插入运算符“&lt;&lt;”顺序加入的。如果有<br>  cout&lt;&lt;”I “&lt;&lt;”study C++ “&lt;&lt;”very hard. &lt;&lt; “wang bao ming “;</li></ol><p>按顺序将字符串”I “, “study C++ “, “very hard.”插人到cout流中，cout就将它们送到显示器，在显示器上输出字符串”I study C++ very hard.”。cout流是容纳数据的载体，它并不是一个运算符。人们关心的是cout流中的内容，也就是向显示器输出什么。<br>2)用“ccmt&lt;&lt;”输出基本类型的数据时，可以不必考虑数据是什么类型，系统会判断数据的类型，并根据其类型选择调用与之匹配的运算符重 载函数。这个过程都是自动的，用户不必干预。如果在C语言中用prinf函数输出不同类型的数据，必须分别指定相应的输出格式符，十分麻烦，而且容易出 错。C++的I&#x2F;O机制对用户来说，显然是方便而安全的。</p><ol start="3"><li>cout流在内存中对应开辟了一个缓冲区，用来存放流中的数据，当向cout流插 人一个endl时，不论缓冲区是否已满，都立即输出流中所有数据，然后插入一个换行符， 并刷新流（清空缓冲区）。注意如果插人一个换行符”\n“（如cout&lt;&lt;a&lt;&lt;”\n”），则只输出和换行，而不刷新cout 流(但并不是所有编译系统都体现出这一区别）。</li><li>在iostream中只对”&lt;&lt;”和”&gt;&gt;”运算符用于标准类型数据的输入输出进行了重载，但未对用户声明的类型数据的输入输出 进行重载。如果用户声明了新的类型，并希望用”&lt;&lt;”和”&gt;&gt;”运算符对其进行输入输出，按照重运算符重载来做。</li></ol></li><li><p>cerr流对象</p><p>cerr流对象是标准错误流，cerr流已被指定为与显示器关联。cerr的 作用是向标准错误设备(standard error device)输出有关出错信息。cerr与标准输出流cout的作用和用法差不多。但有一点不同：cout流通常是传送到显示器输出，但也可以被重定向 输出到磁盘文件，而cerr流中的信息只能在显示器输出。当调试程序时，往往不希望程序运行时的出错信息被送到其他文件，而要求在显示器上及时输出，这时 应该用cerr。cerr流中的信息是用户根据需要指定的。</p></li><li><p>clog流对象</p><p>clog流对象也是标准错误流，它是console log的缩写。它的作用和cerr相同，都是在终端显示器上显示出错信息。区别：cerr是不经过缓冲区，直接向显示器上输出有关信息，而clog中的信息存放在缓冲区中，缓冲区满后或遇endl时向显示器输出。</p></li></ul><h3 id="2-1、标准输入流"><a href="#2-1、标准输入流" class="headerlink" title="2.1、标准输入流"></a>2.1、标准输入流</h3><p>标准输入流对象cin，重点掌握的函数</p><ul><li>cin.get() &#x2F;&#x2F;一次只能读取一个字符</li><li>cin.get(一个参数) &#x2F;&#x2F;读一个字符</li><li>cin.get(三个参数) &#x2F;&#x2F;可以读字符串</li><li>cin.getline()</li><li>cin.ignore()</li><li>cin.peek()</li><li>cin.putback()</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 cin cout能根据类型 获取数据 / 输出数据</span></span><br><span class="line"><span class="comment">//2 输入字符串 你 好  遇见空格,停止接受输入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> YourName[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> myInt;</span><br><span class="line"><span class="type">long</span> myLong;</span><br><span class="line"><span class="type">double</span> myDouble;</span><br><span class="line"><span class="type">float</span> myFloat;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> myUnsigned;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入一个Int: &quot;</span>;</span><br><span class="line">cin &gt;&gt; myInt;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入一个Long: &quot;</span>;</span><br><span class="line">cin &gt;&gt; myLong;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入一个Double: &quot;</span>;</span><br><span class="line">cin &gt;&gt; myDouble;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入你的姓名: &quot;</span>;</span><br><span class="line">cin &gt;&gt; YourName;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n\n你输入的数是：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Int: \t&quot;</span> &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Long: \t&quot;</span> &lt;&lt; myLong &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Double: \t&quot;</span> &lt;&lt; myDouble &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名: \t&quot;</span> &lt;&lt; YourName &lt;&lt; endl;</span><br><span class="line">cout&lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1 输入英文 ok </span></span><br><span class="line"><span class="comment">//2 ctr+z  会产生一个 EOF(-1)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">while</span>( (ch= cin.<span class="built_in">get</span>())!= EOF)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;字符: &quot;</span> &lt;&lt; ch &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;\n结束.\n&quot;</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演示:读一个字符 链式编程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> a, b, c;</span><br><span class="line">cin.<span class="built_in">get</span>(a);</span><br><span class="line">cin.<span class="built_in">get</span>(b);</span><br><span class="line">cin.<span class="built_in">get</span>(c);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; b &lt;&lt; c&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;开始链式编程&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout.<span class="built_in">flush</span>();</span><br><span class="line"></span><br><span class="line">cin.<span class="built_in">get</span>(a).<span class="built_in">get</span>(b).<span class="built_in">get</span>(c);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; b &lt;&lt; c&lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//演示cin.getline() 可以接受空格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> buf1[<span class="number">256</span>];</span><br><span class="line"><span class="type">char</span> buf2[<span class="number">256</span>]; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n请输入你的字符串 不超过256&quot;</span> ;</span><br><span class="line">cin.<span class="built_in">getline</span>(buf1, <span class="number">256</span>, <span class="string">&#x27;\n&#x27;</span>); </span><br><span class="line">cout &lt;&lt; buf1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;注意: cin.getline() 和 cin &gt;&gt; buf2 的区别, 能不能带空格 &quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; buf2 ; <span class="comment">//流提取操作符 遇见空格 停止提取输入流</span></span><br><span class="line">cout &lt;&lt; buf2 &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲区实验 </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1 输入 &quot;aa bb cc dd&quot; 字符串入缓冲区 </span></span><br><span class="line"><span class="comment">2 通过 cin &gt;&gt; buf1; 提走了 aa </span></span><br><span class="line"><span class="comment">3 不需要输入 可以再通过cin.getline() 把剩余的缓冲区数据提走</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> buf1[<span class="number">256</span>];</span><br><span class="line"><span class="type">char</span> buf2[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入带有空格的字符串,测试缓冲区&quot;</span> &lt;&lt; endl; </span><br><span class="line">cin &gt;&gt; buf1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;buf1:&quot;</span> &lt;&lt; buf1 &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入数据...&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲区没有数据,就等待; 缓冲区如果有数据直接从缓冲区中拿走数据</span></span><br><span class="line">cin.<span class="built_in">getline</span>(buf2, <span class="number">256</span>); </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;buf2:&quot;</span> &lt;&lt; buf2 &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ignore 和 peek</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>  intchar;</span><br><span class="line"><span class="type">char</span> buf1[<span class="number">256</span>];</span><br><span class="line"><span class="type">char</span> buf2[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入带有空格的字符串,测试缓冲区 aa bb cc dd ee &quot;</span> &lt;&lt; endl; </span><br><span class="line">cin &gt;&gt; buf1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;buf1:&quot;</span> &lt;&lt; buf1 &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入数据...&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin.<span class="built_in">ignore</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//intchar = cin.peek();</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;缓冲区若有数据,返回第一个数据的asc码:&quot; &lt;&lt; intchar &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲区没有数据,就等待; 缓冲区如果有数据直接从缓冲区中拿走数据</span></span><br><span class="line">cin.<span class="built_in">getline</span>(buf2, <span class="number">256</span>); </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;buf2:&quot;</span> &lt;&lt; buf2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">intchar = cin.<span class="built_in">peek</span>(); <span class="comment">//没有缓冲区 默认是阻塞模式 </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;缓冲区若有数据,返回第一个数据的asc码:&quot;</span> &lt;&lt; intchar &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//案例:输入的整数和字符串分开处理</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Please, enter a number or a word: &quot;</span>;</span><br><span class="line"><span class="type">char</span> c = std::cin.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( (c &gt;= <span class="string">&#x27;0&#x27;</span>) &amp;&amp; (c &lt;= <span class="string">&#x27;9&#x27;</span>) ) <span class="comment">//输入的整数和字符串 分开处理</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n; <span class="comment">//整数不可能 中间有空格 使用cin &gt;&gt;n</span></span><br><span class="line">cin.<span class="built_in">putback</span> (c);</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;You entered a number: &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">string str;</span><br><span class="line">cin.<span class="built_in">putback</span> (c);</span><br><span class="line"><span class="built_in">getline</span> (cin,str); <span class="comment">// //字符串 中间可能有空格 使用 cin.getline();</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;You entered a word: &quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2、标准输出流"><a href="#2-2、标准输出流" class="headerlink" title="2.2、标准输出流"></a>2.2、标准输出流</h3><p>标准输出流对象cout</p><ul><li>cout.flush()</li><li>cout.put()</li><li>cout.write()</li><li>cout.width()</li><li>cout.fill()</li><li>cout.setf(标记)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout.<span class="built_in">put</span>(<span class="string">&#x27;h&#x27;</span>).<span class="built_in">put</span>(<span class="string">&#x27;e&#x27;</span>).<span class="built_in">put</span>(<span class="string">&#x27;l&#x27;</span>).<span class="built_in">put</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">cout.<span class="built_in">write</span>(<span class="string">&quot;hello world&quot;</span>, <span class="number">4</span>); <span class="comment">//输出的长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">cout.<span class="built_in">write</span>(buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">cout.<span class="built_in">write</span>(buf, <span class="built_in">strlen</span>(buf) - <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">cout.<span class="built_in">write</span>(buf, <span class="built_in">strlen</span>(buf) + <span class="number">6</span>); <span class="comment">//给的大于buf长度 不会帮我们检查 提高速度</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用cout.setf()控制符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//使用类成员函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;start&gt;&quot;</span>;</span><br><span class="line">cout.<span class="built_in">width</span>(<span class="number">30</span>);</span><br><span class="line">cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">cout.<span class="built_in">setf</span>(ios::showbase); <span class="comment">//#include &lt;iomanip&gt;</span></span><br><span class="line">cout.<span class="built_in">setf</span>(ios::internal); <span class="comment">//设置</span></span><br><span class="line">cout &lt;&lt; hex &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="string">&quot;&lt;End&gt;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//manipulator(操作符、控制符)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用控制阀</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&lt;Start&gt;&quot;</span> </span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">30</span>) </span><br><span class="line">&lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) </span><br><span class="line">&lt;&lt; <span class="built_in">setiosflags</span>(ios::showbase) <span class="comment">//基数</span></span><br><span class="line">&lt;&lt; <span class="built_in">setiosflags</span>(ios::internal)</span><br><span class="line">&lt;&lt; hex</span><br><span class="line">&lt;&lt; <span class="number">123</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;&lt;End&gt;\n&quot;</span></span><br><span class="line">&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3、C-格式化输出控制"><a href="#2-3、C-格式化输出控制" class="headerlink" title="2.3、C++格式化输出控制"></a>2.3、C++格式化输出控制</h3><p>在输出数据时，为简便起见，往往不指定输出的格式，由系统根据数据的类型采取默认的格式，但有时希望数据按指定的格式输出，如要求以十六进制或八进制形式 输出一个 整数，对输出的小数只保留两位小数等。有两种方法可以达到此目的。</p><p>1）使用控制符的方法；</p><p>2）使用流对象的有关成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;input a:&quot;</span>;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;dec:&quot;</span>&lt;&lt;dec&lt;&lt;a&lt;&lt;endl; <span class="comment">//以十进制形式输出整数</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;hex:&quot;</span>&lt;&lt;hex&lt;&lt;a&lt;&lt;endl; <span class="comment">//以十六进制形式输出整数a</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;oct:&quot;</span>&lt;&lt;<span class="built_in">setbase</span>(<span class="number">8</span>)&lt;&lt;a&lt;&lt;endl; <span class="comment">//以八进制形式输出整数a</span></span><br><span class="line"><span class="type">char</span> *pt=<span class="string">&quot;China&quot;</span>; <span class="comment">//pt指向字符串&quot;China&quot;</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;pt&lt;&lt;endl; <span class="comment">//指定域宽为,输出字符串</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>)&lt;&lt;<span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;pt&lt;&lt;endl; <span class="comment">//指定域宽,输出字符串,空白处以&#x27;*&#x27;填充</span></span><br><span class="line"><span class="type">double</span> pi=<span class="number">22.0</span>/<span class="number">7.0</span>; <span class="comment">//计算pi值</span></span><br><span class="line"><span class="comment">//按指数形式输出,8位小数</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">setiosflags</span>(ios::scientific)&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">8</span>);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;pi=&quot;</span>&lt;&lt;pi&lt;&lt;endl; <span class="comment">//输出pi值</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;pi=&quot;</span>&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">4</span>)&lt;&lt;pi&lt;&lt;endl; <span class="comment">//改为位小数</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;pi=&quot;</span>&lt;&lt;<span class="built_in">setiosflags</span>(ios::fixed)&lt;&lt;pi&lt;&lt;endl; <span class="comment">//改为小数形式输出</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">运行结果如下：</span><br><span class="line">input a:34↙(输入a的值)</span><br><span class="line">dec:34                   (十进制形式)</span><br><span class="line">hex:22                   (十六进制形式)</span><br><span class="line">oct:42                   (八进制形式)</span><br><span class="line">         China               (域宽为)</span><br><span class="line">*****China               (域宽为,空白处以&#x27;*&#x27;填充)</span><br><span class="line">pi=3.14285714e+00        (指数形式输出,8位小数)</span><br><span class="line">pi=3.1429e+00            (指数形式输出,4位小数)</span><br><span class="line">pi=3.143                 (小数形式输出,精度仍为)</span><br></pre></td></tr></table></figure><p>在输入输出时有一些特殊的要求，如在输出实数时规定字段宽度，只保留两位小数，数据向左或向右对齐等。C++提供了在输入输出流中使用的控制符(有的书中称为操纵符)</p><p>1）标准输入输出控制符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dec  设置整数的基数为10 </span><br><span class="line">hex  设置整数的基数为16 </span><br><span class="line">oct  设置整数的基数为8 </span><br><span class="line">setbase(n)  设置整数的基数为n(n只能是16，10，8之一) </span><br><span class="line">setfill(c)  设置填充字符c，c可以是字符常量或字符变量 </span><br><span class="line">setprecision(n)  设置实数的精度为n位。在以一般十进制小数形式输出时，n代表有效数字。在以fixed(固定小数位数)形式和scientific(指数)形式输出时，n为小数位数。 </span><br><span class="line">setw(n)  设置字段宽度为n位。 </span><br><span class="line">setiosflags(ios::fixed)  设置浮点数以固定的小数位数显示。 </span><br><span class="line">setiosflags(ios::scientific)  设置浮点数以科学计数法(即指数形式)显示。 </span><br><span class="line">setiosflags(ios::left)  输出数据左对齐。 </span><br><span class="line">setiosflags(ios::right)  输出数据右对齐。 </span><br><span class="line">setiosflags(ios::shipws)  忽略前导的空格。 </span><br><span class="line">setiosflags(ios::uppercase)  在以科学计数法输出E和十六进制输出字母X时，以大写表示。 </span><br><span class="line">setiosflags(ios::showpos)  输出正数时，给出“+”号。 </span><br><span class="line">resetiosflags  终止已设置的输出格式状态，在括号中应指定内容。 </span><br></pre></td></tr></table></figure><p>2）用流对象的成员控制输出格式 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">流成员函数      与之作用相同的控制符    作用 </span><br><span class="line">precision(n)  setprecision(n)     设置实数的精度为n位。 </span><br><span class="line">width(n)      setw(n)             设置字段宽度为n位。 </span><br><span class="line">fill(c)       setfill(c)          设置填充字符c。 </span><br><span class="line">setf( )       setiosflags( )      设置输出格式状态，括号中应给出格式状态，内容与控制符setiosflags括                                   号中内容相同。 </span><br><span class="line">ubsetf( )     resetiosflags( )    终止已设置的输出格式状态。 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3）设置格式状态的格式标志 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">格式标志         作用 </span><br><span class="line">ios::left       输出数据在本域宽范围内左对齐 </span><br><span class="line">ios::right      输出数据在本域宽范围内右对齐 </span><br><span class="line">ios::internal   数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充 </span><br><span class="line">ios::dec        设置整数的基数为10 </span><br><span class="line">ios::oct        设置整数的基数为8 </span><br><span class="line">ios::hex        设置整数的基数为16 </span><br><span class="line">ios::showbase   强制输出整数的基数(八进制以0打头，十六进制以0x打头) </span><br><span class="line">ios::showpoint  强制输出浮点数的小点和尾数0 </span><br><span class="line">ios::uppercase  在以科学计数法输出E和十六进制输出字母X时，以大写表示 </span><br><span class="line">ios::showpos    输出正数时，给出“+”号。 </span><br><span class="line">ios::scientific  设置浮点数以科学计数法(即指数形式)显示 </span><br><span class="line">ios::fixed      设置浮点数以固定的小数位数显示 </span><br><span class="line">ios::unitbuf    每次输出后刷新所有流 </span><br><span class="line">ios::stdio      每次输出后清除 stdout，stderr </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="type">int</span> a=<span class="number">21</span>;</span><br><span class="line">   cout.<span class="built_in">setf</span>(ios::showbase); <span class="comment">//设置输出时的基数符号</span></span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;dec:&quot;</span>&lt;&lt;a&lt;&lt;endl; <span class="comment">//默认以十进制形式输出a</span></span><br><span class="line">   cout.<span class="built_in">unsetf</span>(ios::dec); <span class="comment">//终止十进制的格式设置</span></span><br><span class="line">   cout.<span class="built_in">setf</span>(ios::hex); <span class="comment">//设置以十六进制输出的状态</span></span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;hex:&quot;</span>&lt;&lt;a&lt;&lt;endl; <span class="comment">//以十六进制形式输出a</span></span><br><span class="line">   cout.<span class="built_in">unsetf</span>(ios::hex); <span class="comment">//终止十六进制的格式设置</span></span><br><span class="line">   cout.<span class="built_in">setf</span>(ios::oct); <span class="comment">//设置以八进制输出的状态</span></span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;oct:&quot;</span>&lt;&lt;a&lt;&lt;endl; <span class="comment">//以八进制形式输出a</span></span><br><span class="line">   cout.<span class="built_in">unsetf</span>(ios::oct); <span class="comment">//终止以八进制的输出格式设置</span></span><br><span class="line">   <span class="type">char</span> *pt=<span class="string">&quot;China&quot;</span>; <span class="comment">//pt指向字符串”china”</span></span><br><span class="line">   cout.<span class="built_in">width</span>(<span class="number">10</span>); <span class="comment">//指定域宽为10</span></span><br><span class="line">   cout&lt;&lt;pt&lt;&lt;endl; <span class="comment">//输出字符串</span></span><br><span class="line">   cout.<span class="built_in">width</span>(<span class="number">10</span>); <span class="comment">//指定域宽为10</span></span><br><span class="line">   cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>); <span class="comment">//指定空白处以&#x27;*&#x27;填充</span></span><br><span class="line">   cout&lt;&lt;pt&lt;&lt;endl; <span class="comment">//输出字符串</span></span><br><span class="line">   <span class="type">double</span> pi=<span class="number">22.0</span>/<span class="number">7.0</span>; <span class="comment">//计算pi值</span></span><br><span class="line">   cout.<span class="built_in">setf</span>(ios::scientific);<span class="comment">//指定用科学记数法输出</span></span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;pi=&quot;</span>; <span class="comment">//输出&quot;pi=&quot;</span></span><br><span class="line">   cout.<span class="built_in">width</span>(<span class="number">14</span>); <span class="comment">//指定域宽为14</span></span><br><span class="line">   cout&lt;&lt;pi&lt;&lt;endl; <span class="comment">//输出&quot;pi值</span></span><br><span class="line">   cout.<span class="built_in">unsetf</span>(ios::scientific); <span class="comment">//终止科学记数法状态</span></span><br><span class="line">   cout.<span class="built_in">setf</span>(ios::fixed); <span class="comment">//指定用定点形式输出</span></span><br><span class="line">   cout.<span class="built_in">width</span>(<span class="number">12</span>); <span class="comment">//指定域宽为12</span></span><br><span class="line">   cout.<span class="built_in">setf</span>(ios::showpos); <span class="comment">//在输出正数时显示“+”号</span></span><br><span class="line">   cout.<span class="built_in">setf</span>(ios::internal); <span class="comment">//数符出现在左侧</span></span><br><span class="line">   cout.<span class="built_in">precision</span>(<span class="number">6</span>); <span class="comment">//保留6位小数</span></span><br><span class="line">   cout&lt;&lt;pi&lt;&lt;endl; <span class="comment">//输出pi，注意数符“+”的位置</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">dec：<span class="number">21</span> (十进制形式)</span><br><span class="line">    hex：<span class="built_in">Oxl5</span> (十六进制形式，以<span class="number">0</span>x开头)</span><br><span class="line">    oct：<span class="number">025</span> (八进制形式，以O开头)</span><br><span class="line">    <span class="built_in">China</span> (域宽为<span class="number">10</span>)</span><br><span class="line">    *****<span class="built_in">china</span> (域宽为<span class="number">10</span>，空白处以<span class="string">&#x27;*&#x27;</span>填充)</span><br><span class="line">    pi=**<span class="number">3.142857e+00</span> (指数形式输出，域宽<span class="number">14</span>，默认<span class="number">6</span>位小数)</span><br><span class="line">    ****<span class="number">3.142857</span> (小数形式输㈩，精度为<span class="number">6</span>，最左侧输出数符“+”)</span><br></pre></td></tr></table></figure><p>对程序的几点说明：</p><ol><li>成员函数width(n)和控制符setw(n)只对其后的第一个输出项有效。如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">width</span>(<span class="number">6</span>);</span><br><span class="line">cout &lt;&lt;<span class="number">20</span> &lt;&lt;<span class="number">3.14</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">输出结果为 <span class="number">203.14</span></span><br></pre></td></tr></table></figure><p>在输出第一个输出项20时，域宽为6，因此在20前面有4个空格，在输出3.14时，width (6)已不起作用，此时按系统默认的域宽输出（按数据实际长度输出）。如果要求在输出数据时都按指定的同一域宽n输出，不能只调用一次width(n)， 而必须在输出每一项前都调用一次width(n&gt;），上面的程序中就是这样做的。</p><ol start="2"><li><p>在输出格式状态分为5组，每一组中同时只能选用一种（例如dec、hex和oct中只能选一，它们是互相排斥的）。在用成员函数setf和 控制符setiosflags设置输出格式状态后，如果想改设置为同组的另一状态，应当调用成员函数unsetf（对应于成员函数self）或 resetiosflags（对应于控制符setiosflags），先终止原来设置的状态。然后再设置其他状态，可以从本程序中看到这点。程序在开始虽然没有用成员函数self和控制符setiosflags设置用dec输出格式状态，但系统默认指定为dec，因此要改变为hex或oct，也应当先 用unsetf 函数终止原来设置。如果删去程序中的第7行和第10行，虽然在第8行和第11行中用成员函数setf设置了hex和oct格式，由于未终止dec格式，因 此hex和oct的设置均不起作用，系统依然以十进制形式输出。同理，程序倒数第8行的unsetf 函数的调用也是不可缺少的。</p></li><li><p>用setf 函数设置格式状态时，可以包含两个或多个格式标志，由于这些格式标志在ios类中被定义为枚举值，每一个格式标志以一个二进位代表，因此可以用位或运算符“|”组合多个格式标志。如倒数第5、第6行可以用下面一行代替：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">setf</span>(ios::internal I ios::showpos);  <span class="comment">//包含两个状态标志，用&quot;|&quot;组合</span></span><br></pre></td></tr></table></figure><p>可以看到：对输出格式的控制，既可以用控制符，也可以用cout流的有关成员函数，二者的作用是相同的。控制符是在头文件iomanip中定义的，因此用控制符时，必须包含iomanip头文件。cout流的成员函数是在头文件iostream 中定义的，因此只需包含头文件iostream，不必包含iomanip。许多程序人员感到使用控制符方便简单，可以在一个cout输出语句中连续使用多种控制符。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;C-输入输出–标准IO流&quot;&gt;&lt;a href=&quot;#C-输入输出–标准IO流&quot; class=&quot;headerlink&quot; title=&quot;C++输入输出–标准IO流&quot;&gt;&lt;/a&gt;C++输入输出–标准IO流&lt;/h1&gt;&lt;h2 id=&quot;1、I-x2F-O流的概念和流类库的结构&quot;&gt;&lt;a href=&quot;#1、I-x2F-O流的概念和流类库的结构&quot; class=&quot;headerlink&quot; title=&quot;1、I&amp;#x2F;O流的概念和流类库的结构&quot;&gt;&lt;/a&gt;1、I&amp;#x2F;O流的概念和流类库的结构&lt;/h2&gt;&lt;p&gt;输入输出：程序的输入指的是从输入文件将数据传送给程序，程序的输出指的是从程序将数据传送给输出文件。</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C++" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++异常处理</title>
    <link href="http://example.com/2022/08/31/C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2022/08/31/C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2022-08-31T07:56:51.000Z</published>
    <updated>2022-08-31T09:24:13.635Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="C-异常处理"><a href="#C-异常处理" class="headerlink" title="C++异常处理"></a>C++异常处理</h1><p>异常是一种程序控制机制，与函数机制独立和互补。<span id="more"></span></p><p>函数是一种以栈结构展开的上下函数衔接的程序控制系统，异常是另一种控制结构，它依附于栈结构，却可以同时设置多个异常类型作为网捕条件，从而以类型匹配在栈机制中跳跃回馈。</p><p>异常设计目的：栈机制是一种高度节律性控制机制，面向对象编程却要求对象之间有方向、有目的的控制传动,从一开始，异常就是冲着改变程序控制结构，以适应面向对象程序更有效地工作这个主题，而不是仅为了进行错误处理。异常设计出来之后，却发现在错误处理方面获得了最大的好处。</p><h2 id="1、c-异常处理机制"><a href="#1、c-异常处理机制" class="headerlink" title="1、c++异常处理机制"></a>1、c++异常处理机制</h2><p>对异常的处理有3个组成部 分： </p><ul><li><p>引发异常</p></li><li><p>使用处理程序捕获异常 </p></li><li><p>使用try块</p></li></ul><p><img src="https://pic.imgdb.cn/item/630f14a316f2c2beb1a1f0b7.jpg"></p><ul><li><p>C++的异常处理机制使得异常的引发和异常的处理不必在同一个函数中，这样底层的函数可以着重解决具体问题，而不必过多的考虑异常的处理。上层调用者可以再适当的位置设计对不同类型异常的处理。</p></li><li><p>异常是专门针对抽象编程中的一系列错误处理的，C++中不能借助函数机制，因为栈结构的本质是先进后出，依次访问，无法进行跳跃，但错误处理的特征却是遇到错误信息就想要转到若干级之上进行重新尝试。</p></li><li><p>异常超脱于函数机制，决定了其对函数的跨越式回跳。异常跨越函数</p></li></ul><h2 id="2、c-异常处理的实现"><a href="#2、c-异常处理的实现" class="headerlink" title="2、c++异常处理的实现"></a>2、c++异常处理的实现</h2><h3 id="2-1、c-异常处理语法"><a href="#2-1、c-异常处理语法" class="headerlink" title="2.1、c++异常处理语法"></a>2.1、c++异常处理语法</h3><p><img src="https://pic.imgdb.cn/item/630f14b616f2c2beb1a1fd13.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(...) <span class="keyword">throw</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">  &#125;<span class="built_in">catch</span>(B)&#123;</span><br><span class="line">    cout&lt;&lt;“exception B\n”;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">g</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1） 若有异常则通过throw操作创建一个异常对象并抛掷。</p><p>2） 将可能抛出异常的程序段嵌在try块之中。控制通过正常的顺序执行到达try语句，然后执行try块内的保护段。</p><p>3） 如果在保护段执行期间没有引起异常，那么跟在try块后的catch子句就不执行。程序从try块后跟随的最后一个catch子句后面的语句继续执行下去。</p><p>4） catch子句按其在try块后出现的顺序被检查。匹配的catch子句将捕获并处理异常（或继续抛掷异常）。</p><p>5） 如果匹配的处理器未找到，则运行函数terminate将被自动调用，其缺省功能是调用abort终止程序。</p><p>6）处理不了的异常，可以在catch的最后一个分支，使用throw语法，向上扔。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被零整除</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (y ==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x/y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;8/2 = &quot;</span> &lt;&lt; <span class="built_in">divide</span>(<span class="number">8</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;10/0 =&quot;</span> &lt;&lt; <span class="built_in">divide</span>(<span class="number">10</span>, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;e&quot;</span> &lt;&lt; <span class="string">&quot; is divided by zero!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;未知异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7）异常机制与函数机制互不干涉，但捕捉的方式是基于类型匹配。捕捉相当于函数返回类型的匹配，而不是函数参数的匹配，所以捕捉不用考虑一个抛掷中的多种数据类型匹配问题</p><p>比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;    </span><br><span class="line"><span class="type">double</span> d = <span class="number">2.3</span>;    </span><br><span class="line"><span class="type">char</span> str[<span class="number">20</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Please input a exception number: &quot;</span>;</span><br><span class="line"><span class="type">int</span> a; </span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line"><span class="keyword">switch</span>(a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span>  <span class="number">1</span>: </span><br><span class="line"><span class="keyword">throw</span> d;      </span><br><span class="line"><span class="keyword">case</span>  <span class="number">2</span>: </span><br><span class="line"><span class="keyword">throw</span> j;      </span><br><span class="line"><span class="keyword">case</span>  <span class="number">3</span>: </span><br><span class="line"><span class="keyword">throw</span> str;</span><br><span class="line"><span class="keyword">case</span>  <span class="number">4</span>: </span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">A</span>();      </span><br><span class="line"><span class="keyword">case</span>  <span class="number">5</span>: </span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">B</span>();</span><br><span class="line"><span class="keyword">default</span>: </span><br><span class="line">cout&lt;&lt;<span class="string">&quot;No throws here.\n&quot;</span>;    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;int exception.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">double</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;double exception.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">char</span>*)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;char* exception.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(A)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;class A exception.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(B)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;class B exception.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;That&#x27;s ok.\n&quot;</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>catch代码块必须出现在try后，并且在try块后可以出现多个catch代码块，以捕捉各种不同类型的抛掷。</p><p>异常机制是基于这样的原理：程序运行实质上是数据实体在做一些操作，因此发生异常现象的地方，一定是某个实体出了差错，该实体所对应的数据类型便作为抛掷和捕捉的依据。</p><p>8）异常捕捉严格按照类型匹配</p><p>异常捕捉的类型匹配之苛刻程度可以和模板的类型匹配媲美，它不允许相容类型的隐式转换，比如，抛掷char类型用int型就捕捉不到。例如下列代码不会输出“int exception”，从而也不会输出“That’s ok”  因为出现异常后提示退出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> ‘H’;</span><br><span class="line">  &#125;<span class="built_in">catch</span>(<span class="type">int</span>)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;int exception.\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;That&#x27;s ok.\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2、栈解旋-unwinding"><a href="#2-2、栈解旋-unwinding" class="headerlink" title="2.2、栈解旋(unwinding)"></a>2.2、栈解旋(unwinding)</h3><p>异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上的构造的所有对象，都会被自动析构。析构的顺序与构造的顺序相反。这一过程称为栈的解旋(unwinding)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;a = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Test 构造函数执行&quot;</span> &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Test 析构函数执行&quot;</span> &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunc</span><span class="params">()</span> <span class="title">throw</span> <span class="params">(MyException)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test t1;</span><br><span class="line">Test t2;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;定义了两个栈变量,异常抛出后测试栈变量的如何被析构&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上的构造的所有对象，</span></span><br><span class="line"><span class="comment">//都会被自动析构。析构的顺序与构造的顺序相反。</span></span><br><span class="line"><span class="comment">//这一过程称为栈的解旋(unwinding)</span></span><br><span class="line"><span class="keyword">try</span>  </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">myFunc</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//catch(MyException &amp;e) //这里不能访问异常对象</span></span><br><span class="line"><span class="built_in">catch</span>(MyException ) <span class="comment">//这里不能访问异常对象</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;接收到MyException类型异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(...)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;未知类型异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、异常接口声明"><a href="#3、异常接口声明" class="headerlink" title="3、异常接口声明"></a>3、异常接口声明</h2><p>1）为了加强程序的可读性，可以在函数声明中列出可能抛出的所有异常类型，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span> <span class="params">(A, B, C , D)</span></span>; <span class="comment">//这个函数func（）能够且只能抛出类型A B C D及其子类型的异常。</span></span><br></pre></td></tr></table></figure><p>2）如果在函数声明中没有包含异常接口声明，则次函数可以抛掷任何类型的异常，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>3）一个不抛掷任何类型异常的函数可以声明为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span>  <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>4） 如果一个函数抛出了它的异常接口声明所不允许抛出的异常，unexpected函数会被调用，该函数默认行为调用terminate函数中止程序。</p><h2 id="4、异常类型和异常变量的生命周期"><a href="#4、异常类型和异常变量的生命周期" class="headerlink" title="4、异常类型和异常变量的生命周期"></a>4、异常类型和异常变量的生命周期</h2><ul><li><p>throw的异常是有类型的，可以是数字、字符串、类对象。</p></li><li><p>throw的异常是有类型的，catch严格按照类型进行匹配。</p></li><li><p>异常对象的内存模型。</p></li></ul><h3 id="4-1、throw-int类型异常"><a href="#4-1、throw-int类型异常" class="headerlink" title="4.1、throw int类型异常"></a>4.1、throw int类型异常</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件的二进制copy</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">filecopy</span><span class="params">(<span class="type">char</span> *filename2, <span class="type">char</span> *filename1 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *fp1= <span class="literal">NULL</span>,  *fp2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">fp1 = <span class="built_in">fopen</span>(filename1, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp1 == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//return 1;</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fp2 = <span class="built_in">fopen</span>(filename2, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp1 == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//return 2;</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line"><span class="type">int</span>  readlen, writelen;</span><br><span class="line"><span class="keyword">while</span> ( (readlen = <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="number">256</span>, fp1)) &gt; <span class="number">0</span> ) <span class="comment">//如果读到数据，则大于0 </span></span><br><span class="line">&#123;</span><br><span class="line">writelen = <span class="built_in">fwrite</span>(buf, <span class="number">1</span>, readlen, fp2);</span><br><span class="line"><span class="keyword">if</span> (readlen != readlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//return 3;</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fclose</span>(fp1);</span><br><span class="line"><span class="built_in">fclose</span>(fp2);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2、throw字符类型异常"><a href="#4-2、throw字符类型异常" class="headerlink" title="4.2、throw字符类型异常"></a>4.2、throw字符类型异常</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件的二进制copy</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">filecopy</span><span class="params">(<span class="type">char</span> *filename2, <span class="type">char</span> *filename1 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *fp1= <span class="literal">NULL</span>,  *fp2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">fp1 = <span class="built_in">fopen</span>(filename1, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp1 == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;打开源文件时出错&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fp2 = <span class="built_in">fopen</span>(filename2, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp1 == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;打开目标文件时出错&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line"><span class="type">int</span>  readlen, writelen;</span><br><span class="line"><span class="keyword">while</span> ( (readlen = <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="number">256</span>, fp1)) &gt; <span class="number">0</span> ) <span class="comment">//如果读到数据，则大于0 </span></span><br><span class="line">&#123;</span><br><span class="line">writelen = <span class="built_in">fwrite</span>(buf, <span class="number">1</span>, readlen, fp2);</span><br><span class="line"><span class="keyword">if</span> (readlen != readlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;拷贝文件过程中失败&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fclose</span>(fp1);</span><br><span class="line"><span class="built_in">fclose</span>(fp2);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3、throw类对象类型异常"><a href="#4-3、throw类对象类型异常" class="headerlink" title="4.3、throw类对象类型异常"></a>4.3、throw类对象类型异常</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//throw int类型变量</span></span><br><span class="line"><span class="comment">//throw 字符串类型</span></span><br><span class="line"><span class="comment">//throw 类类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BadSrcFile</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">BadSrcFile</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;BadSrcFile 构造 do &quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">BadSrcFile</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;BadSrcFile 析构 do &quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BadSrcFile</span>(BadSrcFile &amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造  do &quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;aaaa&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BadDestFile</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BadCpyFile</span> &#123;&#125;;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">filecopy</span><span class="params">(<span class="type">char</span> *filename2, <span class="type">char</span> *filename1 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE *fp1= <span class="literal">NULL</span>,  *fp2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">fp1 = <span class="built_in">fopen</span>(filename1, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp1 == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//throw new BadSrcFile();</span></span><br><span class="line"><span class="keyword">throw</span>  <span class="built_in">BadSrcFile</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fp2 = <span class="built_in">fopen</span>(filename2, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp1 == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">BadDestFile</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line"><span class="type">int</span>  readlen, writelen;</span><br><span class="line"><span class="keyword">while</span> ( (readlen = <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="number">256</span>, fp1)) &gt; <span class="number">0</span> ) <span class="comment">//如果读到数据，则大于0 </span></span><br><span class="line">&#123;</span><br><span class="line">writelen = <span class="built_in">fwrite</span>(buf, <span class="number">1</span>, readlen, fp2);</span><br><span class="line"><span class="keyword">if</span> (readlen != readlen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">BadCpyFile</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fclose</span>(fp1);</span><br><span class="line"><span class="built_in">fclose</span>(fp2);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//filecopy(&quot;c:/1.txt&quot;,&quot;c:/2.txt&quot;);</span></span><br><span class="line"><span class="comment">// filecopy(&quot;c:/1.txt&quot;,&quot;c:/2.txt&quot;);</span></span><br><span class="line"> <span class="built_in">filecopy</span>(<span class="string">&quot;c:/1.txt&quot;</span>,<span class="string">&quot;c:/2.txt&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">int</span> e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;发生异常：%d \n&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span> * e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;发生异常：%s \n&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> ( BadSrcFile *e)</span><br><span class="line">&#123;</span><br><span class="line"> e-&gt;<span class="built_in">toString</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;发生异常：打开源文件时出错!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> ( BadSrcFile &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">e.<span class="built_in">toString</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;发生异常：打开源文件时出错!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> ( BadDestFile e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;发生异常：打开目标文件时出错!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> ( BadCpyFile e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;发生异常：copy时出错!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(...) <span class="comment">//抓漏网之鱼</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;发生了未知异常! 抓漏网之鱼\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//class BadSrcFile &#123;&#125;;</span></span><br><span class="line"><span class="comment">//class BadDestFile &#123;&#125;;</span></span><br><span class="line"><span class="comment">//class BadCpyFile &#123;&#125;;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、异常的层次结构-继承在异常中的应用-–-创建自己的异常类"><a href="#5、异常的层次结构-继承在异常中的应用-–-创建自己的异常类" class="headerlink" title="5、异常的层次结构(继承在异常中的应用) – 创建自己的异常类"></a>5、异常的层次结构(继承在异常中的应用) – 创建自己的异常类</h2><h3 id="5-1、exception类"><a href="#5-1、exception类" class="headerlink" title="5.1、exception类"></a>5.1、exception类</h3><p>C++异常的主要目的是为设计容错程序提供语言级支持，即异常使得在程序设计中包含错误处理功能更容易，以免事后采取一些严格的错误处理方式。异常的灵活性和相对方便性激励着程序员在条件允许的情况下在程序设计中加入错误处理功能。总之，异常是这样一种特性：类似于类，可以改变您的编程方式。 </p><p>较新的C++编译器将异常合并到语言中。例如，为支持该语言，exception头文件（以前为exception.h或except.h）定义了exception类， C++可以把它用作其他异常类的基类。代码可以引发exception异常，也可以将exception类用作基类。</p><ul><li><p>异常派生</p></li><li><p>异常中的数据：数据成员</p></li><li><p>按引用传递异常，在异常中使用虚函数</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// out_of_range</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span>  </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Teacher</span>(<span class="type">int</span> age)  <span class="comment">//构造函数, 通过异常机制 处理错误</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (age &gt; <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;年龄太大&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Teacher <span class="title">t1</span><span class="params">(<span class="number">102</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (out_of_range e)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exception e;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义异常类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyException</span>(<span class="type">const</span> <span class="type">char</span> *p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_p = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span> *  <span class="title">what</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyException: 类型&quot;</span> &lt;&lt; m_p &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> m_p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *m_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testMyExcept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyException</span>(<span class="string">&quot;函数异常&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">testMyExcept</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (MyException &amp; e)</span><br><span class="line">&#123;</span><br><span class="line">e.<span class="built_in">what</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;未知 类型 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2、标准程序库异常"><a href="#5-2、标准程序库异常" class="headerlink" title="5.2、标准程序库异常"></a>5.2、标准程序库异常</h3><p>C++标准提供了一组标准异常类，这些类以基类Exception开始，标准程序库抛出的所有异常，都派生与该基类，这些类构成如图所示的异常类的派生继承关系。该继承类提供一个成员函数what()，用于返回错误信息（返回类型为const char）。在Exception类中，what()函数的声明如下：<br>virtual const char* what() const throw();<br>该函数可以在派生类中重新定义 </p><p> 标准异常类的继承关系如下：</p><p><img src="https://pic.imgdb.cn/item/630f14f416f2c2beb1a2343f.png"></p><p>下表中列出了各个具体异常类的含义及定义它们的头文件。runtime_error和logic_error是一些具体的异常类的基类，它们分别表示两大异常类。logic_error表示那些可以在程序中被预先检测到的异常，也就是说如果小心地编写程序，这类异常能够避免；而runtime_error则表示那些难以被预先检测的异常。 </p><pre><code>                                                C++标准库各种异常类所代表的的异常</code></pre><table><thead><tr><th>异常类</th><th>头文件</th><th>异常的含义</th></tr></thead><tbody><tr><td>bad_alloc</td><td>exception</td><td>用 new 动态分配空间失败</td></tr><tr><td>bad_cast</td><td>new</td><td>执行dynamic_cast失败</td></tr><tr><td>bad_typeid</td><td>typeinfo</td><td>对某个空指针p执行 typeid(*p)</td></tr><tr><td>bad_exception</td><td>typeinfo</td><td>当某个函数fun()因在执行过程中抛出了异常声明所不允许的异常而调用unexpected()函数时，若unexpected()函数又一次抛出了fun()的异常声明所不允许的异常，且fun()的异常声明列表中有bad_exception，则会有一个bad_exception异常在fun()的调用点被抛出</td></tr><tr><td>ios_base::failure</td><td>ios</td><td>用来表示 C++ 的输入输出流执行过程中发生的错误</td></tr><tr><td>underflow_error</td><td>stdexcept</td><td>算术运算时向下溢出</td></tr><tr><td>overflow_error</td><td>stdexcept</td><td>算术运算时向上溢出</td></tr><tr><td>range_error</td><td>stdexcept</td><td>内部计算时发生作用域的错误</td></tr><tr><td>out_of_range</td><td>stdexcept</td><td>表示一个参数值不在允许的范围之内</td></tr><tr><td>length_error</td><td>stdexcept</td><td>尝试创建一个长度超过最大允许值的对象</td></tr><tr><td>invalid_argument</td><td>stdexcept</td><td>表示向函数传入无效参数</td></tr><tr><td>domain_error</td><td>stdexcept</td><td>执行一段程序所需要的先决条件不满足</td></tr></tbody></table><p> 下面的例子使用了标准程序库提供的异常类。<br>三角形面积计算<br>        编写一个计算三角形面积的函数，函数的参数为三角形三边长 a，b，c，可以用 Heron 公式计算：</p><p><img src="https://pic.imgdb.cn/item/630f186416f2c2beb1a4e376.jpg"></p><p>  在计算三角形面积的函数中需要判断输入的参数 a，b，c 是否构成一个三角形，若三角形三个边长不能构成三角形，则需要抛出异常。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//==========================================   </span></span><br><span class="line"><span class="comment">//Filename : 三角形面积计算   </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给出三角形三边长，计算三角形面积</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Area</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c)</span> <span class="title">throw</span> <span class="params">(invalid_argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//判断三角形三边长是否为正</span></span><br><span class="line"><span class="keyword">if</span> (a &lt;= <span class="number">0</span> || b &lt;= <span class="number">0</span> || c &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;the side length should be positive&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断三边长是否满足三角不等式</span></span><br><span class="line"><span class="keyword">if</span> (a + b &lt;= c || a + c &lt;= b || b + c &lt;= a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;the side length should fit the triangle inequation&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由 Heron 公式计算三角形面积</span></span><br><span class="line"><span class="type">double</span> s = (a + b + c) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>(s * (s - a) * (s - b) * (s - c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> a, b, c;<span class="comment">//三角形三边长</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Please input the side lengths of a triangle:&quot;</span>;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> s = <span class="built_in">Area</span>(a, b, c);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Area = &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (exception &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Error:&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please input the side lengths of a triangle:3 4 5</span><br><span class="line">Area = 6</span><br></pre></td></tr></table></figure><p>程序运行结果 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please input the side lengths of a triangle:0 5 5</span><br><span class="line">Error:the side length should be positive</span><br></pre></td></tr></table></figure><p>程序运行结果 3：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please input the side lengths of a triangle:<span class="number">1</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line">Error:the side length should fit the triangle inequation</span><br></pre></td></tr></table></figure><p>C++ 标准程序库对于异常处理做了如下保证：C++ 标准程序库在面对异常时，保证不会发生资源泄露，也不会破坏容器的不变特性。</p><p>1）对于以结点实现为基础的容器，如 list，set，multiset，map 和 multimap，如果结点构造失败，容器应当保持不变。同样需要保证删除结点操作不会失败。在顺序关联容器中插入多个元素时，为保证数据的有序排列，应当保证如果插入不成功，则容器元素不做任何改动。对于删除操作，确保操作成功。比如，对于列表容器，除了 remove()，remove_if()，merge()，sort() 和 unique() 之外的所有操作，要么成功，要么对容器不作任何改动。</p><p>2）对于以数组实现为基础的容器，如 vector 和 deque，在插入和删除元素时，由于有时需要调用复制构造函数和复制赋值运算符，当这些操作失败而抛出异常时，容器的不变性能不能被保证。除此以外，对于这些容器的不变特性的保证程度以结点实现为基础的容器相同。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;C-异常处理&quot;&gt;&lt;a href=&quot;#C-异常处理&quot; class=&quot;headerlink&quot; title=&quot;C++异常处理&quot;&gt;&lt;/a&gt;C++异常处理&lt;/h1&gt;&lt;p&gt;异常是一种程序控制机制，与函数机制独立和互补。</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C++" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++面向对象-多态</title>
    <link href="http://example.com/2022/08/31/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/"/>
    <id>http://example.com/2022/08/31/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81/</id>
    <published>2022-08-31T07:54:10.000Z</published>
    <updated>2022-08-31T09:23:56.823Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="面向对象–多态"><a href="#面向对象–多态" class="headerlink" title="面向对象–多态"></a>面向对象–多态</h1><h2 id="1、多态概念"><a href="#1、多态概念" class="headerlink" title="1、多态概念"></a>1、多态概念</h2><p>多态是面向对象程序设计语言中数据抽象和继承之外的第三个基本特征。<span id="more"></span></p><p>多态性(polymorphism)提供接口与具体实现之间的另一层隔离，从而将”what”和”how”分离开来。多态性改善了代码的可读性和组织性，同时也使创建的程序具有可扩展性，项目不仅在最初创建时期可以扩展，而且当项目在需要有新的功能时也能扩展。</p><p>c++支持编译时多态(静态多态)和运行时多态(动态多态)，运算符重载和函数重载就是编译时多态，而派生类和虚函数实现运行时多态。静态多态和动态多态的区别就是函数地址是早绑定(静态联编)还是晚绑定(动态联编)。如果函数的调用，在编译阶段就可以确定函数的调用地址，并产生代码，就是静态多态(编译时多态)，就是说地址是早绑定的。而如果函数的调用地址不能编译不能在编译期间确定，而需要在运行时才能决定，这这就属于晚绑定(动态多态,运行时多态)。</p><p>如果子类定义了与父类中原型相同的函数会发生什么？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Parent:print() do...&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Child:print() do...&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Child child;</span><br><span class="line">Parent *p = <span class="literal">NULL</span>;</span><br><span class="line">p = &amp;child;</span><br><span class="line">child.<span class="built_in">print</span>();</span><br><span class="line">child.Parent::<span class="built_in">print</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数重写：在子类中定义与父类中原型相同的函数。函数重写只发生在父类与子类之间。父类中被重写的函数依然会继承给子类默认情况下子类中重写的函数将隐藏父类中的函数。通过作用域分辨符::可以访问到父类中被隐藏的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Parent:print() do...&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Child:print() do...&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、在编译此函数的时，编译器不可能知道指针 p 究竟指向了什么。</span></span><br><span class="line"><span class="comment">2、编译器没有理由报错。</span></span><br><span class="line"><span class="comment">3、于是，编译器认为最安全的做法是编译到父类的print函数，因为父类和子类肯定都有相同的print函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">howToPrint</span><span class="params">(Parent* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p-&gt;<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Child child;</span><br><span class="line">Parent* pp = &amp;child;</span><br><span class="line">Parent&amp; rp = child;</span><br><span class="line"></span><br><span class="line"><span class="comment">//child.print();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过指针</span></span><br><span class="line"><span class="comment">//pp-&gt;print();</span></span><br><span class="line"><span class="comment">//通过引用</span></span><br><span class="line"><span class="comment">//rp.print();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">howToPrint</span>(&amp;child);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">run</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据实际的对象类型来判断重写函数的调用。</p><ul><li><p>如果父类指针指向的是父类对象则调用父类中定义的函数</p></li><li><p>如果父类指针指向的是子类对象则调用子类中定义的重写函数</p></li></ul><p><img src="https://pic.imgdb.cn/item/630f141616f2c2beb1a19f3a.jpg"></p><p>C++中通过virtual关键字对多态进行支持，使用virtual声明的函数被重写后即可展现多态特性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caculator</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setA</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mA = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setB</span><span class="params">(<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mB = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setOperator</span><span class="params">(string oper)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mOperator = oper;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mOperator == <span class="string">&quot;+&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> mA + mB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mOperator == <span class="string">&quot;-&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> mA - mB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mOperator == <span class="string">&quot;*&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> mA * mB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mOperator == <span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> mA / mB;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> mA;</span><br><span class="line"><span class="type">int</span> mB;</span><br><span class="line">string mOperator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这种程序不利于扩展，维护困难，如果修改功能或者扩展功能需要在源代码基础上修改</span></span><br><span class="line"><span class="comment">//面向对象程序设计一个基本原则:开闭原则(对修改关闭，对扩展开放)</span></span><br><span class="line"><span class="comment">//抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCaculator</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setA</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mA = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setB</span><span class="params">(<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mB = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> mA;</span><br><span class="line"><span class="type">int</span> mB;</span><br><span class="line">string mOperator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlusCaculator</span> : <span class="keyword">public</span> AbstractCaculator&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> mA + mB;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinusCaculator</span> : <span class="keyword">public</span> AbstractCaculator&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> mA - mB;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultipliesCaculator</span> : <span class="keyword">public</span> AbstractCaculator&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> mA * mB;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoBussiness</span><span class="params">(AbstractCaculator* caculator)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">caculator-&gt;<span class="built_in">setA</span>(a);</span><br><span class="line">caculator-&gt;<span class="built_in">setB</span>(b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;计算结果：&quot;</span> &lt;&lt; caculator-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> caculator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、向上类型转换"><a href="#2、向上类型转换" class="headerlink" title="2、向上类型转换"></a>2、向上类型转换</h2><p>对象可以作为自己的类或者作为它的基类的对象来使用。还能通过基类的地址来操作它。取一个对象的地址(指针或引用)，并将其作为基类的地址来处理，这种称为向上类型转换。也就是说：父类引用或指针可以指向子类对象，通过父类指针或引用来操作子类对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;动物在唱歌...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小狗在唱歌...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoBussiness</span><span class="params">(Animal&amp; animal)</span></span>&#123;</span><br><span class="line">animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Dog dog;</span><br><span class="line"><span class="built_in">DoBussiness</span>(dog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序运行结果是: 动物在唱歌</p><p>给DoBussiness传入的对象是dog，而不是animal对象，输出的结果应该是Dog::speak</p><p>解决这个问题，需要了解下绑定(捆绑,binding)概念。把函数体与函数调用相联系称为绑定(捆绑，binding)。</p><p>当绑定在程序运行之前(由编译器和连接器)完成时，称为早绑定(early binding).C语言中只有一种函数调用方式，就是早绑定。上面的问题就是由于早绑定引起的，因为编译器在只有Animal地址时并不知道要调用的正确函数。编译是根据指向对象的指针或引用的类型来选择函数调用。这个时候由于DoBussiness的参数类型是Animal&amp;,编译器确定了应该调用的speak是Animal::speak的，而不是真正传入的对象Dog::speak。解决方法就是迟绑定(迟捆绑,动态绑定,运行时绑定，late binding),意味着绑定要根据对象的实际类型，发生在运行。</p><p>C++语言要实现这种动态绑定，必须有某种机制来确定运行时对象的类型并调用合适的成员函数。对于一种编译语言，编译器并不知道实际的对象类型（编译器并不知道Animal类型的指针或引用指向的实际的对象类型）。</p><p>C++动态多态性是通过虚函数来实现的，虚函数允许子类（派生类）重新定义父类（基类）成员函数，而子类（派生类）重新定义父类（基类）虚函数的做法称为覆盖(override)，或者称为重写。</p><p>对于特定的函数进行动态绑定，c++要求在基类中声明这个函数的时候使用virtual关键字，动态绑定也就对virtual函数起作用。</p><ul><li><p>为创建一个需要动态绑定的虚成员函数，可以简单在这个函数声明前面加上virtual关键字，定义时候不需要。</p></li><li><p>如果一个函数在基类中被声明为virtual，那么在所有派生类中它都是virtual的。</p></li><li><p>在派生类中virtual函数的重定义称为重写(override)。</p></li><li><p>virtual关键字只能修饰成员函数。</p></li><li><p>构造函数不能为虚函数。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;动物在唱歌...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小狗在唱歌...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoBussiness</span><span class="params">(Animal&amp; animal)</span></span>&#123;</span><br><span class="line">animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Dog dog;</span><br><span class="line"><span class="built_in">DoBussiness</span>(dog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态绑定什么时候发生？所有的工作都是由编译器在幕后完成。当我们告诉通过创建一个virtual函数来告诉编译器要进行动态绑定，那么编译器就会根据动态绑定机制来实现我们的要求， 不会再执行早绑定。</p><p>C++的动态捆绑机制是怎么样的？</p><p>首先，看看编译器如何处理虚函数。当编译器发现类中有虚函数的时候，编译器会创建一张虚函数表，把虚函数的函数入口地址放到虚函数表中，并且在类中秘密增加一个指针，这个指针就是vpointer(缩写vptr)，这个指针是指向对象的虚函数表。在多态调用的时候，根据vptr指针，找到虚函数表来实现动态绑定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B类为空，那么大小应该是1字节，实际情况是这样吗？</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A size:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B size:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译阶段，编译器秘密增加了一个vptr指针，但是此时vptr指针并没有初始化指向虚函数表(vtable)，什么时候vptr才会指向虚函数表？在对象构建的时候，也就是在对象初始化调用构造函数的时候。编译器首先默认会在我们所编写的每一个构造函数中，增加一些vptr指针初始化的代码。如果没有提供构造函数，编译器会提供默认的构造函数，那么就会在默认构造函数里做此项工作，初始化vptr指针，使之指向本对象的虚函数表。</p><p>起初，子类继承基类，子类继承了基类的vptr指针，这个vptr指针是指向基类虚函数表，当子类调用构造函数，使得子类的vptr指针指向了子类的虚函数表。</p><p>多态的成立条件：</p><ul><li><p>有继承</p></li><li><p>子类重写父类虚函数函数</p><p>   a) 返回值，函数名字，函数参数，必须和父类完全一致(析构函数除外)</p><p>   b) 子类中virtual关键字可写可不写，建议写</p></li><li><p>类型兼容，父类指针，父类引用 指向 子类对象</p></li></ul><h2 id="3、抽象基类和纯虚函数-pure-virtual-function"><a href="#3、抽象基类和纯虚函数-pure-virtual-function" class="headerlink" title="3、抽象基类和纯虚函数(pure virtual function)"></a>3、抽象基类和纯虚函数(pure virtual function)</h2><p>在设计时，常常希望基类仅仅作为其派生类的一个接口。这就是说，仅想对基类进行向上类型转换，使用它的接口，而不希望用户实际的创建一个基类的对象。同时创建一个纯虚函数允许接口中放置成员原函数，而不一定要提供一段可能对这个函数毫无意义的代码。做到这点，可以在基类中加入至少一个纯虚函数(pure virtual function)，使得基类称为抽象类(abstract class)。</p><ul><li><p>纯虚函数使用关键字virtual，并在其后面加上&#x3D;0。如果试图去实例化一个抽象类，编译器则会阻止这种操作。</p></li><li><p>当继承一个抽象类的时候，必须实现所有的纯虚函数，否则由抽象类派生的类也是一个抽象类。</p></li><li><p>virtual void fun() &#x3D; 0;告诉编译器在vtable中为函数保留一个位置，但在这个特定位置不放地址。</p></li></ul><p><img src="https://pic.imgdb.cn/item/630f143716f2c2beb1a1b33f.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//规定流程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MakeDrink</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">Boil</span>();</span><br><span class="line"><span class="built_in">Brew</span>();</span><br><span class="line"><span class="built_in">PourInCup</span>();</span><br><span class="line"><span class="built_in">PutSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> AbstractDrinking&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> AbstractDrinking&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加入食盐!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoBussiness</span><span class="params">(AbstractDrinking* drink)</span></span>&#123;</span><br><span class="line">drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line"><span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">DoBussiness</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">DoBussiness</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、纯虚函数和多继承"><a href="#4、纯虚函数和多继承" class="headerlink" title="4、纯虚函数和多继承"></a>4、纯虚函数和多继承</h2><p>绝大数面向对象语言都不支持多继承，但是绝大数面向对象对象语言都支持接口的概念，c++中没有接口的概念，但是可以通过纯虚函数实现接口。接口类中只有函数原型定义，没有任何数据定义。多重继承接口不会带来二义性和复杂性问题。接口类只是一个功能声明，并不是功能实现，子类需要根据功能说明定义功能实现。除了析构函数外，其他声明都是纯虚函数。</p><h3 id="4-1、虚析构函数"><a href="#4-1、虚析构函数" class="headerlink" title="4.1、虚析构函数"></a>4.1、虚析构函数</h3><p>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">People</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;构造函数 People!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">People</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数 People!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> : <span class="keyword">public</span> People&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Worker</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;构造函数 Worker!&quot;</span> &lt;&lt; endl;</span><br><span class="line">pName = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">showName</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;打印子类的名字!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Worker</span>()&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数 Worker!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (pName != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">delete</span> pName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* pName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">People* people = <span class="keyword">new</span> Worker;</span><br><span class="line">people-&gt;~<span class="built_in">People</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2、纯虚析构函数"><a href="#4-2、纯虚析构函数" class="headerlink" title="4.2、纯虚析构函数"></a>4.2、纯虚析构函数</h3><p>纯虚析构函数在c++中是合法的，但是在使用的时候有一个额外的限制：必须为纯虚析构函数提供一个函数体。那么问题是：如果给虚析构函数提供函数体了，那怎么还能称作纯虚析构函数呢？</p><p>纯虚析构函数和非纯析构函数之间唯一的不同之处在于纯虚析构函数使得基类是抽象类，不能创建基类的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非纯虚析构函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">A</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//纯析构函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">B</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B::~<span class="built_in">B</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">A a; <span class="comment">//A类不是抽象类，可以实例化对象</span></span><br><span class="line">B b; <span class="comment">//B类是抽象类，不可以实例化对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、重载-重定义-重写"><a href="#5、重载-重定义-重写" class="headerlink" title="5、重载  重定义 重写"></a>5、重载  重定义 重写</h2><ul><li><p>重载，同一作用域的同名函数</p><p> 1）同一个作用域</p><p> 2）参数个数，参数顺序，参数类型不同</p><p>3）和函数返回值，没有关系</p><p>4）const也可以作为重载条件  &#x2F;&#x2F;do(const Teacher&amp; t){}  do(Teacher&amp; t)</p></li><li><p>重定义（隐藏）</p><p>1）有继承</p><p>2）子类（派生类）重新定义父类（基类）的同名成员（非virtual函数）</p></li><li><p>重写（覆盖）</p><p>1）有继承</p><p>2）子类（派生类）重写父类（基类）的virtual函数</p><p>3）函数返回值，函数名字，函数参数，必须和基类中的虚函数一致</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//同一作用域下，func1函数重载</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//重定义基类的func2,隐藏了基类的func2方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//重写基类的func3函数，也可以覆盖基类func3</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面向对象–多态&quot;&gt;&lt;a href=&quot;#面向对象–多态&quot; class=&quot;headerlink&quot; title=&quot;面向对象–多态&quot;&gt;&lt;/a&gt;面向对象–多态&lt;/h1&gt;&lt;h2 id=&quot;1、多态概念&quot;&gt;&lt;a href=&quot;#1、多态概念&quot; class=&quot;headerlink&quot; title=&quot;1、多态概念&quot;&gt;&lt;/a&gt;1、多态概念&lt;/h2&gt;&lt;p&gt;多态是面向对象程序设计语言中数据抽象和继承之外的第三个基本特征。</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="C++" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
</feed>
